{"ast":null,"code":"import { difference, replaceAt } from './utils.mjs';\nimport { notifyManager } from './notifyManager.mjs';\nimport { QueryObserver } from './queryObserver.mjs';\nimport { Subscribable } from './subscribable.mjs';\n\nclass QueriesObserver extends Subscribable {\n  constructor(client, queries) {\n    super();\n    this.client = client;\n    this.queries = [];\n    this.result = [];\n    this.observers = [];\n    this.observersMap = {};\n\n    if (queries) {\n      this.setQueries(queries);\n    }\n  }\n\n  onSubscribe() {\n    if (this.listeners.length === 1) {\n      this.observers.forEach(observer => {\n        observer.subscribe(result => {\n          this.onUpdate(observer, result);\n        });\n      });\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.listeners.length) {\n      this.destroy();\n    }\n  }\n\n  destroy() {\n    this.listeners = [];\n    this.observers.forEach(observer => {\n      observer.destroy();\n    });\n  }\n\n  setQueries(queries, notifyOptions) {\n    this.queries = queries;\n    notifyManager.batch(() => {\n      const prevObservers = this.observers;\n      const newObserverMatches = this.findMatchingObservers(this.queries); // set options for the new observers to notify of changes\n\n      newObserverMatches.forEach(match => match.observer.setOptions(match.defaultedQueryOptions, notifyOptions));\n      const newObservers = newObserverMatches.map(match => match.observer);\n      const newObserversMap = Object.fromEntries(newObservers.map(observer => [observer.options.queryHash, observer]));\n      const newResult = newObservers.map(observer => observer.getCurrentResult());\n      const hasIndexChange = newObservers.some((observer, index) => observer !== prevObservers[index]);\n\n      if (prevObservers.length === newObservers.length && !hasIndexChange) {\n        return;\n      }\n\n      this.observers = newObservers;\n      this.observersMap = newObserversMap;\n      this.result = newResult;\n\n      if (!this.hasListeners()) {\n        return;\n      }\n\n      difference(prevObservers, newObservers).forEach(observer => {\n        observer.destroy();\n      });\n      difference(newObservers, prevObservers).forEach(observer => {\n        observer.subscribe(result => {\n          this.onUpdate(observer, result);\n        });\n      });\n      this.notify();\n    });\n  }\n\n  getCurrentResult() {\n    return this.result;\n  }\n\n  getQueries() {\n    return this.observers.map(observer => observer.getCurrentQuery());\n  }\n\n  getObservers() {\n    return this.observers;\n  }\n\n  getOptimisticResult(queries) {\n    return this.findMatchingObservers(queries).map(match => match.observer.getOptimisticResult(match.defaultedQueryOptions));\n  }\n\n  findMatchingObservers(queries) {\n    const prevObservers = this.observers;\n    const defaultedQueryOptions = queries.map(options => this.client.defaultQueryOptions(options));\n    const matchingObservers = defaultedQueryOptions.flatMap(defaultedOptions => {\n      const match = prevObservers.find(observer => observer.options.queryHash === defaultedOptions.queryHash);\n\n      if (match != null) {\n        return [{\n          defaultedQueryOptions: defaultedOptions,\n          observer: match\n        }];\n      }\n\n      return [];\n    });\n    const matchedQueryHashes = matchingObservers.map(match => match.defaultedQueryOptions.queryHash);\n    const unmatchedQueries = defaultedQueryOptions.filter(defaultedOptions => !matchedQueryHashes.includes(defaultedOptions.queryHash));\n    const unmatchedObservers = prevObservers.filter(prevObserver => !matchingObservers.some(match => match.observer === prevObserver));\n\n    const getObserver = options => {\n      const defaultedOptions = this.client.defaultQueryOptions(options);\n      const currentObserver = this.observersMap[defaultedOptions.queryHash];\n      return currentObserver != null ? currentObserver : new QueryObserver(this.client, defaultedOptions);\n    };\n\n    const newOrReusedObservers = unmatchedQueries.map((options, index) => {\n      if (options.keepPreviousData) {\n        // return previous data from one of the observers that no longer match\n        const previouslyUsedObserver = unmatchedObservers[index];\n\n        if (previouslyUsedObserver !== undefined) {\n          return {\n            defaultedQueryOptions: options,\n            observer: previouslyUsedObserver\n          };\n        }\n      }\n\n      return {\n        defaultedQueryOptions: options,\n        observer: getObserver(options)\n      };\n    });\n\n    const sortMatchesByOrderOfQueries = (a, b) => defaultedQueryOptions.indexOf(a.defaultedQueryOptions) - defaultedQueryOptions.indexOf(b.defaultedQueryOptions);\n\n    return matchingObservers.concat(newOrReusedObservers).sort(sortMatchesByOrderOfQueries);\n  }\n\n  onUpdate(observer, result) {\n    const index = this.observers.indexOf(observer);\n\n    if (index !== -1) {\n      this.result = replaceAt(this.result, index, result);\n      this.notify();\n    }\n  }\n\n  notify() {\n    notifyManager.batch(() => {\n      this.listeners.forEach(listener => {\n        listener(this.result);\n      });\n    });\n  }\n\n}\n\nexport { QueriesObserver };","map":{"version":3,"mappings":"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","names":["QueriesObserver","Subscribable","constructor","client","queries","result","observers","observersMap","setQueries","onSubscribe","listeners","length","forEach","observer","subscribe","onUpdate","onUnsubscribe","destroy","notifyOptions","notifyManager","batch","prevObservers","newObserverMatches","findMatchingObservers","match","setOptions","defaultedQueryOptions","newObservers","map","newObserversMap","Object","fromEntries","options","queryHash","newResult","getCurrentResult","hasIndexChange","some","index","hasListeners","difference","notify","getQueries","getCurrentQuery","getObservers","getOptimisticResult","defaultQueryOptions","matchingObservers","flatMap","defaultedOptions","find","matchedQueryHashes","unmatchedQueries","filter","includes","unmatchedObservers","prevObserver","getObserver","currentObserver","QueryObserver","newOrReusedObservers","keepPreviousData","previouslyUsedObserver","undefined","sortMatchesByOrderOfQueries","a","b","indexOf","concat","sort","replaceAt","listener"],"sources":["/Users/ianbrighton/Documents/Mach 34/BattleZipsV2/BattleZipsV2-Frontend/node_modules/@tanstack/query-core/src/queriesObserver.ts"],"sourcesContent":["import { difference, replaceAt } from './utils'\nimport { notifyManager } from './notifyManager'\nimport type {\n  QueryObserverOptions,\n  QueryObserverResult,\n  DefaultedQueryObserverOptions,\n} from './types'\nimport type { QueryClient } from './queryClient'\nimport type { NotifyOptions } from './queryObserver'\nimport { QueryObserver } from './queryObserver'\nimport { Subscribable } from './subscribable'\n\ntype QueriesObserverListener = (result: QueryObserverResult[]) => void\n\nexport class QueriesObserver extends Subscribable<QueriesObserverListener> {\n  private client: QueryClient\n  private result: QueryObserverResult[]\n  private queries: QueryObserverOptions[]\n  private observers: QueryObserver[]\n  private observersMap: Record<string, QueryObserver>\n\n  constructor(client: QueryClient, queries?: QueryObserverOptions[]) {\n    super()\n\n    this.client = client\n    this.queries = []\n    this.result = []\n    this.observers = []\n    this.observersMap = {}\n\n    if (queries) {\n      this.setQueries(queries)\n    }\n  }\n\n  protected onSubscribe(): void {\n    if (this.listeners.length === 1) {\n      this.observers.forEach((observer) => {\n        observer.subscribe((result) => {\n          this.onUpdate(observer, result)\n        })\n      })\n    }\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.listeners.length) {\n      this.destroy()\n    }\n  }\n\n  destroy(): void {\n    this.listeners = []\n    this.observers.forEach((observer) => {\n      observer.destroy()\n    })\n  }\n\n  setQueries(\n    queries: QueryObserverOptions[],\n    notifyOptions?: NotifyOptions,\n  ): void {\n    this.queries = queries\n\n    notifyManager.batch(() => {\n      const prevObservers = this.observers\n\n      const newObserverMatches = this.findMatchingObservers(this.queries)\n\n      // set options for the new observers to notify of changes\n      newObserverMatches.forEach((match) =>\n        match.observer.setOptions(match.defaultedQueryOptions, notifyOptions),\n      )\n\n      const newObservers = newObserverMatches.map((match) => match.observer)\n      const newObserversMap = Object.fromEntries(\n        newObservers.map((observer) => [observer.options.queryHash, observer]),\n      )\n      const newResult = newObservers.map((observer) =>\n        observer.getCurrentResult(),\n      )\n\n      const hasIndexChange = newObservers.some(\n        (observer, index) => observer !== prevObservers[index],\n      )\n      if (prevObservers.length === newObservers.length && !hasIndexChange) {\n        return\n      }\n\n      this.observers = newObservers\n      this.observersMap = newObserversMap\n      this.result = newResult\n\n      if (!this.hasListeners()) {\n        return\n      }\n\n      difference(prevObservers, newObservers).forEach((observer) => {\n        observer.destroy()\n      })\n\n      difference(newObservers, prevObservers).forEach((observer) => {\n        observer.subscribe((result) => {\n          this.onUpdate(observer, result)\n        })\n      })\n\n      this.notify()\n    })\n  }\n\n  getCurrentResult(): QueryObserverResult[] {\n    return this.result\n  }\n\n  getQueries() {\n    return this.observers.map((observer) => observer.getCurrentQuery())\n  }\n\n  getObservers() {\n    return this.observers\n  }\n\n  getOptimisticResult(queries: QueryObserverOptions[]): QueryObserverResult[] {\n    return this.findMatchingObservers(queries).map((match) =>\n      match.observer.getOptimisticResult(match.defaultedQueryOptions),\n    )\n  }\n\n  private findMatchingObservers(\n    queries: QueryObserverOptions[],\n  ): QueryObserverMatch[] {\n    const prevObservers = this.observers\n    const defaultedQueryOptions = queries.map((options) =>\n      this.client.defaultQueryOptions(options),\n    )\n\n    const matchingObservers: QueryObserverMatch[] =\n      defaultedQueryOptions.flatMap((defaultedOptions) => {\n        const match = prevObservers.find(\n          (observer) =>\n            observer.options.queryHash === defaultedOptions.queryHash,\n        )\n        if (match != null) {\n          return [{ defaultedQueryOptions: defaultedOptions, observer: match }]\n        }\n        return []\n      })\n\n    const matchedQueryHashes = matchingObservers.map(\n      (match) => match.defaultedQueryOptions.queryHash,\n    )\n    const unmatchedQueries = defaultedQueryOptions.filter(\n      (defaultedOptions) =>\n        !matchedQueryHashes.includes(defaultedOptions.queryHash),\n    )\n\n    const unmatchedObservers = prevObservers.filter(\n      (prevObserver) =>\n        !matchingObservers.some((match) => match.observer === prevObserver),\n    )\n\n    const getObserver = (options: QueryObserverOptions): QueryObserver => {\n      const defaultedOptions = this.client.defaultQueryOptions(options)\n      const currentObserver = this.observersMap[defaultedOptions.queryHash!]\n      return currentObserver ?? new QueryObserver(this.client, defaultedOptions)\n    }\n\n    const newOrReusedObservers: QueryObserverMatch[] = unmatchedQueries.map(\n      (options, index) => {\n        if (options.keepPreviousData) {\n          // return previous data from one of the observers that no longer match\n          const previouslyUsedObserver = unmatchedObservers[index]\n          if (previouslyUsedObserver !== undefined) {\n            return {\n              defaultedQueryOptions: options,\n              observer: previouslyUsedObserver,\n            }\n          }\n        }\n        return {\n          defaultedQueryOptions: options,\n          observer: getObserver(options),\n        }\n      },\n    )\n\n    const sortMatchesByOrderOfQueries = (\n      a: QueryObserverMatch,\n      b: QueryObserverMatch,\n    ): number =>\n      defaultedQueryOptions.indexOf(a.defaultedQueryOptions) -\n      defaultedQueryOptions.indexOf(b.defaultedQueryOptions)\n\n    return matchingObservers\n      .concat(newOrReusedObservers)\n      .sort(sortMatchesByOrderOfQueries)\n  }\n\n  private onUpdate(observer: QueryObserver, result: QueryObserverResult): void {\n    const index = this.observers.indexOf(observer)\n    if (index !== -1) {\n      this.result = replaceAt(this.result, index, result)\n      this.notify()\n    }\n  }\n\n  private notify(): void {\n    notifyManager.batch(() => {\n      this.listeners.forEach((listener) => {\n        listener(this.result)\n      })\n    })\n  }\n}\n\ntype QueryObserverMatch = {\n  defaultedQueryOptions: DefaultedQueryObserverOptions\n  observer: QueryObserver\n}\n"]},"metadata":{},"sourceType":"module"}