{"ast":null,"code":"var _jsxFileName = \"/Users/ianbrighton/Documents/Mach 34/BattleZipsV2/BattleZipsV2-Frontend/src/views/Game/index.tsx\",\n    _s = $RefreshSig$();\n\nimport { useState } from 'react';\nimport { createUseStyles } from 'react-jss';\nimport MainLayout from 'layouts/MainLayout';\nimport { useNavigate, useSearchParams } from 'react-router-dom';\n// import { useGame } from 'hooks/useGame';\nimport GameSkeleton from './components/GameSkeleton'; // import { playingGame, ITx, transaction, leaveGame } from 'web3/battleshipGame';\n\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst useStyles = createUseStyles({\n  content: {\n    display: 'flex',\n    gap: '114px',\n    marginInline: 'auto',\n    width: 'fit-content'\n  },\n  eth: {\n    height: '28px',\n    width: '28px'\n  },\n  fleetLabel: {\n    alignItems: 'center',\n    borderRadius: '3px',\n    color: '#FFFFFF',\n    display: 'flex',\n    fontSize: '24px',\n    fontWeight: 700,\n    gap: '16px',\n    justifyContent: 'center',\n    lineHeight: '34.68px',\n    paddingBlock: '2px'\n  },\n  waitingForOpponent: {\n    alignItems: 'center',\n    display: 'flex',\n    fontSize: '24px',\n    fontWeight: 700,\n    height: '523px',\n    justifyContent: 'center',\n    lineHeight: '34.68px'\n  }\n});\nexport default function Game() {\n  _s();\n\n  const [searchParams] = useSearchParams();\n  const id = searchParams.get('id');\n  const styles = useStyles();\n  const navigate = useNavigate(); // const { address, chainId, provider, biconomy } = useWallet();\n  // Display GameOver component if over\n\n  const [gameOver, setGameOver] = useState({\n    over: false,\n    winner: ''\n  });\n  const [opponentShots, setOpponentShots] = useState([]);\n  const [placedShips, setPlacedShips] = useState([]);\n  const [yourShots, setYourShots] = useState([]); // const { fetching, game, refreshCount } = useGame(id ?? '');\n\n  /**\n   * Function to leave the game early. If there is not an adversary then this is simply an exit.\n   * If adversary is in game then the leave is treated as a forfeit with the adversary being treated\n   * as the winner\n   *\n   * @returns {null} - return null if initial if-statement is validated\n   */\n  // const onLeave = async () => {\n  //   if (!chainId || !id || game.status === GameStatus.Over || !provider) return;\n  //   // Game status started means that only one player is in game\n  //   const action =\n  //     game.status === GameStatus.Started ? 'Leaving' : 'Forfeiting';\n  //   let loadingToast = '';\n  //   try {\n  //     loadingToast = toast.loading(`${action} game ${id}...`);\n  //     const tx = await leaveGame(chainId, provider, Number(id));\n  //     await tx.wait();\n  //     const completedAction =\n  //       game.status === GameStatus.Started ? 'Left' : 'Forfeited';\n  //     toast.success(`${completedAction} game ${id}`, { id: loadingToast });\n  //     await delay(3000);\n  //     // Go to home location after leaving game\n  //     navigate(RootLocation);\n  //   } catch (err) {\n  //     toast.error(`Error ${action} game`, { id: loadingToast });\n  //   }\n  // };\n\n  /**\n   *\n   * @param {number[][]} board - 2d array representing ships and their placement on the bord\n   * @param {number[]} shot - array containing x and y coordinate of a shot\n   * @param {boolean} hit - whether shot has hit a ship or not\n   * @returns {Promise} - a promise containing the board hash and the proof\n   */\n  // const shotProof = async (\n  //   board: number[][],\n  //   shot: number[],\n  //   hit: boolean\n  // ): Promise<{ hash: string; proof: Buffer }> => {\n  //   // Generate Pedersen hash of ships on board\n  //   const _shipHash = await createShipHash(board);\n  //   const abi = {\n  //     hash: _shipHash,\n  //     hit: hit ? 1 : 0,\n  //     // Flatten board to 1D array\n  //     ships: board.flat(),\n  //     shot,\n  //   };\n  //   // Generate shot proof\n  //   const proof = await generateProof('shot', abi);\n  //   // TODO: Add in window verification\n  //   return { hash: _shipHash, proof };\n  // };\n\n  /**\n   * Convert ships and shot to formate friendly for proof generation\n   *\n   * @param {number[]} shotCoords - x and y coordinates of the shot\n   * @param {boolean} hit - whether or not the shot has hit a ship\n   * @returns {Buffer} - Noir proof\n   */\n  // const prepareShotProof = async (shotCoords: number[], hit: boolean) => {\n  //   const board: number[][] = [];\n  //   placedShips.forEach((ship: Ship) => {\n  //     const x = ship.sections[0] % 10;\n  //     const y = Math.floor(ship.sections[0] / 10);\n  //     const z = ship.orientation === 'x' ? 0 : 1;\n  //     board.push([x, y, z]);\n  //   });\n  //   const { proof } = await shotProof(\n  //     board,\n  //     [shotCoords[0], shotCoords[1]],\n  //     hit\n  //   );\n  //   return proof;\n  // };\n\n  /**\n   * Checks to see whether logged in user is in the request game\n   *\n   * @returns {bool} - if response id equals game id\n   */\n  // const playing = async () => {\n  //   if (!address || !chainId || !provider) return;\n  //   const res = await playingGame(chainId, provider, address);\n  //   return `${res}` === id;\n  // };\n\n  /**\n   * Restore the latest board state by loading in ship positions from local storage and shot\n   * data from subgraph\n   *\n   * @returns {null} - Exits function if game has not been fetched\n   */\n  // const restoreBoardState = () => {\n  //   if (!game) return;\n  //   // Check if chain state has been updated\n  //   const update = shouldUpdateShots();\n  //   if (update) {\n  //     const storedBoard = localStorage.getItem(`BOARD_STATE_${id}_${address}`);\n  //     if (storedBoard) {\n  //       setPlacedShips(JSON.parse(storedBoard));\n  //     }\n  //     const evenShots = game.shots\n  //       .filter((_shot: Shot, index: number) => index % 2 === 0)\n  //       .map((shot: Shot) => ({\n  //         hit: shot.hit,\n  //         turn: +shot.turn,\n  //         x: +shot.x,\n  //         y: +shot.y,\n  //       }));\n  //     const oddShots = game.shots\n  //       .filter((_shot: Shot, index: number) => index % 2 === 1)\n  //       .map((shot: Shot) => ({\n  //         hit: shot.hit,\n  //         turn: +shot.turn,\n  //         x: +shot.x,\n  //         y: +shot.y,\n  //       }));\n  //     // If game was started by logged in user then even shots are theirs, else opponents\n  //     if (game.startedBy === address) {\n  //       setOpponentShots(oddShots);\n  //       setYourShots(evenShots);\n  //     } else {\n  //       setOpponentShots(evenShots);\n  //       setYourShots(oddShots);\n  //     }\n  //   }\n  // };\n\n  /**\n   * Memoized value to render board once an opponent has joined\n   */\n  // const showOpponentBoard = useMemo(() => {\n  //   if (!address || !game) return false;\n  //   return (\n  //     (game.startedBy === address && game.joinedBy) ||\n  //     game.startedBy !== address\n  //   );\n  // }, [address, game]);\n\n  /**\n   * Wrapper for smart contract function to take shot\n   *\n   * @param { Shot } shot - Shot with coordinate, turn number, and hit confirmation\n   * @returns {null} - function exits if chainId or eth provider are undefined\n   */\n  // const takeShot = async (shot: Shot) => {\n  //   if (!chainId || !provider) return;\n  //   setYourShots((prev) => [...prev, shot].sort((a, b) => b.turn - a.turn));\n  //   let loadingToast = '';\n  //   try {\n  //     // Check if shot is first shot of game\n  //     const first = !opponentShots.length && !yourShots.length;\n  //     // If shot is first shot then no proof is generated as hit needs to be reported by\n  //     // adversary\n  //     if (first) {\n  //       loadingToast = toast.loading('Firing shot...');\n  //       const params = [+game.id, [shot.x, shot.y]];\n  //       // If biconomy is enabled then trigger meta transaction\n  //       if (biconomy) {\n  //         const metatx: IMetaTx = {\n  //           provider,\n  //           biconomy,\n  //           functionName: 'firstTurn',\n  //           args: params,\n  //         };\n  //         await metatransaction(metatx);\n  //       } else {\n  //         const tx: ITx = {\n  //           provider,\n  //           functionName: 'firstTurn',\n  //           args: params,\n  //         };\n  //         await transaction(tx);\n  //       }\n  //     } else {\n  //       loadingToast = toast.loading('Generating shot proof...');\n  //       // Last shot is reported into shot proof\n  //       const lastShot = opponentShots[opponentShots.length - 1];\n  //       // Check if shot coordinates correspond to one of user's ship\n  //       const hit = !!wasHit(lastShot.x + lastShot.y * 10);\n  //       const proof = await prepareShotProof([lastShot.x, lastShot.y], hit);\n  //       toast.loading('Firing shot...', { id: loadingToast });\n  //       const params = [+game.id, hit, [shot.x, shot.y], proof];\n  //       // If biconomy is enabled then trigger meta transaction\n  //       if (biconomy) {\n  //         const metatx: IMetaTx = {\n  //           provider,\n  //           biconomy,\n  //           functionName: 'turn',\n  //           args: params,\n  //         };\n  //         await metatransaction(metatx);\n  //       } else {\n  //         const tx: ITx = {\n  //           provider,\n  //           functionName: 'turn',\n  //           args: params,\n  //         };\n  //         await transaction(tx);\n  //       }\n  //     }\n  //     toast.success('Shot fired', { id: loadingToast });\n  //   } catch (err) {\n  //     console.log('Err: ', err);\n  //     toast.error('Error firing shot', { id: loadingToast });\n  //     // Reset shots rendered on opponent board\n  //     setYourShots((prev) => prev.filter((prevShot) => prevShot !== shot));\n  //   }\n  // };\n\n  /**\n   * Memoized value of total turns in a game\n   */\n  // const totalTurns = useMemo(() => {\n  //   return opponentShots.length + yourShots.length;\n  // }, [opponentShots, yourShots]);\n\n  /**\n   *\n   * @param {number} tile - tile coordinate calculated from x and y\n   * @returns\n   */\n  // const wasHit = (tile: number) => {\n  //   return placedShips.find((ship) => ship.sections.includes(tile));\n  // };\n\n  /**\n   * Function to check whether the board state should be re-rendered on UI. Checks if no prior shots\n   * or if new shot length from subgraph is greater than existing shots in state variables\n   *\n   * @returns {boolean} - whether board should be updated\n   */\n  // const shouldUpdateShots = () => {\n  //   const newShotLength = game.shots.length;\n  //   const oldShotLength = opponentShots.length + yourShots.length;\n  //   return !oldShotLength || newShotLength > oldShotLength;\n  // };\n\n  /**\n   * Memoized value to determine if turn is yours or not\n   */\n  // const yourTurn = useMemo(() => {\n  //   if (!game) return false;\n  //   const totalShots = totalTurns;\n  //   return game.startedBy === address\n  //     ? totalShots % 2 === 0\n  //     : totalShots % 2 === 1;\n  // }, [address, game, totalTurns]);\n  // useEffect(() => {\n  //   (async () => {\n  //     if (!fetching) {\n  //       if (game) {\n  //         const historic = game.status === 'OVER';\n  //         // Check is user is in game\n  //         const inGame = await playing();\n  //         // Kick user to home if not in game\n  //         if (!historic && !inGame) {\n  //           navigate(RootLocation);\n  //           // If game is historic and user is in game then show \"GameOver\" compoenent\n  //         } else if (historic && inGame) {\n  //           setGameOver({ over: true, winner: game.winner });\n  //         } else {\n  //           restoreBoardState();\n  //         }\n  //       } else {\n  //         navigate(RootLocation);\n  //       }\n  //     }\n  //   })();\n  //   // eslint-disable-next-line\n  // }, [address, fetching, game, id, navigate]);\n\n  return /*#__PURE__*/_jsxDEV(MainLayout, {\n    children: true ? /*#__PURE__*/_jsxDEV(GameSkeleton, {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 345,\n      columnNumber: 9\n    }, this) : gameOver.over ?\n    /*#__PURE__*/\n    // <GameOver winner={gameOver.winner === address} />\n    _jsxDEV(_Fragment, {}, void 0, false) : /*#__PURE__*/_jsxDEV(\"div\", {\n      children: /*#__PURE__*/_jsxDEV(\"div\", {\n        className: styles.content,\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            width: '523px'\n          },\n          children: [/*#__PURE__*/_jsxDEV(\"div\", {\n            className: styles.fleetLabel,\n            style: {\n              background: '#717C96'\n            },\n            children: \"OPPONENT\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 353,\n            columnNumber: 15\n          }, this), true ?\n          /*#__PURE__*/\n          // <OpponentBoard\n          //   shots={yourShots}\n          //   takeShot={takeShot}\n          //   totalTurns={totalTurns}\n          //   yourTurn={yourTurn}\n          // />\n          _jsxDEV(_Fragment, {}, void 0, false) : /*#__PURE__*/_jsxDEV(\"div\", {\n            className: styles.waitingForOpponent,\n            children: \"WAITING FOR OPPONENT\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 372,\n            columnNumber: 17\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 352,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            width: '523px'\n          },\n          children: /*#__PURE__*/_jsxDEV(\"div\", {\n            className: styles.fleetLabel,\n            style: {\n              background: '#FF0055'\n            },\n            children: \"YOUR FLEET\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 378,\n            columnNumber: 15\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 377,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 351,\n        columnNumber: 11\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 350,\n      columnNumber: 9\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 343,\n    columnNumber: 5\n  }, this);\n}\n\n_s(Game, \"Q3/sCCUj9TqS734YSkUXtzKyb6U=\", false, function () {\n  return [useSearchParams, useStyles, useNavigate];\n});\n\n_c = Game;\n\nvar _c;\n\n$RefreshReg$(_c, \"Game\");","map":{"version":3,"sources":["/Users/ianbrighton/Documents/Mach 34/BattleZipsV2/BattleZipsV2-Frontend/src/views/Game/index.tsx"],"names":["useState","createUseStyles","MainLayout","useNavigate","useSearchParams","GameSkeleton","useStyles","content","display","gap","marginInline","width","eth","height","fleetLabel","alignItems","borderRadius","color","fontSize","fontWeight","justifyContent","lineHeight","paddingBlock","waitingForOpponent","Game","searchParams","id","get","styles","navigate","gameOver","setGameOver","over","winner","opponentShots","setOpponentShots","placedShips","setPlacedShips","yourShots","setYourShots","background"],"mappings":";;;AAAA,SAA6BA,QAA7B,QAA6C,OAA7C;AACA,SAASC,eAAT,QAAgC,WAAhC;AAGA,OAAOC,UAAP,MAAuB,oBAAvB;AAEA,SAASC,WAAT,EAAsBC,eAAtB,QAA6C,kBAA7C;AAEA;AACA,OAAOC,YAAP,MAAyB,2BAAzB,C,CACA;;;;AASA,MAAMC,SAAS,GAAGL,eAAe,CAAC;AAChCM,EAAAA,OAAO,EAAE;AACPC,IAAAA,OAAO,EAAE,MADF;AAEPC,IAAAA,GAAG,EAAE,OAFE;AAGPC,IAAAA,YAAY,EAAE,MAHP;AAIPC,IAAAA,KAAK,EAAE;AAJA,GADuB;AAOhCC,EAAAA,GAAG,EAAE;AACHC,IAAAA,MAAM,EAAE,MADL;AAEHF,IAAAA,KAAK,EAAE;AAFJ,GAP2B;AAWhCG,EAAAA,UAAU,EAAE;AACVC,IAAAA,UAAU,EAAE,QADF;AAEVC,IAAAA,YAAY,EAAE,KAFJ;AAGVC,IAAAA,KAAK,EAAE,SAHG;AAIVT,IAAAA,OAAO,EAAE,MAJC;AAKVU,IAAAA,QAAQ,EAAE,MALA;AAMVC,IAAAA,UAAU,EAAE,GANF;AAOVV,IAAAA,GAAG,EAAE,MAPK;AAQVW,IAAAA,cAAc,EAAE,QARN;AASVC,IAAAA,UAAU,EAAE,SATF;AAUVC,IAAAA,YAAY,EAAE;AAVJ,GAXoB;AAuBhCC,EAAAA,kBAAkB,EAAE;AAClBR,IAAAA,UAAU,EAAE,QADM;AAElBP,IAAAA,OAAO,EAAE,MAFS;AAGlBU,IAAAA,QAAQ,EAAE,MAHQ;AAIlBC,IAAAA,UAAU,EAAE,GAJM;AAKlBN,IAAAA,MAAM,EAAE,OALU;AAMlBO,IAAAA,cAAc,EAAE,QANE;AAOlBC,IAAAA,UAAU,EAAE;AAPM;AAvBY,CAAD,CAAjC;AAkCA,eAAe,SAASG,IAAT,GAA6B;AAAA;;AAC1C,QAAM,CAACC,YAAD,IAAiBrB,eAAe,EAAtC;AACA,QAAMsB,EAAE,GAAGD,YAAY,CAACE,GAAb,CAAiB,IAAjB,CAAX;AACA,QAAMC,MAAM,GAAGtB,SAAS,EAAxB;AACA,QAAMuB,QAAQ,GAAG1B,WAAW,EAA5B,CAJ0C,CAK1C;AACA;;AACA,QAAM,CAAC2B,QAAD,EAAWC,WAAX,IAA0B/B,QAAQ,CAAC;AAAEgC,IAAAA,IAAI,EAAE,KAAR;AAAeC,IAAAA,MAAM,EAAE;AAAvB,GAAD,CAAxC;AACA,QAAM,CAACC,aAAD,EAAgBC,gBAAhB,IAAoCnC,QAAQ,CAAS,EAAT,CAAlD;AACA,QAAM,CAACoC,WAAD,EAAcC,cAAd,IAAgCrC,QAAQ,CAAS,EAAT,CAA9C;AACA,QAAM,CAACsC,SAAD,EAAYC,YAAZ,IAA4BvC,QAAQ,CAAS,EAAT,CAA1C,CAV0C,CAW1C;;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACF;AACA;AACA;AACA;AACE;AACA;AACA;AACA;AACA;;AAEA;AACF;AACA;AACA;AACA;AACA;AACE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACF;AACA;AACE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACF;AACA;AACA;AACA;AACA;AACE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACF;AACA;AACE;AACA;AACA;;AAEA;AACF;AACA;AACA;AACA;AACE;AACA;AACA;;AAEA;AACF;AACA;AACA;AACA;AACA;AACE;AACA;AACA;AACA;AACA;;AAEA;AACF;AACA;AACE;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,sBACE,QAAC,UAAD;AAAA,cACG,oBACC,QAAC,YAAD;AAAA;AAAA;AAAA;AAAA,YADD,GAEG8B,QAAQ,CAACE,IAAT;AAAA;AACF;AACA,yCAFE,gBAIF;AAAA,6BACE;AAAK,QAAA,SAAS,EAAEJ,MAAM,CAACrB,OAAvB;AAAA,gCACE;AAAK,UAAA,KAAK,EAAE;AAAEI,YAAAA,KAAK,EAAE;AAAT,WAAZ;AAAA,kCACE;AACE,YAAA,SAAS,EAAEiB,MAAM,CAACd,UADpB;AAEE,YAAA,KAAK,EAAE;AAAE0B,cAAAA,UAAU,EAAE;AAAd,aAFT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBADF,EAWG;AAAA;AACC;AACA;AACA;AACA;AACA;AACA;AACA,+CAPD,gBASC;AAAK,YAAA,SAAS,EAAEZ,MAAM,CAACL,kBAAvB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBApBJ;AAAA;AAAA;AAAA;AAAA;AAAA,gBADF,eA0BE;AAAK,UAAA,KAAK,EAAE;AAAEZ,YAAAA,KAAK,EAAE;AAAT,WAAZ;AAAA,iCACE;AACE,YAAA,SAAS,EAAEiB,MAAM,CAACd,UADpB;AAEE,YAAA,KAAK,EAAE;AAAE0B,cAAAA,UAAU,EAAE;AAAd,aAFT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADF;AAAA;AAAA;AAAA;AAAA,gBA1BF;AAAA;AAAA;AAAA;AAAA;AAAA;AADF;AAAA;AAAA;AAAA;AAAA;AAPJ;AAAA;AAAA;AAAA;AAAA,UADF;AA2DD;;GA3VuBhB,I;UACCpB,e,EAERE,S,EACEH,W;;;KAJKqB,I","sourcesContent":["import { useEffect, useMemo, useState } from 'react';\nimport { createUseStyles } from 'react-jss';\nimport Board from 'components/Board';\nimport { Ship } from 'components/Board/types';\nimport MainLayout from 'layouts/MainLayout';\nimport OpponentBoard from 'components/Board/OpponentBoard';\nimport { useNavigate, useSearchParams } from 'react-router-dom';\nimport { RootLocation } from 'Locations';\n// import { useGame } from 'hooks/useGame';\nimport GameSkeleton from './components/GameSkeleton';\n// import { playingGame, ITx, transaction, leaveGame } from 'web3/battleshipGame';\nimport eth from 'images/eth.svg';\n// import { IMetaTx, metatransaction } from 'web3/erc2771';\nimport { Shot } from './types';\nimport { toast } from 'react-hot-toast';\nimport GameOver from './components/GameOver';\nimport { delay } from 'utils';\nimport { GameStatus } from 'utils/constants';\n\nconst useStyles = createUseStyles({\n  content: {\n    display: 'flex',\n    gap: '114px',\n    marginInline: 'auto',\n    width: 'fit-content',\n  },\n  eth: {\n    height: '28px',\n    width: '28px',\n  },\n  fleetLabel: {\n    alignItems: 'center',\n    borderRadius: '3px',\n    color: '#FFFFFF',\n    display: 'flex',\n    fontSize: '24px',\n    fontWeight: 700,\n    gap: '16px',\n    justifyContent: 'center',\n    lineHeight: '34.68px',\n    paddingBlock: '2px',\n  },\n  waitingForOpponent: {\n    alignItems: 'center',\n    display: 'flex',\n    fontSize: '24px',\n    fontWeight: 700,\n    height: '523px',\n    justifyContent: 'center',\n    lineHeight: '34.68px',\n  },\n});\n\nexport default function Game(): JSX.Element {\n  const [searchParams] = useSearchParams();\n  const id = searchParams.get('id');\n  const styles = useStyles();\n  const navigate = useNavigate();\n  // const { address, chainId, provider, biconomy } = useWallet();\n  // Display GameOver component if over\n  const [gameOver, setGameOver] = useState({ over: false, winner: '' });\n  const [opponentShots, setOpponentShots] = useState<Shot[]>([]);\n  const [placedShips, setPlacedShips] = useState<Ship[]>([]);\n  const [yourShots, setYourShots] = useState<Shot[]>([]);\n  // const { fetching, game, refreshCount } = useGame(id ?? '');\n\n  /**\n   * Function to leave the game early. If there is not an adversary then this is simply an exit.\n   * If adversary is in game then the leave is treated as a forfeit with the adversary being treated\n   * as the winner\n   *\n   * @returns {null} - return null if initial if-statement is validated\n   */\n  // const onLeave = async () => {\n  //   if (!chainId || !id || game.status === GameStatus.Over || !provider) return;\n  //   // Game status started means that only one player is in game\n  //   const action =\n  //     game.status === GameStatus.Started ? 'Leaving' : 'Forfeiting';\n  //   let loadingToast = '';\n  //   try {\n  //     loadingToast = toast.loading(`${action} game ${id}...`);\n  //     const tx = await leaveGame(chainId, provider, Number(id));\n  //     await tx.wait();\n  //     const completedAction =\n  //       game.status === GameStatus.Started ? 'Left' : 'Forfeited';\n  //     toast.success(`${completedAction} game ${id}`, { id: loadingToast });\n  //     await delay(3000);\n  //     // Go to home location after leaving game\n  //     navigate(RootLocation);\n  //   } catch (err) {\n  //     toast.error(`Error ${action} game`, { id: loadingToast });\n  //   }\n  // };\n\n  /**\n   *\n   * @param {number[][]} board - 2d array representing ships and their placement on the bord\n   * @param {number[]} shot - array containing x and y coordinate of a shot\n   * @param {boolean} hit - whether shot has hit a ship or not\n   * @returns {Promise} - a promise containing the board hash and the proof\n   */\n  // const shotProof = async (\n  //   board: number[][],\n  //   shot: number[],\n  //   hit: boolean\n  // ): Promise<{ hash: string; proof: Buffer }> => {\n  //   // Generate Pedersen hash of ships on board\n  //   const _shipHash = await createShipHash(board);\n  //   const abi = {\n  //     hash: _shipHash,\n  //     hit: hit ? 1 : 0,\n  //     // Flatten board to 1D array\n  //     ships: board.flat(),\n  //     shot,\n  //   };\n  //   // Generate shot proof\n  //   const proof = await generateProof('shot', abi);\n  //   // TODO: Add in window verification\n  //   return { hash: _shipHash, proof };\n  // };\n\n  /**\n   * Convert ships and shot to formate friendly for proof generation\n   *\n   * @param {number[]} shotCoords - x and y coordinates of the shot\n   * @param {boolean} hit - whether or not the shot has hit a ship\n   * @returns {Buffer} - Noir proof\n   */\n  // const prepareShotProof = async (shotCoords: number[], hit: boolean) => {\n  //   const board: number[][] = [];\n  //   placedShips.forEach((ship: Ship) => {\n  //     const x = ship.sections[0] % 10;\n  //     const y = Math.floor(ship.sections[0] / 10);\n  //     const z = ship.orientation === 'x' ? 0 : 1;\n  //     board.push([x, y, z]);\n  //   });\n  //   const { proof } = await shotProof(\n  //     board,\n  //     [shotCoords[0], shotCoords[1]],\n  //     hit\n  //   );\n  //   return proof;\n  // };\n\n  /**\n   * Checks to see whether logged in user is in the request game\n   *\n   * @returns {bool} - if response id equals game id\n   */\n  // const playing = async () => {\n  //   if (!address || !chainId || !provider) return;\n  //   const res = await playingGame(chainId, provider, address);\n  //   return `${res}` === id;\n  // };\n\n  /**\n   * Restore the latest board state by loading in ship positions from local storage and shot\n   * data from subgraph\n   *\n   * @returns {null} - Exits function if game has not been fetched\n   */\n  // const restoreBoardState = () => {\n  //   if (!game) return;\n  //   // Check if chain state has been updated\n  //   const update = shouldUpdateShots();\n  //   if (update) {\n  //     const storedBoard = localStorage.getItem(`BOARD_STATE_${id}_${address}`);\n  //     if (storedBoard) {\n  //       setPlacedShips(JSON.parse(storedBoard));\n  //     }\n  //     const evenShots = game.shots\n  //       .filter((_shot: Shot, index: number) => index % 2 === 0)\n  //       .map((shot: Shot) => ({\n  //         hit: shot.hit,\n  //         turn: +shot.turn,\n  //         x: +shot.x,\n  //         y: +shot.y,\n  //       }));\n  //     const oddShots = game.shots\n  //       .filter((_shot: Shot, index: number) => index % 2 === 1)\n  //       .map((shot: Shot) => ({\n  //         hit: shot.hit,\n  //         turn: +shot.turn,\n  //         x: +shot.x,\n  //         y: +shot.y,\n  //       }));\n  //     // If game was started by logged in user then even shots are theirs, else opponents\n  //     if (game.startedBy === address) {\n  //       setOpponentShots(oddShots);\n  //       setYourShots(evenShots);\n  //     } else {\n  //       setOpponentShots(evenShots);\n  //       setYourShots(oddShots);\n  //     }\n  //   }\n  // };\n\n  /**\n   * Memoized value to render board once an opponent has joined\n   */\n  // const showOpponentBoard = useMemo(() => {\n  //   if (!address || !game) return false;\n  //   return (\n  //     (game.startedBy === address && game.joinedBy) ||\n  //     game.startedBy !== address\n  //   );\n  // }, [address, game]);\n\n  /**\n   * Wrapper for smart contract function to take shot\n   *\n   * @param { Shot } shot - Shot with coordinate, turn number, and hit confirmation\n   * @returns {null} - function exits if chainId or eth provider are undefined\n   */\n  // const takeShot = async (shot: Shot) => {\n  //   if (!chainId || !provider) return;\n  //   setYourShots((prev) => [...prev, shot].sort((a, b) => b.turn - a.turn));\n  //   let loadingToast = '';\n  //   try {\n  //     // Check if shot is first shot of game\n  //     const first = !opponentShots.length && !yourShots.length;\n  //     // If shot is first shot then no proof is generated as hit needs to be reported by\n  //     // adversary\n  //     if (first) {\n  //       loadingToast = toast.loading('Firing shot...');\n  //       const params = [+game.id, [shot.x, shot.y]];\n  //       // If biconomy is enabled then trigger meta transaction\n  //       if (biconomy) {\n  //         const metatx: IMetaTx = {\n  //           provider,\n  //           biconomy,\n  //           functionName: 'firstTurn',\n  //           args: params,\n  //         };\n  //         await metatransaction(metatx);\n  //       } else {\n  //         const tx: ITx = {\n  //           provider,\n  //           functionName: 'firstTurn',\n  //           args: params,\n  //         };\n  //         await transaction(tx);\n  //       }\n  //     } else {\n  //       loadingToast = toast.loading('Generating shot proof...');\n  //       // Last shot is reported into shot proof\n  //       const lastShot = opponentShots[opponentShots.length - 1];\n  //       // Check if shot coordinates correspond to one of user's ship\n  //       const hit = !!wasHit(lastShot.x + lastShot.y * 10);\n  //       const proof = await prepareShotProof([lastShot.x, lastShot.y], hit);\n  //       toast.loading('Firing shot...', { id: loadingToast });\n  //       const params = [+game.id, hit, [shot.x, shot.y], proof];\n  //       // If biconomy is enabled then trigger meta transaction\n  //       if (biconomy) {\n  //         const metatx: IMetaTx = {\n  //           provider,\n  //           biconomy,\n  //           functionName: 'turn',\n  //           args: params,\n  //         };\n  //         await metatransaction(metatx);\n  //       } else {\n  //         const tx: ITx = {\n  //           provider,\n  //           functionName: 'turn',\n  //           args: params,\n  //         };\n  //         await transaction(tx);\n  //       }\n  //     }\n  //     toast.success('Shot fired', { id: loadingToast });\n  //   } catch (err) {\n  //     console.log('Err: ', err);\n  //     toast.error('Error firing shot', { id: loadingToast });\n  //     // Reset shots rendered on opponent board\n  //     setYourShots((prev) => prev.filter((prevShot) => prevShot !== shot));\n  //   }\n  // };\n\n  /**\n   * Memoized value of total turns in a game\n   */\n  // const totalTurns = useMemo(() => {\n  //   return opponentShots.length + yourShots.length;\n  // }, [opponentShots, yourShots]);\n\n  /**\n   *\n   * @param {number} tile - tile coordinate calculated from x and y\n   * @returns\n   */\n  // const wasHit = (tile: number) => {\n  //   return placedShips.find((ship) => ship.sections.includes(tile));\n  // };\n\n  /**\n   * Function to check whether the board state should be re-rendered on UI. Checks if no prior shots\n   * or if new shot length from subgraph is greater than existing shots in state variables\n   *\n   * @returns {boolean} - whether board should be updated\n   */\n  // const shouldUpdateShots = () => {\n  //   const newShotLength = game.shots.length;\n  //   const oldShotLength = opponentShots.length + yourShots.length;\n  //   return !oldShotLength || newShotLength > oldShotLength;\n  // };\n\n  /**\n   * Memoized value to determine if turn is yours or not\n   */\n  // const yourTurn = useMemo(() => {\n  //   if (!game) return false;\n  //   const totalShots = totalTurns;\n  //   return game.startedBy === address\n  //     ? totalShots % 2 === 0\n  //     : totalShots % 2 === 1;\n  // }, [address, game, totalTurns]);\n\n  // useEffect(() => {\n  //   (async () => {\n  //     if (!fetching) {\n  //       if (game) {\n  //         const historic = game.status === 'OVER';\n  //         // Check is user is in game\n  //         const inGame = await playing();\n  //         // Kick user to home if not in game\n  //         if (!historic && !inGame) {\n  //           navigate(RootLocation);\n  //           // If game is historic and user is in game then show \"GameOver\" compoenent\n  //         } else if (historic && inGame) {\n  //           setGameOver({ over: true, winner: game.winner });\n  //         } else {\n  //           restoreBoardState();\n  //         }\n  //       } else {\n  //         navigate(RootLocation);\n  //       }\n  //     }\n  //   })();\n  //   // eslint-disable-next-line\n  // }, [address, fetching, game, id, navigate]);\n  return (\n    <MainLayout>\n      {true ? (\n        <GameSkeleton />\n      ) : gameOver.over ? (\n        // <GameOver winner={gameOver.winner === address} />\n        <></>\n      ) : (\n        <div>\n          <div className={styles.content}>\n            <div style={{ width: '523px' }}>\n              <div\n                className={styles.fleetLabel}\n                style={{ background: '#717C96' }}\n              >\n                OPPONENT\n                {/* {!yourTurn && (\n                  <img alt='Eth' className={styles.eth} src={eth} />\n                )} */}\n              </div>\n              {/* {showOpponentBoard ? ( */}\n              {true ? (\n                // <OpponentBoard\n                //   shots={yourShots}\n                //   takeShot={takeShot}\n                //   totalTurns={totalTurns}\n                //   yourTurn={yourTurn}\n                // />\n                <></>\n              ) : (\n                <div className={styles.waitingForOpponent}>\n                  WAITING FOR OPPONENT\n                </div>\n              )}\n            </div>\n            <div style={{ width: '523px' }}>\n              <div\n                className={styles.fleetLabel}\n                style={{ background: '#FF0055' }}\n              >\n                YOUR FLEET\n                {/* {yourTurn && <img alt='Eth' className={styles.eth} src={eth} />} */}\n              </div>\n              {/* <Board\n                allPlaced={true}\n                onLeave={onLeave}\n                opponentShots={opponentShots}\n                placedShips={placedShips}\n                rotationAxis={''}\n                selectedShip={{} as Ship}\n                setPlacedShip={() => null}\n                status={game?.status}\n              /> */}\n            </div>\n          </div>\n        </div>\n      )}\n    </MainLayout>\n  );\n}\n"]},"metadata":{},"sourceType":"module"}