{"ast":null,"code":"/**\n * Copyright 2021 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Note: we use `wasm_bindgen_worker_`-prefixed message types to make sure\n// we can handle bundling into other files, which might happen to have their\n// own `postMessage`/`onmessage` communication channels.\n//\n// If we didn't take that into the account, we could send much simpler signals\n// like just `0` or whatever, but the code would be less resilient.\nfunction waitForMsgType(target, type) {\n  return new Promise(resolve => {\n    target.addEventListener('message', function onMsg(_ref) {\n      let {\n        data\n      } = _ref;\n      if (data == null || data.type !== type) return;\n      target.removeEventListener('message', onMsg);\n      resolve(data);\n    });\n  });\n}\n\nwaitForMsgType(self, 'wasm_bindgen_worker_init').then(async data => {\n  // # Note 1\n  // Our JS should have been generated in\n  // `[out-dir]/snippets/wasm-bindgen-rayon-[hash]/workerHelpers.js`,\n  // resolve the main module via `../../..`.\n  //\n  // This might need updating if the generated structure changes on wasm-bindgen\n  // side ever in the future, but works well with bundlers today. The whole\n  // point of this crate, after all, is to abstract away unstable features\n  // and temporary bugs so that you don't need to deal with them in your code.\n  //\n  // # Note 2\n  // This could be a regular import, but then some bundlers complain about\n  // circular deps.\n  //\n  // Dynamic import could be cheap if this file was inlined into the parent,\n  // which would require us just using `../../..` in `new Worker` below,\n  // but that doesn't work because wasm-pack unconditionally adds\n  // \"sideEffects\":false (see below).\n  //\n  // OTOH, even though it can't be inlined, it should be still reasonably\n  // cheap since the requested file is already in cache (it was loaded by\n  // the main thread).\n  const pkg = await import('../../..');\n  await pkg.default(data.module, data.memory);\n  postMessage({\n    type: 'wasm_bindgen_worker_ready'\n  });\n  pkg.wbg_rayon_start_worker(data.receiver);\n}); // Note: this is never used, but necessary to prevent a bug in Firefox\n// (https://bugzilla.mozilla.org/show_bug.cgi?id=1702191) where it collects\n// Web Workers that have a shared WebAssembly memory with the main thread,\n// but are not explicitly rooted via a `Worker` instance.\n//\n// By storing them in a variable, we can keep `Worker` objects around and\n// prevent them from getting GC-d.\n\nlet _workers;\n\nexport async function startWorkers(module, memory, builder) {\n  const workerInit = {\n    type: 'wasm_bindgen_worker_init',\n    module,\n    memory,\n    receiver: builder.receiver()\n  };\n  _workers = await Promise.all(Array.from({\n    length: builder.numThreads()\n  }, async () => {\n    // Self-spawn into a new Worker.\n    //\n    // TODO: while `new URL('...', import.meta.url) becomes a semi-standard\n    // way to get asset URLs relative to the module across various bundlers\n    // and browser, ideally we should switch to `import.meta.resolve`\n    // once it becomes a standard.\n    //\n    // Note: we could use `../../..` as the URL here to inline workerHelpers.js\n    // into the parent entry instead of creating another split point -\n    // this would be preferable from optimization perspective -\n    // however, Webpack then eliminates all message handler code\n    // because wasm-pack produces \"sideEffects\":false in package.json\n    // unconditionally.\n    //\n    // The only way to work around that is to have side effect code\n    // in an entry point such as Worker file itself.\n    const worker = new Worker(new URL('./workerHelpers.js', import.meta.url), {\n      type: 'module'\n    });\n    worker.postMessage(workerInit);\n    await waitForMsgType(worker, 'wasm_bindgen_worker_ready');\n    return worker;\n  }));\n  builder.build();\n}","map":{"version":3,"sources":["/Users/ianbrighton/Documents/Mach 34/BattleZipsV2/BattleZipsV2-Frontend/node_modules/battlezipsv2-wasm/snippets/wasm-bindgen-rayon-7afa899f36665473/src/workerHelpers.js"],"names":["waitForMsgType","target","type","Promise","resolve","addEventListener","onMsg","data","removeEventListener","self","then","pkg","default","module","memory","postMessage","wbg_rayon_start_worker","receiver","_workers","startWorkers","builder","workerInit","all","Array","from","length","numThreads","worker","Worker","URL","import","meta","url","build"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA,SAASA,cAAT,CAAwBC,MAAxB,EAAgCC,IAAhC,EAAsC;AACpC,SAAO,IAAIC,OAAJ,CAAYC,OAAO,IAAI;AAC5BH,IAAAA,MAAM,CAACI,gBAAP,CAAwB,SAAxB,EAAmC,SAASC,KAAT,OAAyB;AAAA,UAAV;AAAEC,QAAAA;AAAF,OAAU;AAC1D,UAAIA,IAAI,IAAI,IAAR,IAAgBA,IAAI,CAACL,IAAL,KAAcA,IAAlC,EAAwC;AACxCD,MAAAA,MAAM,CAACO,mBAAP,CAA2B,SAA3B,EAAsCF,KAAtC;AACAF,MAAAA,OAAO,CAACG,IAAD,CAAP;AACD,KAJD;AAKD,GANM,CAAP;AAOD;;AAEDP,cAAc,CAACS,IAAD,EAAO,0BAAP,CAAd,CAAiDC,IAAjD,CAAsD,MAAMH,IAAN,IAAc;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAMI,GAAG,GAAG,MAAM,OAAO,UAAP,CAAlB;AACA,QAAMA,GAAG,CAACC,OAAJ,CAAYL,IAAI,CAACM,MAAjB,EAAyBN,IAAI,CAACO,MAA9B,CAAN;AACAC,EAAAA,WAAW,CAAC;AAAEb,IAAAA,IAAI,EAAE;AAAR,GAAD,CAAX;AACAS,EAAAA,GAAG,CAACK,sBAAJ,CAA2BT,IAAI,CAACU,QAAhC;AACD,CA3BD,E,CA6BA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAIC,QAAJ;;AAEA,OAAO,eAAeC,YAAf,CAA4BN,MAA5B,EAAoCC,MAApC,EAA4CM,OAA5C,EAAqD;AAC1D,QAAMC,UAAU,GAAG;AACjBnB,IAAAA,IAAI,EAAE,0BADW;AAEjBW,IAAAA,MAFiB;AAGjBC,IAAAA,MAHiB;AAIjBG,IAAAA,QAAQ,EAAEG,OAAO,CAACH,QAAR;AAJO,GAAnB;AAOAC,EAAAA,QAAQ,GAAG,MAAMf,OAAO,CAACmB,GAAR,CACfC,KAAK,CAACC,IAAN,CAAW;AAAEC,IAAAA,MAAM,EAAEL,OAAO,CAACM,UAAR;AAAV,GAAX,EAA6C,YAAY;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAMC,MAAM,GAAG,IAAIC,MAAJ,CAAW,IAAIC,GAAJ,CAAQ,oBAAR,EAA8BC,MAAM,CAACC,IAAP,CAAYC,GAA1C,CAAX,EAA2D;AACxE9B,MAAAA,IAAI,EAAE;AADkE,KAA3D,CAAf;AAGAyB,IAAAA,MAAM,CAACZ,WAAP,CAAmBM,UAAnB;AACA,UAAMrB,cAAc,CAAC2B,MAAD,EAAS,2BAAT,CAApB;AACA,WAAOA,MAAP;AACD,GAvBD,CADe,CAAjB;AA0BAP,EAAAA,OAAO,CAACa,KAAR;AACD","sourcesContent":["/**\n * Copyright 2021 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Note: we use `wasm_bindgen_worker_`-prefixed message types to make sure\n// we can handle bundling into other files, which might happen to have their\n// own `postMessage`/`onmessage` communication channels.\n//\n// If we didn't take that into the account, we could send much simpler signals\n// like just `0` or whatever, but the code would be less resilient.\n\nfunction waitForMsgType(target, type) {\n  return new Promise(resolve => {\n    target.addEventListener('message', function onMsg({ data }) {\n      if (data == null || data.type !== type) return;\n      target.removeEventListener('message', onMsg);\n      resolve(data);\n    });\n  });\n}\n\nwaitForMsgType(self, 'wasm_bindgen_worker_init').then(async data => {\n  // # Note 1\n  // Our JS should have been generated in\n  // `[out-dir]/snippets/wasm-bindgen-rayon-[hash]/workerHelpers.js`,\n  // resolve the main module via `../../..`.\n  //\n  // This might need updating if the generated structure changes on wasm-bindgen\n  // side ever in the future, but works well with bundlers today. The whole\n  // point of this crate, after all, is to abstract away unstable features\n  // and temporary bugs so that you don't need to deal with them in your code.\n  //\n  // # Note 2\n  // This could be a regular import, but then some bundlers complain about\n  // circular deps.\n  //\n  // Dynamic import could be cheap if this file was inlined into the parent,\n  // which would require us just using `../../..` in `new Worker` below,\n  // but that doesn't work because wasm-pack unconditionally adds\n  // \"sideEffects\":false (see below).\n  //\n  // OTOH, even though it can't be inlined, it should be still reasonably\n  // cheap since the requested file is already in cache (it was loaded by\n  // the main thread).\n  const pkg = await import('../../..');\n  await pkg.default(data.module, data.memory);\n  postMessage({ type: 'wasm_bindgen_worker_ready' });\n  pkg.wbg_rayon_start_worker(data.receiver);\n});\n\n// Note: this is never used, but necessary to prevent a bug in Firefox\n// (https://bugzilla.mozilla.org/show_bug.cgi?id=1702191) where it collects\n// Web Workers that have a shared WebAssembly memory with the main thread,\n// but are not explicitly rooted via a `Worker` instance.\n//\n// By storing them in a variable, we can keep `Worker` objects around and\n// prevent them from getting GC-d.\nlet _workers;\n\nexport async function startWorkers(module, memory, builder) {\n  const workerInit = {\n    type: 'wasm_bindgen_worker_init',\n    module,\n    memory,\n    receiver: builder.receiver()\n  };\n\n  _workers = await Promise.all(\n    Array.from({ length: builder.numThreads() }, async () => {\n      // Self-spawn into a new Worker.\n      //\n      // TODO: while `new URL('...', import.meta.url) becomes a semi-standard\n      // way to get asset URLs relative to the module across various bundlers\n      // and browser, ideally we should switch to `import.meta.resolve`\n      // once it becomes a standard.\n      //\n      // Note: we could use `../../..` as the URL here to inline workerHelpers.js\n      // into the parent entry instead of creating another split point -\n      // this would be preferable from optimization perspective -\n      // however, Webpack then eliminates all message handler code\n      // because wasm-pack produces \"sideEffects\":false in package.json\n      // unconditionally.\n      //\n      // The only way to work around that is to have side effect code\n      // in an entry point such as Worker file itself.\n      const worker = new Worker(new URL('./workerHelpers.js', import.meta.url), {\n        type: 'module'\n      });\n      worker.postMessage(workerInit);\n      await waitForMsgType(worker, 'wasm_bindgen_worker_ready');\n      return worker;\n    })\n  );\n  builder.build();\n}\n"]},"metadata":{},"sourceType":"module"}