{"ast":null,"code":"\"use strict\";\n\nimport { getAddress } from \"@ethersproject/address\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { arrayify, hexConcat, hexDataLength, hexDataSlice, hexlify, hexZeroPad, isBytesLike, splitSignature, stripZeros } from \"@ethersproject/bytes\";\nimport { Zero } from \"@ethersproject/constants\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { checkProperties } from \"@ethersproject/properties\";\nimport * as RLP from \"@ethersproject/rlp\";\nimport { computePublicKey, recoverPublicKey } from \"@ethersproject/signing-key\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nexport var TransactionTypes;\n\n(function (TransactionTypes) {\n  TransactionTypes[TransactionTypes[\"legacy\"] = 0] = \"legacy\";\n  TransactionTypes[TransactionTypes[\"eip2930\"] = 1] = \"eip2930\";\n  TransactionTypes[TransactionTypes[\"eip1559\"] = 2] = \"eip1559\";\n})(TransactionTypes || (TransactionTypes = {}));\n\n; ///////////////////////////////\n\nfunction handleAddress(value) {\n  if (value === \"0x\") {\n    return null;\n  }\n\n  return getAddress(value);\n}\n\nfunction handleNumber(value) {\n  if (value === \"0x\") {\n    return Zero;\n  }\n\n  return BigNumber.from(value);\n} // Legacy Transaction Fields\n\n\nconst transactionFields = [{\n  name: \"nonce\",\n  maxLength: 32,\n  numeric: true\n}, {\n  name: \"gasPrice\",\n  maxLength: 32,\n  numeric: true\n}, {\n  name: \"gasLimit\",\n  maxLength: 32,\n  numeric: true\n}, {\n  name: \"to\",\n  length: 20\n}, {\n  name: \"value\",\n  maxLength: 32,\n  numeric: true\n}, {\n  name: \"data\"\n}];\nconst allowedTransactionKeys = {\n  chainId: true,\n  data: true,\n  gasLimit: true,\n  gasPrice: true,\n  nonce: true,\n  to: true,\n  type: true,\n  value: true\n};\nexport function computeAddress(key) {\n  const publicKey = computePublicKey(key);\n  return getAddress(hexDataSlice(keccak256(hexDataSlice(publicKey, 1)), 12));\n}\nexport function recoverAddress(digest, signature) {\n  return computeAddress(recoverPublicKey(arrayify(digest), signature));\n}\n\nfunction formatNumber(value, name) {\n  const result = stripZeros(BigNumber.from(value).toHexString());\n\n  if (result.length > 32) {\n    logger.throwArgumentError(\"invalid length for \" + name, \"transaction:\" + name, value);\n  }\n\n  return result;\n}\n\nfunction accessSetify(addr, storageKeys) {\n  return {\n    address: getAddress(addr),\n    storageKeys: (storageKeys || []).map((storageKey, index) => {\n      if (hexDataLength(storageKey) !== 32) {\n        logger.throwArgumentError(\"invalid access list storageKey\", `accessList[${addr}:${index}]`, storageKey);\n      }\n\n      return storageKey.toLowerCase();\n    })\n  };\n}\n\nexport function accessListify(value) {\n  if (Array.isArray(value)) {\n    return value.map((set, index) => {\n      if (Array.isArray(set)) {\n        if (set.length > 2) {\n          logger.throwArgumentError(\"access list expected to be [ address, storageKeys[] ]\", `value[${index}]`, set);\n        }\n\n        return accessSetify(set[0], set[1]);\n      }\n\n      return accessSetify(set.address, set.storageKeys);\n    });\n  }\n\n  const result = Object.keys(value).map(addr => {\n    const storageKeys = value[addr].reduce((accum, storageKey) => {\n      accum[storageKey] = true;\n      return accum;\n    }, {});\n    return accessSetify(addr, Object.keys(storageKeys).sort());\n  });\n  result.sort((a, b) => a.address.localeCompare(b.address));\n  return result;\n}\n\nfunction formatAccessList(value) {\n  return accessListify(value).map(set => [set.address, set.storageKeys]);\n}\n\nfunction _serializeEip1559(transaction, signature) {\n  // If there is an explicit gasPrice, make sure it matches the\n  // EIP-1559 fees; otherwise they may not understand what they\n  // think they are setting in terms of fee.\n  if (transaction.gasPrice != null) {\n    const gasPrice = BigNumber.from(transaction.gasPrice);\n    const maxFeePerGas = BigNumber.from(transaction.maxFeePerGas || 0);\n\n    if (!gasPrice.eq(maxFeePerGas)) {\n      logger.throwArgumentError(\"mismatch EIP-1559 gasPrice != maxFeePerGas\", \"tx\", {\n        gasPrice,\n        maxFeePerGas\n      });\n    }\n  }\n\n  const fields = [formatNumber(transaction.chainId || 0, \"chainId\"), formatNumber(transaction.nonce || 0, \"nonce\"), formatNumber(transaction.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"), formatNumber(transaction.maxFeePerGas || 0, \"maxFeePerGas\"), formatNumber(transaction.gasLimit || 0, \"gasLimit\"), transaction.to != null ? getAddress(transaction.to) : \"0x\", formatNumber(transaction.value || 0, \"value\"), transaction.data || \"0x\", formatAccessList(transaction.accessList || [])];\n\n  if (signature) {\n    const sig = splitSignature(signature);\n    fields.push(formatNumber(sig.recoveryParam, \"recoveryParam\"));\n    fields.push(stripZeros(sig.r));\n    fields.push(stripZeros(sig.s));\n  }\n\n  return hexConcat([\"0x02\", RLP.encode(fields)]);\n}\n\nfunction _serializeEip2930(transaction, signature) {\n  const fields = [formatNumber(transaction.chainId || 0, \"chainId\"), formatNumber(transaction.nonce || 0, \"nonce\"), formatNumber(transaction.gasPrice || 0, \"gasPrice\"), formatNumber(transaction.gasLimit || 0, \"gasLimit\"), transaction.to != null ? getAddress(transaction.to) : \"0x\", formatNumber(transaction.value || 0, \"value\"), transaction.data || \"0x\", formatAccessList(transaction.accessList || [])];\n\n  if (signature) {\n    const sig = splitSignature(signature);\n    fields.push(formatNumber(sig.recoveryParam, \"recoveryParam\"));\n    fields.push(stripZeros(sig.r));\n    fields.push(stripZeros(sig.s));\n  }\n\n  return hexConcat([\"0x01\", RLP.encode(fields)]);\n} // Legacy Transactions and EIP-155\n\n\nfunction _serialize(transaction, signature) {\n  checkProperties(transaction, allowedTransactionKeys);\n  const raw = [];\n  transactionFields.forEach(function (fieldInfo) {\n    let value = transaction[fieldInfo.name] || [];\n    const options = {};\n\n    if (fieldInfo.numeric) {\n      options.hexPad = \"left\";\n    }\n\n    value = arrayify(hexlify(value, options)); // Fixed-width field\n\n    if (fieldInfo.length && value.length !== fieldInfo.length && value.length > 0) {\n      logger.throwArgumentError(\"invalid length for \" + fieldInfo.name, \"transaction:\" + fieldInfo.name, value);\n    } // Variable-width (with a maximum)\n\n\n    if (fieldInfo.maxLength) {\n      value = stripZeros(value);\n\n      if (value.length > fieldInfo.maxLength) {\n        logger.throwArgumentError(\"invalid length for \" + fieldInfo.name, \"transaction:\" + fieldInfo.name, value);\n      }\n    }\n\n    raw.push(hexlify(value));\n  });\n  let chainId = 0;\n\n  if (transaction.chainId != null) {\n    // A chainId was provided; if non-zero we'll use EIP-155\n    chainId = transaction.chainId;\n\n    if (typeof chainId !== \"number\") {\n      logger.throwArgumentError(\"invalid transaction.chainId\", \"transaction\", transaction);\n    }\n  } else if (signature && !isBytesLike(signature) && signature.v > 28) {\n    // No chainId provided, but the signature is signing with EIP-155; derive chainId\n    chainId = Math.floor((signature.v - 35) / 2);\n  } // We have an EIP-155 transaction (chainId was specified and non-zero)\n\n\n  if (chainId !== 0) {\n    raw.push(hexlify(chainId)); // @TODO: hexValue?\n\n    raw.push(\"0x\");\n    raw.push(\"0x\");\n  } // Requesting an unsigned transaction\n\n\n  if (!signature) {\n    return RLP.encode(raw);\n  } // The splitSignature will ensure the transaction has a recoveryParam in the\n  // case that the signTransaction function only adds a v.\n\n\n  const sig = splitSignature(signature); // We pushed a chainId and null r, s on for hashing only; remove those\n\n  let v = 27 + sig.recoveryParam;\n\n  if (chainId !== 0) {\n    raw.pop();\n    raw.pop();\n    raw.pop();\n    v += chainId * 2 + 8; // If an EIP-155 v (directly or indirectly; maybe _vs) was provided, check it!\n\n    if (sig.v > 28 && sig.v !== v) {\n      logger.throwArgumentError(\"transaction.chainId/signature.v mismatch\", \"signature\", signature);\n    }\n  } else if (sig.v !== v) {\n    logger.throwArgumentError(\"transaction.chainId/signature.v mismatch\", \"signature\", signature);\n  }\n\n  raw.push(hexlify(v));\n  raw.push(stripZeros(arrayify(sig.r)));\n  raw.push(stripZeros(arrayify(sig.s)));\n  return RLP.encode(raw);\n}\n\nexport function serialize(transaction, signature) {\n  // Legacy and EIP-155 Transactions\n  if (transaction.type == null || transaction.type === 0) {\n    if (transaction.accessList != null) {\n      logger.throwArgumentError(\"untyped transactions do not support accessList; include type: 1\", \"transaction\", transaction);\n    }\n\n    return _serialize(transaction, signature);\n  } // Typed Transactions (EIP-2718)\n\n\n  switch (transaction.type) {\n    case 1:\n      return _serializeEip2930(transaction, signature);\n\n    case 2:\n      return _serializeEip1559(transaction, signature);\n\n    default:\n      break;\n  }\n\n  return logger.throwError(`unsupported transaction type: ${transaction.type}`, Logger.errors.UNSUPPORTED_OPERATION, {\n    operation: \"serializeTransaction\",\n    transactionType: transaction.type\n  });\n}\n\nfunction _parseEipSignature(tx, fields, serialize) {\n  try {\n    const recid = handleNumber(fields[0]).toNumber();\n\n    if (recid !== 0 && recid !== 1) {\n      throw new Error(\"bad recid\");\n    }\n\n    tx.v = recid;\n  } catch (error) {\n    logger.throwArgumentError(\"invalid v for transaction type: 1\", \"v\", fields[0]);\n  }\n\n  tx.r = hexZeroPad(fields[1], 32);\n  tx.s = hexZeroPad(fields[2], 32);\n\n  try {\n    const digest = keccak256(serialize(tx));\n    tx.from = recoverAddress(digest, {\n      r: tx.r,\n      s: tx.s,\n      recoveryParam: tx.v\n    });\n  } catch (error) {\n    console.log(error);\n  }\n}\n\nfunction _parseEip1559(payload) {\n  const transaction = RLP.decode(payload.slice(1));\n\n  if (transaction.length !== 9 && transaction.length !== 12) {\n    logger.throwArgumentError(\"invalid component count for transaction type: 2\", \"payload\", hexlify(payload));\n  }\n\n  const maxPriorityFeePerGas = handleNumber(transaction[2]);\n  const maxFeePerGas = handleNumber(transaction[3]);\n  const tx = {\n    type: 2,\n    chainId: handleNumber(transaction[0]).toNumber(),\n    nonce: handleNumber(transaction[1]).toNumber(),\n    maxPriorityFeePerGas: maxPriorityFeePerGas,\n    maxFeePerGas: maxFeePerGas,\n    gasPrice: null,\n    gasLimit: handleNumber(transaction[4]),\n    to: handleAddress(transaction[5]),\n    value: handleNumber(transaction[6]),\n    data: transaction[7],\n    accessList: accessListify(transaction[8])\n  }; // Unsigned EIP-1559 Transaction\n\n  if (transaction.length === 9) {\n    return tx;\n  }\n\n  tx.hash = keccak256(payload);\n\n  _parseEipSignature(tx, transaction.slice(9), _serializeEip1559);\n\n  return tx;\n}\n\nfunction _parseEip2930(payload) {\n  const transaction = RLP.decode(payload.slice(1));\n\n  if (transaction.length !== 8 && transaction.length !== 11) {\n    logger.throwArgumentError(\"invalid component count for transaction type: 1\", \"payload\", hexlify(payload));\n  }\n\n  const tx = {\n    type: 1,\n    chainId: handleNumber(transaction[0]).toNumber(),\n    nonce: handleNumber(transaction[1]).toNumber(),\n    gasPrice: handleNumber(transaction[2]),\n    gasLimit: handleNumber(transaction[3]),\n    to: handleAddress(transaction[4]),\n    value: handleNumber(transaction[5]),\n    data: transaction[6],\n    accessList: accessListify(transaction[7])\n  }; // Unsigned EIP-2930 Transaction\n\n  if (transaction.length === 8) {\n    return tx;\n  }\n\n  tx.hash = keccak256(payload);\n\n  _parseEipSignature(tx, transaction.slice(8), _serializeEip2930);\n\n  return tx;\n} // Legacy Transactions and EIP-155\n\n\nfunction _parse(rawTransaction) {\n  const transaction = RLP.decode(rawTransaction);\n\n  if (transaction.length !== 9 && transaction.length !== 6) {\n    logger.throwArgumentError(\"invalid raw transaction\", \"rawTransaction\", rawTransaction);\n  }\n\n  const tx = {\n    nonce: handleNumber(transaction[0]).toNumber(),\n    gasPrice: handleNumber(transaction[1]),\n    gasLimit: handleNumber(transaction[2]),\n    to: handleAddress(transaction[3]),\n    value: handleNumber(transaction[4]),\n    data: transaction[5],\n    chainId: 0\n  }; // Legacy unsigned transaction\n\n  if (transaction.length === 6) {\n    return tx;\n  }\n\n  try {\n    tx.v = BigNumber.from(transaction[6]).toNumber();\n  } catch (error) {\n    console.log(error);\n    return tx;\n  }\n\n  tx.r = hexZeroPad(transaction[7], 32);\n  tx.s = hexZeroPad(transaction[8], 32);\n\n  if (BigNumber.from(tx.r).isZero() && BigNumber.from(tx.s).isZero()) {\n    // EIP-155 unsigned transaction\n    tx.chainId = tx.v;\n    tx.v = 0;\n  } else {\n    // Signed Transaction\n    tx.chainId = Math.floor((tx.v - 35) / 2);\n\n    if (tx.chainId < 0) {\n      tx.chainId = 0;\n    }\n\n    let recoveryParam = tx.v - 27;\n    const raw = transaction.slice(0, 6);\n\n    if (tx.chainId !== 0) {\n      raw.push(hexlify(tx.chainId));\n      raw.push(\"0x\");\n      raw.push(\"0x\");\n      recoveryParam -= tx.chainId * 2 + 8;\n    }\n\n    const digest = keccak256(RLP.encode(raw));\n\n    try {\n      tx.from = recoverAddress(digest, {\n        r: hexlify(tx.r),\n        s: hexlify(tx.s),\n        recoveryParam: recoveryParam\n      });\n    } catch (error) {\n      console.log(error);\n    }\n\n    tx.hash = keccak256(rawTransaction);\n  }\n\n  tx.type = null;\n  return tx;\n}\n\nexport function parse(rawTransaction) {\n  const payload = arrayify(rawTransaction); // Legacy and EIP-155 Transactions\n\n  if (payload[0] > 0x7f) {\n    return _parse(payload);\n  } // Typed Transaction (EIP-2718)\n\n\n  switch (payload[0]) {\n    case 1:\n      return _parseEip2930(payload);\n\n    case 2:\n      return _parseEip1559(payload);\n\n    default:\n      break;\n  }\n\n  return logger.throwError(`unsupported transaction type: ${payload[0]}`, Logger.errors.UNSUPPORTED_OPERATION, {\n    operation: \"parseTransaction\",\n    transactionType: payload[0]\n  });\n}","map":{"version":3,"mappings":"AAAA;;AAEA,SAASA,UAAT,QAA2B,wBAA3B;AACA,SAASC,SAAT,QAAwC,0BAAxC;AACA,SAASC,QAAT,EAA2CC,SAA3C,EAAsDC,aAAtD,EAAqEC,YAArE,EAAmFC,OAAnF,EAA4FC,UAA5F,EAAwGC,WAAxG,EAAoIC,cAApI,EAAoJC,UAApJ,QAAuK,sBAAvK;AACA,SAASC,IAAT,QAAqB,0BAArB;AACA,SAASC,SAAT,QAA0B,0BAA1B;AACA,SAASC,eAAT,QAAgC,2BAAhC;AACA,OAAO,KAAKC,GAAZ,MAAqB,oBAArB;AACA,SAASC,gBAAT,EAA2BC,gBAA3B,QAAmD,4BAAnD;AAEA,SAASC,MAAT,QAAuB,uBAAvB;AACA,SAASC,OAAT,QAAwB,YAAxB;AACA,MAAMC,MAAM,GAAG,IAAIF,MAAJ,CAAWC,OAAX,CAAf;AAYA,WAAYE,gBAAZ;;AAAA,WAAYA,gBAAZ,EAA4B;AACxBA;AACAA;AACAA;AACH,CAJD,EAAYA,gBAAgB,KAAhBA,gBAAgB,MAA5B;;AAIC,C,CAqDD;;AAEA,SAASC,aAAT,CAAuBC,KAAvB,EAAoC;AAChC,MAAIA,KAAK,KAAK,IAAd,EAAoB;AAAE,WAAO,IAAP;AAAc;;AACpC,SAAOtB,UAAU,CAACsB,KAAD,CAAjB;AACH;;AAED,SAASC,YAAT,CAAsBD,KAAtB,EAAmC;AAC/B,MAAIA,KAAK,KAAK,IAAd,EAAoB;AAAE,WAAOX,IAAP;AAAc;;AACpC,SAAOV,SAAS,CAACuB,IAAV,CAAeF,KAAf,CAAP;AACH,C,CAED;;;AACA,MAAMG,iBAAiB,GAAG,CACtB;AAAEC,MAAI,EAAE,OAAR;AAAoBC,WAAS,EAAE,EAA/B;AAAmCC,SAAO,EAAE;AAA5C,CADsB,EAEtB;AAAEF,MAAI,EAAE,UAAR;AAAoBC,WAAS,EAAE,EAA/B;AAAmCC,SAAO,EAAE;AAA5C,CAFsB,EAGtB;AAAEF,MAAI,EAAE,UAAR;AAAoBC,WAAS,EAAE,EAA/B;AAAmCC,SAAO,EAAE;AAA5C,CAHsB,EAItB;AAAEF,MAAI,EAAE,IAAR;AAAuBG,QAAM,EAAE;AAA/B,CAJsB,EAKtB;AAAEH,MAAI,EAAE,OAAR;AAAoBC,WAAS,EAAE,EAA/B;AAAmCC,SAAO,EAAE;AAA5C,CALsB,EAMtB;AAAEF,MAAI,EAAE;AAAR,CANsB,CAA1B;AASA,MAAMI,sBAAsB,GAAiC;AACzDC,SAAO,EAAE,IADgD;AAC1CC,MAAI,EAAE,IADoC;AAC9BC,UAAQ,EAAE,IADoB;AACdC,UAAQ,EAAC,IADK;AACCC,OAAK,EAAE,IADR;AACcC,IAAE,EAAE,IADlB;AACwBC,MAAI,EAAE,IAD9B;AACoCf,OAAK,EAAE;AAD3C,CAA7D;AAIA,OAAM,SAAUgB,cAAV,CAAyBC,GAAzB,EAAgD;AAClD,QAAMC,SAAS,GAAGzB,gBAAgB,CAACwB,GAAD,CAAlC;AACA,SAAOvC,UAAU,CAACK,YAAY,CAACO,SAAS,CAACP,YAAY,CAACmC,SAAD,EAAY,CAAZ,CAAb,CAAV,EAAwC,EAAxC,CAAb,CAAjB;AACH;AAED,OAAM,SAAUC,cAAV,CAAyBC,MAAzB,EAA4CC,SAA5C,EAAoE;AACtE,SAAOL,cAAc,CAACtB,gBAAgB,CAACd,QAAQ,CAACwC,MAAD,CAAT,EAAmBC,SAAnB,CAAjB,CAArB;AACH;;AAED,SAASC,YAAT,CAAsBtB,KAAtB,EAA2CI,IAA3C,EAAuD;AACnD,QAAMmB,MAAM,GAAGnC,UAAU,CAACT,SAAS,CAACuB,IAAV,CAAeF,KAAf,EAAsBwB,WAAtB,EAAD,CAAzB;;AACA,MAAID,MAAM,CAAChB,MAAP,GAAgB,EAApB,EAAwB;AACpBV,UAAM,CAAC4B,kBAAP,CAA0B,wBAAwBrB,IAAlD,EAAyD,iBAAiBA,IAA1E,EAAiFJ,KAAjF;AACH;;AACD,SAAOuB,MAAP;AACH;;AAED,SAASG,YAAT,CAAsBC,IAAtB,EAAoCC,WAApC,EAA8D;AAC1D,SAAO;AACHC,WAAO,EAAEnD,UAAU,CAACiD,IAAD,CADhB;AAEHC,eAAW,EAAE,CAACA,WAAW,IAAI,EAAhB,EAAoBE,GAApB,CAAwB,CAACC,UAAD,EAAaC,KAAb,KAAsB;AACvD,UAAIlD,aAAa,CAACiD,UAAD,CAAb,KAA8B,EAAlC,EAAsC;AAClClC,cAAM,CAAC4B,kBAAP,CAA0B,gCAA1B,EAA4D,cAAeE,IAAK,IAAKK,KAAM,GAA3F,EAAgGD,UAAhG;AACH;;AACD,aAAOA,UAAU,CAACE,WAAX,EAAP;AACH,KALY;AAFV,GAAP;AASH;;AAED,OAAM,SAAUC,aAAV,CAAwBlC,KAAxB,EAA4C;AAC9C,MAAImC,KAAK,CAACC,OAAN,CAAcpC,KAAd,CAAJ,EAA0B;AACtB,WAA0FA,KAAM,CAAC8B,GAAP,CAAW,CAACO,GAAD,EAAML,KAAN,KAAe;AAChH,UAAIG,KAAK,CAACC,OAAN,CAAcC,GAAd,CAAJ,EAAwB;AACpB,YAAIA,GAAG,CAAC9B,MAAJ,GAAa,CAAjB,EAAoB;AAChBV,gBAAM,CAAC4B,kBAAP,CAA0B,uDAA1B,EAAmF,SAAUO,KAAM,GAAnG,EAAwGK,GAAxG;AACH;;AACD,eAAOX,YAAY,CAACW,GAAG,CAAC,CAAD,CAAJ,EAASA,GAAG,CAAC,CAAD,CAAZ,CAAnB;AACH;;AACD,aAAOX,YAAY,CAACW,GAAG,CAACR,OAAL,EAAcQ,GAAG,CAACT,WAAlB,CAAnB;AACH,KARyF,CAA1F;AASH;;AAED,QAAML,MAAM,GAA2De,MAAM,CAACC,IAAP,CAAYvC,KAAZ,EAAmB8B,GAAnB,CAAwBH,IAAD,IAAS;AACnG,UAAMC,WAAW,GAAyB5B,KAAK,CAAC2B,IAAD,CAAL,CAAYa,MAAZ,CAAmB,CAACC,KAAD,EAAQV,UAAR,KAAsB;AAC/EU,WAAK,CAACV,UAAD,CAAL,GAAoB,IAApB;AACA,aAAOU,KAAP;AACH,KAHyC,EAGjB,EAHiB,CAA1C;AAIA,WAAOf,YAAY,CAACC,IAAD,EAAOW,MAAM,CAACC,IAAP,CAAYX,WAAZ,EAAyBc,IAAzB,EAAP,CAAnB;AACH,GANsE,CAAvE;AAOAnB,QAAM,CAACmB,IAAP,CAAY,CAACC,CAAD,EAAIC,CAAJ,KAAWD,CAAC,CAACd,OAAF,CAAUgB,aAAV,CAAwBD,CAAC,CAACf,OAA1B,CAAvB;AACA,SAAON,MAAP;AACH;;AAED,SAASuB,gBAAT,CAA0B9C,KAA1B,EAA8C;AAC1C,SAAOkC,aAAa,CAAClC,KAAD,CAAb,CAAqB8B,GAArB,CAA0BO,GAAD,IAAS,CAAEA,GAAG,CAACR,OAAN,EAAeQ,GAAG,CAACT,WAAnB,CAAlC,CAAP;AACH;;AAED,SAASmB,iBAAT,CAA2BC,WAA3B,EAA6D3B,SAA7D,EAAsF;AAClF;AACA;AACA;AACA,MAAI2B,WAAW,CAACpC,QAAZ,IAAwB,IAA5B,EAAkC;AAC9B,UAAMA,QAAQ,GAAGjC,SAAS,CAACuB,IAAV,CAAe8C,WAAW,CAACpC,QAA3B,CAAjB;AACA,UAAMqC,YAAY,GAAGtE,SAAS,CAACuB,IAAV,CAAe8C,WAAW,CAACC,YAAZ,IAA4B,CAA3C,CAArB;;AACA,QAAI,CAACrC,QAAQ,CAACsC,EAAT,CAAYD,YAAZ,CAAL,EAAgC;AAC5BpD,YAAM,CAAC4B,kBAAP,CAA0B,4CAA1B,EAAwE,IAAxE,EAA8E;AAC1Eb,gBAD0E;AAChEqC;AADgE,OAA9E;AAGH;AACJ;;AAED,QAAME,MAAM,GAAQ,CAChB7B,YAAY,CAAC0B,WAAW,CAACvC,OAAZ,IAAuB,CAAxB,EAA2B,SAA3B,CADI,EAEhBa,YAAY,CAAC0B,WAAW,CAACnC,KAAZ,IAAqB,CAAtB,EAAyB,OAAzB,CAFI,EAGhBS,YAAY,CAAC0B,WAAW,CAACI,oBAAZ,IAAoC,CAArC,EAAwC,sBAAxC,CAHI,EAIhB9B,YAAY,CAAC0B,WAAW,CAACC,YAAZ,IAA4B,CAA7B,EAAgC,cAAhC,CAJI,EAKhB3B,YAAY,CAAC0B,WAAW,CAACrC,QAAZ,IAAwB,CAAzB,EAA4B,UAA5B,CALI,EAMdqC,WAAW,CAAClC,EAAZ,IAAkB,IAAnB,GAA2BpC,UAAU,CAACsE,WAAW,CAAClC,EAAb,CAArC,GAAuD,IANxC,EAOhBQ,YAAY,CAAC0B,WAAW,CAAChD,KAAZ,IAAqB,CAAtB,EAAyB,OAAzB,CAPI,EAQfgD,WAAW,CAACtC,IAAZ,IAAoB,IARL,EASfoC,gBAAgB,CAACE,WAAW,CAACK,UAAZ,IAA0B,EAA3B,CATD,CAApB;;AAYA,MAAIhC,SAAJ,EAAe;AACX,UAAMiC,GAAG,GAAGnE,cAAc,CAACkC,SAAD,CAA1B;AACA8B,UAAM,CAACI,IAAP,CAAYjC,YAAY,CAACgC,GAAG,CAACE,aAAL,EAAoB,eAApB,CAAxB;AACAL,UAAM,CAACI,IAAP,CAAYnE,UAAU,CAACkE,GAAG,CAACG,CAAL,CAAtB;AACAN,UAAM,CAACI,IAAP,CAAYnE,UAAU,CAACkE,GAAG,CAACI,CAAL,CAAtB;AACH;;AAED,SAAO7E,SAAS,CAAC,CAAE,MAAF,EAAUW,GAAG,CAACmE,MAAJ,CAAWR,MAAX,CAAV,CAAD,CAAhB;AACH;;AAED,SAASS,iBAAT,CAA2BZ,WAA3B,EAA6D3B,SAA7D,EAAsF;AAClF,QAAM8B,MAAM,GAAQ,CAChB7B,YAAY,CAAC0B,WAAW,CAACvC,OAAZ,IAAuB,CAAxB,EAA2B,SAA3B,CADI,EAEhBa,YAAY,CAAC0B,WAAW,CAACnC,KAAZ,IAAqB,CAAtB,EAAyB,OAAzB,CAFI,EAGhBS,YAAY,CAAC0B,WAAW,CAACpC,QAAZ,IAAwB,CAAzB,EAA4B,UAA5B,CAHI,EAIhBU,YAAY,CAAC0B,WAAW,CAACrC,QAAZ,IAAwB,CAAzB,EAA4B,UAA5B,CAJI,EAKdqC,WAAW,CAAClC,EAAZ,IAAkB,IAAnB,GAA2BpC,UAAU,CAACsE,WAAW,CAAClC,EAAb,CAArC,GAAuD,IALxC,EAMhBQ,YAAY,CAAC0B,WAAW,CAAChD,KAAZ,IAAqB,CAAtB,EAAyB,OAAzB,CANI,EAOfgD,WAAW,CAACtC,IAAZ,IAAoB,IAPL,EAQfoC,gBAAgB,CAACE,WAAW,CAACK,UAAZ,IAA0B,EAA3B,CARD,CAApB;;AAWA,MAAIhC,SAAJ,EAAe;AACX,UAAMiC,GAAG,GAAGnE,cAAc,CAACkC,SAAD,CAA1B;AACA8B,UAAM,CAACI,IAAP,CAAYjC,YAAY,CAACgC,GAAG,CAACE,aAAL,EAAoB,eAApB,CAAxB;AACAL,UAAM,CAACI,IAAP,CAAYnE,UAAU,CAACkE,GAAG,CAACG,CAAL,CAAtB;AACAN,UAAM,CAACI,IAAP,CAAYnE,UAAU,CAACkE,GAAG,CAACI,CAAL,CAAtB;AACH;;AAED,SAAO7E,SAAS,CAAC,CAAE,MAAF,EAAUW,GAAG,CAACmE,MAAJ,CAAWR,MAAX,CAAV,CAAD,CAAhB;AACH,C,CAED;;;AACA,SAASU,UAAT,CAAoBb,WAApB,EAAsD3B,SAAtD,EAA+E;AAC3E9B,iBAAe,CAACyD,WAAD,EAAcxC,sBAAd,CAAf;AAEA,QAAMsD,GAAG,GAA+B,EAAxC;AAEA3D,mBAAiB,CAAC4D,OAAlB,CAA0B,UAASC,SAAT,EAAkB;AACxC,QAAIhE,KAAK,GAASgD,WAAY,CAACgB,SAAS,CAAC5D,IAAX,CAAZ,IAAiC,EAAnD;AACA,UAAM6D,OAAO,GAAgB,EAA7B;;AACA,QAAID,SAAS,CAAC1D,OAAd,EAAuB;AAAE2D,aAAO,CAACC,MAAR,GAAiB,MAAjB;AAA0B;;AACnDlE,SAAK,GAAGpB,QAAQ,CAACI,OAAO,CAACgB,KAAD,EAAQiE,OAAR,CAAR,CAAhB,CAJwC,CAMxC;;AACA,QAAID,SAAS,CAACzD,MAAV,IAAoBP,KAAK,CAACO,MAAN,KAAiByD,SAAS,CAACzD,MAA/C,IAAyDP,KAAK,CAACO,MAAN,GAAe,CAA5E,EAA+E;AAC3EV,YAAM,CAAC4B,kBAAP,CAA0B,wBAAwBuC,SAAS,CAAC5D,IAA5D,EAAmE,iBAAiB4D,SAAS,CAAC5D,IAA9F,EAAqGJ,KAArG;AACH,KATuC,CAWxC;;;AACA,QAAIgE,SAAS,CAAC3D,SAAd,EAAyB;AACrBL,WAAK,GAAGZ,UAAU,CAACY,KAAD,CAAlB;;AACA,UAAIA,KAAK,CAACO,MAAN,GAAeyD,SAAS,CAAC3D,SAA7B,EAAwC;AACpCR,cAAM,CAAC4B,kBAAP,CAA0B,wBAAwBuC,SAAS,CAAC5D,IAA5D,EAAmE,iBAAiB4D,SAAS,CAAC5D,IAA9F,EAAqGJ,KAArG;AACH;AACJ;;AAED8D,OAAG,CAACP,IAAJ,CAASvE,OAAO,CAACgB,KAAD,CAAhB;AACH,GApBD;AAsBA,MAAIS,OAAO,GAAG,CAAd;;AACA,MAAIuC,WAAW,CAACvC,OAAZ,IAAuB,IAA3B,EAAiC;AAC7B;AACAA,WAAO,GAAGuC,WAAW,CAACvC,OAAtB;;AAEA,QAAI,OAAOA,OAAP,KAAoB,QAAxB,EAAkC;AAC9BZ,YAAM,CAAC4B,kBAAP,CAA0B,6BAA1B,EAAyD,aAAzD,EAAwEuB,WAAxE;AACH;AAEJ,GARD,MAQO,IAAI3B,SAAS,IAAI,CAACnC,WAAW,CAACmC,SAAD,CAAzB,IAAwCA,SAAS,CAAC8C,CAAV,GAAc,EAA1D,EAA8D;AACjE;AACA1D,WAAO,GAAG2D,IAAI,CAACC,KAAL,CAAW,CAAChD,SAAS,CAAC8C,CAAV,GAAc,EAAf,IAAqB,CAAhC,CAAV;AACH,GAvC0E,CAyC3E;;;AACA,MAAI1D,OAAO,KAAK,CAAhB,EAAmB;AACfqD,OAAG,CAACP,IAAJ,CAASvE,OAAO,CAACyB,OAAD,CAAhB,EADe,CACa;;AAC5BqD,OAAG,CAACP,IAAJ,CAAS,IAAT;AACAO,OAAG,CAACP,IAAJ,CAAS,IAAT;AACH,GA9C0E,CAgD3E;;;AACA,MAAI,CAAClC,SAAL,EAAgB;AACZ,WAAO7B,GAAG,CAACmE,MAAJ,CAAWG,GAAX,CAAP;AACH,GAnD0E,CAqD3E;AACA;;;AACA,QAAMR,GAAG,GAAGnE,cAAc,CAACkC,SAAD,CAA1B,CAvD2E,CAyD3E;;AACA,MAAI8C,CAAC,GAAG,KAAKb,GAAG,CAACE,aAAjB;;AACA,MAAI/C,OAAO,KAAK,CAAhB,EAAmB;AACfqD,OAAG,CAACQ,GAAJ;AACAR,OAAG,CAACQ,GAAJ;AACAR,OAAG,CAACQ,GAAJ;AACAH,KAAC,IAAI1D,OAAO,GAAG,CAAV,GAAc,CAAnB,CAJe,CAMf;;AACA,QAAI6C,GAAG,CAACa,CAAJ,GAAQ,EAAR,IAAcb,GAAG,CAACa,CAAJ,KAAUA,CAA5B,EAA+B;AAC1BtE,YAAM,CAAC4B,kBAAP,CAA0B,0CAA1B,EAAsE,WAAtE,EAAmFJ,SAAnF;AACJ;AACJ,GAVD,MAUO,IAAIiC,GAAG,CAACa,CAAJ,KAAUA,CAAd,EAAiB;AACnBtE,UAAM,CAAC4B,kBAAP,CAA0B,0CAA1B,EAAsE,WAAtE,EAAmFJ,SAAnF;AACJ;;AAEDyC,KAAG,CAACP,IAAJ,CAASvE,OAAO,CAACmF,CAAD,CAAhB;AACAL,KAAG,CAACP,IAAJ,CAASnE,UAAU,CAACR,QAAQ,CAAC0E,GAAG,CAACG,CAAL,CAAT,CAAnB;AACAK,KAAG,CAACP,IAAJ,CAASnE,UAAU,CAACR,QAAQ,CAAC0E,GAAG,CAACI,CAAL,CAAT,CAAnB;AAEA,SAAOlE,GAAG,CAACmE,MAAJ,CAAWG,GAAX,CAAP;AACH;;AAED,OAAM,SAAUS,SAAV,CAAoBvB,WAApB,EAAsD3B,SAAtD,EAA+E;AACjF;AACA,MAAI2B,WAAW,CAACjC,IAAZ,IAAoB,IAApB,IAA4BiC,WAAW,CAACjC,IAAZ,KAAqB,CAArD,EAAwD;AACpD,QAAIiC,WAAW,CAACK,UAAZ,IAA0B,IAA9B,EAAoC;AAChCxD,YAAM,CAAC4B,kBAAP,CAA0B,iEAA1B,EAA6F,aAA7F,EAA4GuB,WAA5G;AACH;;AACD,WAAOa,UAAU,CAACb,WAAD,EAAc3B,SAAd,CAAjB;AACH,GAPgF,CASjF;;;AACA,UAAQ2B,WAAW,CAACjC,IAApB;AACI,SAAK,CAAL;AACI,aAAO6C,iBAAiB,CAACZ,WAAD,EAAc3B,SAAd,CAAxB;;AACJ,SAAK,CAAL;AACI,aAAO0B,iBAAiB,CAACC,WAAD,EAAc3B,SAAd,CAAxB;;AACJ;AACI;AANR;;AASA,SAAOxB,MAAM,CAAC2E,UAAP,CAAkB,iCAAkCxB,WAAW,CAACjC,IAAK,EAArE,EAAyEpB,MAAM,CAAC8E,MAAP,CAAcC,qBAAvF,EAA8G;AACjHC,aAAS,EAAE,sBADsG;AAEjHC,mBAAe,EAAE5B,WAAW,CAACjC;AAFoF,GAA9G,CAAP;AAIH;;AAED,SAAS8D,kBAAT,CAA4BC,EAA5B,EAA6C3B,MAA7C,EAAoEoB,SAApE,EAAkH;AAC9G,MAAI;AACA,UAAMQ,KAAK,GAAG9E,YAAY,CAACkD,MAAM,CAAC,CAAD,CAAP,CAAZ,CAAwB6B,QAAxB,EAAd;;AACA,QAAID,KAAK,KAAK,CAAV,IAAeA,KAAK,KAAK,CAA7B,EAAgC;AAAE,YAAM,IAAIE,KAAJ,CAAU,WAAV,CAAN;AAA+B;;AACjEH,MAAE,CAACX,CAAH,GAAOY,KAAP;AACH,GAJD,CAIE,OAAOG,KAAP,EAAc;AACZrF,UAAM,CAAC4B,kBAAP,CAA0B,mCAA1B,EAA+D,GAA/D,EAAoE0B,MAAM,CAAC,CAAD,CAA1E;AACH;;AAED2B,IAAE,CAACrB,CAAH,GAAOxE,UAAU,CAACkE,MAAM,CAAC,CAAD,CAAP,EAAY,EAAZ,CAAjB;AACA2B,IAAE,CAACpB,CAAH,GAAOzE,UAAU,CAACkE,MAAM,CAAC,CAAD,CAAP,EAAY,EAAZ,CAAjB;;AAEA,MAAI;AACA,UAAM/B,MAAM,GAAG9B,SAAS,CAACiF,SAAS,CAACO,EAAD,CAAV,CAAxB;AACAA,MAAE,CAAC5E,IAAH,GAAUiB,cAAc,CAACC,MAAD,EAAS;AAAEqC,OAAC,EAAEqB,EAAE,CAACrB,CAAR;AAAWC,OAAC,EAAEoB,EAAE,CAACpB,CAAjB;AAAoBF,mBAAa,EAAEsB,EAAE,CAACX;AAAtC,KAAT,CAAxB;AACH,GAHD,CAGE,OAAOe,KAAP,EAAc;AACZC,WAAO,CAACC,GAAR,CAAYF,KAAZ;AACH;AACJ;;AAED,SAASG,aAAT,CAAuBC,OAAvB,EAA0C;AACtC,QAAMtC,WAAW,GAAGxD,GAAG,CAAC+F,MAAJ,CAAWD,OAAO,CAACE,KAAR,CAAc,CAAd,CAAX,CAApB;;AAEA,MAAIxC,WAAW,CAACzC,MAAZ,KAAuB,CAAvB,IAA4ByC,WAAW,CAACzC,MAAZ,KAAuB,EAAvD,EAA2D;AACvDV,UAAM,CAAC4B,kBAAP,CAA0B,iDAA1B,EAA6E,SAA7E,EAAwFzC,OAAO,CAACsG,OAAD,CAA/F;AACH;;AAED,QAAMlC,oBAAoB,GAAGnD,YAAY,CAAC+C,WAAW,CAAC,CAAD,CAAZ,CAAzC;AACA,QAAMC,YAAY,GAAGhD,YAAY,CAAC+C,WAAW,CAAC,CAAD,CAAZ,CAAjC;AACA,QAAM8B,EAAE,GAAgB;AACpB/D,QAAI,EAAmB,CADH;AAEpBN,WAAO,EAAgBR,YAAY,CAAC+C,WAAW,CAAC,CAAD,CAAZ,CAAZ,CAA6BgC,QAA7B,EAFH;AAGpBnE,SAAK,EAAkBZ,YAAY,CAAC+C,WAAW,CAAC,CAAD,CAAZ,CAAZ,CAA6BgC,QAA7B,EAHH;AAIpB5B,wBAAoB,EAAGA,oBAJH;AAKpBH,gBAAY,EAAWA,YALH;AAMpBrC,YAAQ,EAAe,IANH;AAOpBD,YAAQ,EAAeV,YAAY,CAAC+C,WAAW,CAAC,CAAD,CAAZ,CAPf;AAQpBlC,MAAE,EAAqBf,aAAa,CAACiD,WAAW,CAAC,CAAD,CAAZ,CARhB;AASpBhD,SAAK,EAAkBC,YAAY,CAAC+C,WAAW,CAAC,CAAD,CAAZ,CATf;AAUpBtC,QAAI,EAAmBsC,WAAW,CAAC,CAAD,CAVd;AAWpBK,cAAU,EAAanB,aAAa,CAACc,WAAW,CAAC,CAAD,CAAZ;AAXhB,GAAxB,CATsC,CAuBtC;;AACA,MAAIA,WAAW,CAACzC,MAAZ,KAAuB,CAA3B,EAA8B;AAAE,WAAOuE,EAAP;AAAY;;AAE5CA,IAAE,CAACW,IAAH,GAAUnG,SAAS,CAACgG,OAAD,CAAnB;;AAEAT,oBAAkB,CAACC,EAAD,EAAK9B,WAAW,CAACwC,KAAZ,CAAkB,CAAlB,CAAL,EAA2BzC,iBAA3B,CAAlB;;AAEA,SAAO+B,EAAP;AACH;;AAED,SAASY,aAAT,CAAuBJ,OAAvB,EAA0C;AACtC,QAAMtC,WAAW,GAAGxD,GAAG,CAAC+F,MAAJ,CAAWD,OAAO,CAACE,KAAR,CAAc,CAAd,CAAX,CAApB;;AAEA,MAAIxC,WAAW,CAACzC,MAAZ,KAAuB,CAAvB,IAA4ByC,WAAW,CAACzC,MAAZ,KAAuB,EAAvD,EAA2D;AACvDV,UAAM,CAAC4B,kBAAP,CAA0B,iDAA1B,EAA6E,SAA7E,EAAwFzC,OAAO,CAACsG,OAAD,CAA/F;AACH;;AAED,QAAMR,EAAE,GAAgB;AACpB/D,QAAI,EAAQ,CADQ;AAEpBN,WAAO,EAAKR,YAAY,CAAC+C,WAAW,CAAC,CAAD,CAAZ,CAAZ,CAA6BgC,QAA7B,EAFQ;AAGpBnE,SAAK,EAAOZ,YAAY,CAAC+C,WAAW,CAAC,CAAD,CAAZ,CAAZ,CAA6BgC,QAA7B,EAHQ;AAIpBpE,YAAQ,EAAIX,YAAY,CAAC+C,WAAW,CAAC,CAAD,CAAZ,CAJJ;AAKpBrC,YAAQ,EAAIV,YAAY,CAAC+C,WAAW,CAAC,CAAD,CAAZ,CALJ;AAMpBlC,MAAE,EAAUf,aAAa,CAACiD,WAAW,CAAC,CAAD,CAAZ,CANL;AAOpBhD,SAAK,EAAOC,YAAY,CAAC+C,WAAW,CAAC,CAAD,CAAZ,CAPJ;AAQpBtC,QAAI,EAAQsC,WAAW,CAAC,CAAD,CARH;AASpBK,cAAU,EAAEnB,aAAa,CAACc,WAAW,CAAC,CAAD,CAAZ;AATL,GAAxB,CAPsC,CAmBtC;;AACA,MAAIA,WAAW,CAACzC,MAAZ,KAAuB,CAA3B,EAA8B;AAAE,WAAOuE,EAAP;AAAY;;AAE5CA,IAAE,CAACW,IAAH,GAAUnG,SAAS,CAACgG,OAAD,CAAnB;;AAEAT,oBAAkB,CAACC,EAAD,EAAK9B,WAAW,CAACwC,KAAZ,CAAkB,CAAlB,CAAL,EAA2B5B,iBAA3B,CAAlB;;AAEA,SAAOkB,EAAP;AACH,C,CAED;;;AACA,SAASa,MAAT,CAAgBC,cAAhB,EAA0C;AACtC,QAAM5C,WAAW,GAAGxD,GAAG,CAAC+F,MAAJ,CAAWK,cAAX,CAApB;;AAEA,MAAI5C,WAAW,CAACzC,MAAZ,KAAuB,CAAvB,IAA4ByC,WAAW,CAACzC,MAAZ,KAAuB,CAAvD,EAA0D;AACtDV,UAAM,CAAC4B,kBAAP,CAA0B,yBAA1B,EAAqD,gBAArD,EAAuEmE,cAAvE;AACH;;AAED,QAAMd,EAAE,GAAgB;AACpBjE,SAAK,EAAKZ,YAAY,CAAC+C,WAAW,CAAC,CAAD,CAAZ,CAAZ,CAA6BgC,QAA7B,EADU;AAEpBpE,YAAQ,EAAEX,YAAY,CAAC+C,WAAW,CAAC,CAAD,CAAZ,CAFF;AAGpBrC,YAAQ,EAAEV,YAAY,CAAC+C,WAAW,CAAC,CAAD,CAAZ,CAHF;AAIpBlC,MAAE,EAAQf,aAAa,CAACiD,WAAW,CAAC,CAAD,CAAZ,CAJH;AAKpBhD,SAAK,EAAKC,YAAY,CAAC+C,WAAW,CAAC,CAAD,CAAZ,CALF;AAMpBtC,QAAI,EAAMsC,WAAW,CAAC,CAAD,CAND;AAOpBvC,WAAO,EAAG;AAPU,GAAxB,CAPsC,CAiBtC;;AACA,MAAIuC,WAAW,CAACzC,MAAZ,KAAuB,CAA3B,EAA8B;AAAE,WAAOuE,EAAP;AAAY;;AAE5C,MAAI;AACAA,MAAE,CAACX,CAAH,GAAOxF,SAAS,CAACuB,IAAV,CAAe8C,WAAW,CAAC,CAAD,CAA1B,EAA+BgC,QAA/B,EAAP;AAEH,GAHD,CAGE,OAAOE,KAAP,EAAc;AACZC,WAAO,CAACC,GAAR,CAAYF,KAAZ;AACA,WAAOJ,EAAP;AACH;;AAEDA,IAAE,CAACrB,CAAH,GAAOxE,UAAU,CAAC+D,WAAW,CAAC,CAAD,CAAZ,EAAiB,EAAjB,CAAjB;AACA8B,IAAE,CAACpB,CAAH,GAAOzE,UAAU,CAAC+D,WAAW,CAAC,CAAD,CAAZ,EAAiB,EAAjB,CAAjB;;AAEA,MAAIrE,SAAS,CAACuB,IAAV,CAAe4E,EAAE,CAACrB,CAAlB,EAAqBoC,MAArB,MAAiClH,SAAS,CAACuB,IAAV,CAAe4E,EAAE,CAACpB,CAAlB,EAAqBmC,MAArB,EAArC,EAAoE;AAChE;AACAf,MAAE,CAACrE,OAAH,GAAaqE,EAAE,CAACX,CAAhB;AACAW,MAAE,CAACX,CAAH,GAAO,CAAP;AAEH,GALD,MAKO;AACH;AAEAW,MAAE,CAACrE,OAAH,GAAa2D,IAAI,CAACC,KAAL,CAAW,CAACS,EAAE,CAACX,CAAH,GAAO,EAAR,IAAc,CAAzB,CAAb;;AACA,QAAIW,EAAE,CAACrE,OAAH,GAAa,CAAjB,EAAoB;AAAEqE,QAAE,CAACrE,OAAH,GAAa,CAAb;AAAiB;;AAEvC,QAAI+C,aAAa,GAAGsB,EAAE,CAACX,CAAH,GAAO,EAA3B;AAEA,UAAML,GAAG,GAAGd,WAAW,CAACwC,KAAZ,CAAkB,CAAlB,EAAqB,CAArB,CAAZ;;AAEA,QAAIV,EAAE,CAACrE,OAAH,KAAe,CAAnB,EAAsB;AAClBqD,SAAG,CAACP,IAAJ,CAASvE,OAAO,CAAC8F,EAAE,CAACrE,OAAJ,CAAhB;AACAqD,SAAG,CAACP,IAAJ,CAAS,IAAT;AACAO,SAAG,CAACP,IAAJ,CAAS,IAAT;AACAC,mBAAa,IAAIsB,EAAE,CAACrE,OAAH,GAAa,CAAb,GAAiB,CAAlC;AACH;;AAED,UAAMW,MAAM,GAAG9B,SAAS,CAACE,GAAG,CAACmE,MAAJ,CAAWG,GAAX,CAAD,CAAxB;;AACA,QAAI;AACAgB,QAAE,CAAC5E,IAAH,GAAUiB,cAAc,CAACC,MAAD,EAAS;AAAEqC,SAAC,EAAEzE,OAAO,CAAC8F,EAAE,CAACrB,CAAJ,CAAZ;AAAoBC,SAAC,EAAE1E,OAAO,CAAC8F,EAAE,CAACpB,CAAJ,CAA9B;AAAsCF,qBAAa,EAAEA;AAArD,OAAT,CAAxB;AACH,KAFD,CAEE,OAAO0B,KAAP,EAAc;AACZC,aAAO,CAACC,GAAR,CAAYF,KAAZ;AACH;;AAEDJ,MAAE,CAACW,IAAH,GAAUnG,SAAS,CAACsG,cAAD,CAAnB;AACH;;AAEDd,IAAE,CAAC/D,IAAH,GAAU,IAAV;AAEA,SAAO+D,EAAP;AACH;;AAGD,OAAM,SAAUgB,KAAV,CAAgBF,cAAhB,EAAyC;AAC3C,QAAMN,OAAO,GAAG1G,QAAQ,CAACgH,cAAD,CAAxB,CAD2C,CAG3C;;AACA,MAAIN,OAAO,CAAC,CAAD,CAAP,GAAa,IAAjB,EAAuB;AAAE,WAAOK,MAAM,CAACL,OAAD,CAAb;AAAyB,GAJP,CAM3C;;;AACA,UAAQA,OAAO,CAAC,CAAD,CAAf;AACI,SAAK,CAAL;AACI,aAAOI,aAAa,CAACJ,OAAD,CAApB;;AACJ,SAAK,CAAL;AACI,aAAOD,aAAa,CAACC,OAAD,CAApB;;AACJ;AACI;AANR;;AASA,SAAOzF,MAAM,CAAC2E,UAAP,CAAkB,iCAAkCc,OAAO,CAAC,CAAD,CAAI,EAA/D,EAAmE3F,MAAM,CAAC8E,MAAP,CAAcC,qBAAjF,EAAwG;AAC3GC,aAAS,EAAE,kBADgG;AAE3GC,mBAAe,EAAEU,OAAO,CAAC,CAAD;AAFmF,GAAxG,CAAP;AAIH","names":["getAddress","BigNumber","arrayify","hexConcat","hexDataLength","hexDataSlice","hexlify","hexZeroPad","isBytesLike","splitSignature","stripZeros","Zero","keccak256","checkProperties","RLP","computePublicKey","recoverPublicKey","Logger","version","logger","TransactionTypes","handleAddress","value","handleNumber","from","transactionFields","name","maxLength","numeric","length","allowedTransactionKeys","chainId","data","gasLimit","gasPrice","nonce","to","type","computeAddress","key","publicKey","recoverAddress","digest","signature","formatNumber","result","toHexString","throwArgumentError","accessSetify","addr","storageKeys","address","map","storageKey","index","toLowerCase","accessListify","Array","isArray","set","Object","keys","reduce","accum","sort","a","b","localeCompare","formatAccessList","_serializeEip1559","transaction","maxFeePerGas","eq","fields","maxPriorityFeePerGas","accessList","sig","push","recoveryParam","r","s","encode","_serializeEip2930","_serialize","raw","forEach","fieldInfo","options","hexPad","v","Math","floor","pop","serialize","throwError","errors","UNSUPPORTED_OPERATION","operation","transactionType","_parseEipSignature","tx","recid","toNumber","Error","error","console","log","_parseEip1559","payload","decode","slice","hash","_parseEip2930","_parse","rawTransaction","isZero","parse"],"sources":["/Users/ianbrighton/Documents/Mach 34/BattleZipsV2/BattleZipsV2-Frontend/node_modules/@ethersproject/transactions/src.ts/index.ts"],"sourcesContent":["\"use strict\";\n\nimport { getAddress } from \"@ethersproject/address\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { arrayify, BytesLike, DataOptions, hexConcat, hexDataLength, hexDataSlice, hexlify, hexZeroPad, isBytesLike, SignatureLike, splitSignature, stripZeros, } from \"@ethersproject/bytes\";\nimport { Zero } from \"@ethersproject/constants\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { checkProperties } from \"@ethersproject/properties\";\nimport * as RLP from \"@ethersproject/rlp\";\nimport { computePublicKey, recoverPublicKey } from \"@ethersproject/signing-key\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type AccessList = Array<{ address: string, storageKeys: Array<string> }>;\n\n// Input allows flexibility in describing an access list\nexport type AccessListish = AccessList |\n                            Array<[ string, Array<string> ]> |\n                            Record<string, Array<string>>;\n\nexport enum TransactionTypes {\n    legacy = 0,\n    eip2930 = 1,\n    eip1559 = 2,\n};\n\nexport type UnsignedTransaction = {\n    to?: string;\n    nonce?: number;\n\n    gasLimit?: BigNumberish;\n    gasPrice?: BigNumberish;\n\n    data?: BytesLike;\n    value?: BigNumberish;\n    chainId?: number;\n\n    // Typed-Transaction features\n    type?: number | null;\n\n    // EIP-2930; Type 1 & EIP-1559; Type 2\n    accessList?: AccessListish;\n\n    // EIP-1559; Type 2\n    maxPriorityFeePerGas?: BigNumberish;\n    maxFeePerGas?: BigNumberish;\n}\n\nexport interface Transaction {\n    hash?: string;\n\n    to?: string;\n    from?: string;\n    nonce: number;\n\n    gasLimit: BigNumber;\n    gasPrice?: BigNumber;\n\n    data: string;\n    value: BigNumber;\n    chainId: number;\n\n    r?: string;\n    s?: string;\n    v?: number;\n\n    // Typed-Transaction features\n    type?: number | null;\n\n    // EIP-2930; Type 1 & EIP-1559; Type 2\n    accessList?: AccessList;\n\n    // EIP-1559; Type 2\n    maxPriorityFeePerGas?: BigNumber;\n    maxFeePerGas?: BigNumber;\n}\n\n///////////////////////////////\n\nfunction handleAddress(value: string): string {\n    if (value === \"0x\") { return null; }\n    return getAddress(value);\n}\n\nfunction handleNumber(value: string): BigNumber {\n    if (value === \"0x\") { return Zero; }\n    return BigNumber.from(value);\n}\n\n// Legacy Transaction Fields\nconst transactionFields = [\n    { name: \"nonce\",    maxLength: 32, numeric: true },\n    { name: \"gasPrice\", maxLength: 32, numeric: true },\n    { name: \"gasLimit\", maxLength: 32, numeric: true },\n    { name: \"to\",          length: 20 },\n    { name: \"value\",    maxLength: 32, numeric: true },\n    { name: \"data\" },\n];\n\nconst allowedTransactionKeys: { [ key: string ]: boolean } = {\n    chainId: true, data: true, gasLimit: true, gasPrice:true, nonce: true, to: true, type: true, value: true\n}\n\nexport function computeAddress(key: BytesLike | string): string {\n    const publicKey = computePublicKey(key);\n    return getAddress(hexDataSlice(keccak256(hexDataSlice(publicKey, 1)), 12));\n}\n\nexport function recoverAddress(digest: BytesLike, signature: SignatureLike): string {\n    return computeAddress(recoverPublicKey(arrayify(digest), signature));\n}\n\nfunction formatNumber(value: BigNumberish, name: string): Uint8Array {\n    const result = stripZeros(BigNumber.from(value).toHexString());\n    if (result.length > 32) {\n        logger.throwArgumentError(\"invalid length for \" + name, (\"transaction:\" + name), value);\n    }\n    return result;\n}\n\nfunction accessSetify(addr: string, storageKeys: Array<string>): { address: string,storageKeys: Array<string> } {\n    return {\n        address: getAddress(addr),\n        storageKeys: (storageKeys || []).map((storageKey, index) => {\n            if (hexDataLength(storageKey) !== 32) {\n                logger.throwArgumentError(\"invalid access list storageKey\", `accessList[${ addr }:${ index }]`, storageKey)\n            }\n            return storageKey.toLowerCase();\n        })\n    };\n}\n\nexport function accessListify(value: AccessListish): AccessList {\n    if (Array.isArray(value)) {\n        return (<Array<[ string, Array<string>] | { address: string, storageKeys: Array<string>}>>value).map((set, index) => {\n            if (Array.isArray(set)) {\n                if (set.length > 2) {\n                    logger.throwArgumentError(\"access list expected to be [ address, storageKeys[] ]\", `value[${ index }]`, set);\n                }\n                return accessSetify(set[0], set[1])\n            }\n            return accessSetify(set.address, set.storageKeys);\n        });\n    }\n\n    const result: Array<{ address: string, storageKeys: Array<string> }> = Object.keys(value).map((addr) => {\n        const storageKeys: Record<string, true> = value[addr].reduce((accum, storageKey) => {\n            accum[storageKey] = true;\n            return accum;\n        }, <Record<string, true>>{ });\n        return accessSetify(addr, Object.keys(storageKeys).sort())\n    });\n    result.sort((a, b) => (a.address.localeCompare(b.address)));\n    return result;\n}\n\nfunction formatAccessList(value: AccessListish): Array<[ string, Array<string> ]> {\n    return accessListify(value).map((set) => [ set.address, set.storageKeys ]);\n}\n\nfunction _serializeEip1559(transaction: UnsignedTransaction, signature?: SignatureLike): string {\n    // If there is an explicit gasPrice, make sure it matches the\n    // EIP-1559 fees; otherwise they may not understand what they\n    // think they are setting in terms of fee.\n    if (transaction.gasPrice != null) {\n        const gasPrice = BigNumber.from(transaction.gasPrice);\n        const maxFeePerGas = BigNumber.from(transaction.maxFeePerGas || 0);\n        if (!gasPrice.eq(maxFeePerGas)) {\n            logger.throwArgumentError(\"mismatch EIP-1559 gasPrice != maxFeePerGas\", \"tx\", {\n                gasPrice, maxFeePerGas\n            });\n        }\n    }\n\n    const fields: any = [\n        formatNumber(transaction.chainId || 0, \"chainId\"),\n        formatNumber(transaction.nonce || 0, \"nonce\"),\n        formatNumber(transaction.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"),\n        formatNumber(transaction.maxFeePerGas || 0, \"maxFeePerGas\"),\n        formatNumber(transaction.gasLimit || 0, \"gasLimit\"),\n        ((transaction.to != null) ? getAddress(transaction.to): \"0x\"),\n        formatNumber(transaction.value || 0, \"value\"),\n        (transaction.data || \"0x\"),\n        (formatAccessList(transaction.accessList || []))\n    ];\n\n    if (signature) {\n        const sig = splitSignature(signature);\n        fields.push(formatNumber(sig.recoveryParam, \"recoveryParam\"));\n        fields.push(stripZeros(sig.r));\n        fields.push(stripZeros(sig.s));\n    }\n\n    return hexConcat([ \"0x02\", RLP.encode(fields)]);\n}\n\nfunction _serializeEip2930(transaction: UnsignedTransaction, signature?: SignatureLike): string {\n    const fields: any = [\n        formatNumber(transaction.chainId || 0, \"chainId\"),\n        formatNumber(transaction.nonce || 0, \"nonce\"),\n        formatNumber(transaction.gasPrice || 0, \"gasPrice\"),\n        formatNumber(transaction.gasLimit || 0, \"gasLimit\"),\n        ((transaction.to != null) ? getAddress(transaction.to): \"0x\"),\n        formatNumber(transaction.value || 0, \"value\"),\n        (transaction.data || \"0x\"),\n        (formatAccessList(transaction.accessList || []))\n    ];\n\n    if (signature) {\n        const sig = splitSignature(signature);\n        fields.push(formatNumber(sig.recoveryParam, \"recoveryParam\"));\n        fields.push(stripZeros(sig.r));\n        fields.push(stripZeros(sig.s));\n    }\n\n    return hexConcat([ \"0x01\", RLP.encode(fields)]);\n}\n\n// Legacy Transactions and EIP-155\nfunction _serialize(transaction: UnsignedTransaction, signature?: SignatureLike): string {\n    checkProperties(transaction, allowedTransactionKeys);\n\n    const raw: Array<string | Uint8Array> = [];\n\n    transactionFields.forEach(function(fieldInfo) {\n        let value = (<any>transaction)[fieldInfo.name] || ([]);\n        const options: DataOptions = { };\n        if (fieldInfo.numeric) { options.hexPad = \"left\"; }\n        value = arrayify(hexlify(value, options));\n\n        // Fixed-width field\n        if (fieldInfo.length && value.length !== fieldInfo.length && value.length > 0) {\n            logger.throwArgumentError(\"invalid length for \" + fieldInfo.name, (\"transaction:\" + fieldInfo.name), value);\n        }\n\n        // Variable-width (with a maximum)\n        if (fieldInfo.maxLength) {\n            value = stripZeros(value);\n            if (value.length > fieldInfo.maxLength) {\n                logger.throwArgumentError(\"invalid length for \" + fieldInfo.name, (\"transaction:\" + fieldInfo.name), value );\n            }\n        }\n\n        raw.push(hexlify(value));\n    });\n\n    let chainId = 0;\n    if (transaction.chainId != null) {\n        // A chainId was provided; if non-zero we'll use EIP-155\n        chainId = transaction.chainId;\n\n        if (typeof(chainId) !== \"number\") {\n            logger.throwArgumentError(\"invalid transaction.chainId\", \"transaction\", transaction);\n        }\n\n    } else if (signature && !isBytesLike(signature) && signature.v > 28) {\n        // No chainId provided, but the signature is signing with EIP-155; derive chainId\n        chainId = Math.floor((signature.v - 35) / 2);\n    }\n\n    // We have an EIP-155 transaction (chainId was specified and non-zero)\n    if (chainId !== 0) {\n        raw.push(hexlify(chainId)); // @TODO: hexValue?\n        raw.push(\"0x\");\n        raw.push(\"0x\");\n    }\n\n    // Requesting an unsigned transaction\n    if (!signature) {\n        return RLP.encode(raw);\n    }\n\n    // The splitSignature will ensure the transaction has a recoveryParam in the\n    // case that the signTransaction function only adds a v.\n    const sig = splitSignature(signature);\n\n    // We pushed a chainId and null r, s on for hashing only; remove those\n    let v = 27 + sig.recoveryParam\n    if (chainId !== 0) {\n        raw.pop();\n        raw.pop();\n        raw.pop();\n        v += chainId * 2 + 8;\n\n        // If an EIP-155 v (directly or indirectly; maybe _vs) was provided, check it!\n        if (sig.v > 28 && sig.v !== v) {\n             logger.throwArgumentError(\"transaction.chainId/signature.v mismatch\", \"signature\", signature);\n        }\n    } else if (sig.v !== v) {\n         logger.throwArgumentError(\"transaction.chainId/signature.v mismatch\", \"signature\", signature);\n    }\n\n    raw.push(hexlify(v));\n    raw.push(stripZeros(arrayify(sig.r)));\n    raw.push(stripZeros(arrayify(sig.s)));\n\n    return RLP.encode(raw);\n}\n\nexport function serialize(transaction: UnsignedTransaction, signature?: SignatureLike): string {\n    // Legacy and EIP-155 Transactions\n    if (transaction.type == null || transaction.type === 0) {\n        if (transaction.accessList != null) {\n            logger.throwArgumentError(\"untyped transactions do not support accessList; include type: 1\", \"transaction\", transaction);\n        }\n        return _serialize(transaction, signature);\n    }\n\n    // Typed Transactions (EIP-2718)\n    switch (transaction.type) {\n        case 1:\n            return _serializeEip2930(transaction, signature);\n        case 2:\n            return _serializeEip1559(transaction, signature);\n        default:\n            break;\n    }\n\n    return logger.throwError(`unsupported transaction type: ${ transaction.type }`, Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"serializeTransaction\",\n        transactionType: transaction.type\n    });\n}\n\nfunction _parseEipSignature(tx: Transaction, fields: Array<string>, serialize: (tx: UnsignedTransaction) => string): void {\n    try {\n        const recid = handleNumber(fields[0]).toNumber();\n        if (recid !== 0 && recid !== 1) { throw new Error(\"bad recid\"); }\n        tx.v = recid;\n    } catch (error) {\n        logger.throwArgumentError(\"invalid v for transaction type: 1\", \"v\", fields[0]);\n    }\n\n    tx.r = hexZeroPad(fields[1], 32);\n    tx.s = hexZeroPad(fields[2], 32);\n\n    try {\n        const digest = keccak256(serialize(tx));\n        tx.from = recoverAddress(digest, { r: tx.r, s: tx.s, recoveryParam: tx.v });\n    } catch (error) {\n        console.log(error);\n    }\n}\n\nfunction _parseEip1559(payload: Uint8Array): Transaction {\n    const transaction = RLP.decode(payload.slice(1));\n\n    if (transaction.length !== 9 && transaction.length !== 12) {\n        logger.throwArgumentError(\"invalid component count for transaction type: 2\", \"payload\", hexlify(payload));\n    }\n\n    const maxPriorityFeePerGas = handleNumber(transaction[2]);\n    const maxFeePerGas = handleNumber(transaction[3]);\n    const tx: Transaction = {\n        type:                  2,\n        chainId:               handleNumber(transaction[0]).toNumber(),\n        nonce:                 handleNumber(transaction[1]).toNumber(),\n        maxPriorityFeePerGas:  maxPriorityFeePerGas,\n        maxFeePerGas:          maxFeePerGas,\n        gasPrice:              null,\n        gasLimit:              handleNumber(transaction[4]),\n        to:                    handleAddress(transaction[5]),\n        value:                 handleNumber(transaction[6]),\n        data:                  transaction[7],\n        accessList:            accessListify(transaction[8]),\n    };\n\n    // Unsigned EIP-1559 Transaction\n    if (transaction.length === 9) { return tx; }\n\n    tx.hash = keccak256(payload);\n\n    _parseEipSignature(tx, transaction.slice(9), _serializeEip1559);\n\n    return tx;\n}\n\nfunction _parseEip2930(payload: Uint8Array): Transaction {\n    const transaction = RLP.decode(payload.slice(1));\n\n    if (transaction.length !== 8 && transaction.length !== 11) {\n        logger.throwArgumentError(\"invalid component count for transaction type: 1\", \"payload\", hexlify(payload));\n    }\n\n    const tx: Transaction = {\n        type:       1,\n        chainId:    handleNumber(transaction[0]).toNumber(),\n        nonce:      handleNumber(transaction[1]).toNumber(),\n        gasPrice:   handleNumber(transaction[2]),\n        gasLimit:   handleNumber(transaction[3]),\n        to:         handleAddress(transaction[4]),\n        value:      handleNumber(transaction[5]),\n        data:       transaction[6],\n        accessList: accessListify(transaction[7])\n    };\n\n    // Unsigned EIP-2930 Transaction\n    if (transaction.length === 8) { return tx; }\n\n    tx.hash = keccak256(payload);\n\n    _parseEipSignature(tx, transaction.slice(8), _serializeEip2930);\n\n    return tx;\n}\n\n// Legacy Transactions and EIP-155\nfunction _parse(rawTransaction: Uint8Array): Transaction {\n    const transaction = RLP.decode(rawTransaction);\n\n    if (transaction.length !== 9 && transaction.length !== 6) {\n        logger.throwArgumentError(\"invalid raw transaction\", \"rawTransaction\", rawTransaction);\n    }\n\n    const tx: Transaction = {\n        nonce:    handleNumber(transaction[0]).toNumber(),\n        gasPrice: handleNumber(transaction[1]),\n        gasLimit: handleNumber(transaction[2]),\n        to:       handleAddress(transaction[3]),\n        value:    handleNumber(transaction[4]),\n        data:     transaction[5],\n        chainId:  0\n    };\n\n    // Legacy unsigned transaction\n    if (transaction.length === 6) { return tx; }\n\n    try {\n        tx.v = BigNumber.from(transaction[6]).toNumber();\n\n    } catch (error) {\n        console.log(error);\n        return tx;\n    }\n\n    tx.r = hexZeroPad(transaction[7], 32);\n    tx.s = hexZeroPad(transaction[8], 32);\n\n    if (BigNumber.from(tx.r).isZero() && BigNumber.from(tx.s).isZero()) {\n        // EIP-155 unsigned transaction\n        tx.chainId = tx.v;\n        tx.v = 0;\n\n    } else {\n        // Signed Transaction\n\n        tx.chainId = Math.floor((tx.v - 35) / 2);\n        if (tx.chainId < 0) { tx.chainId = 0; }\n\n        let recoveryParam = tx.v - 27;\n\n        const raw = transaction.slice(0, 6);\n\n        if (tx.chainId !== 0) {\n            raw.push(hexlify(tx.chainId));\n            raw.push(\"0x\");\n            raw.push(\"0x\");\n            recoveryParam -= tx.chainId * 2 + 8;\n        }\n\n        const digest = keccak256(RLP.encode(raw));\n        try {\n            tx.from = recoverAddress(digest, { r: hexlify(tx.r), s: hexlify(tx.s), recoveryParam: recoveryParam });\n        } catch (error) {\n            console.log(error);\n        }\n\n        tx.hash = keccak256(rawTransaction);\n    }\n\n    tx.type = null;\n\n    return tx;\n}\n\n\nexport function parse(rawTransaction: BytesLike): Transaction {\n    const payload = arrayify(rawTransaction);\n\n    // Legacy and EIP-155 Transactions\n    if (payload[0] > 0x7f) { return _parse(payload); }\n\n    // Typed Transaction (EIP-2718)\n    switch (payload[0]) {\n        case 1:\n            return _parseEip2930(payload);\n        case 2:\n            return _parseEip1559(payload);\n        default:\n            break;\n    }\n\n    return logger.throwError(`unsupported transaction type: ${ payload[0] }`, Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"parseTransaction\",\n        transactionType: payload[0]\n    });\n}\n\n"]},"metadata":{},"sourceType":"module"}