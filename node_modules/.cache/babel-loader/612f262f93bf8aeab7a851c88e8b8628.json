{"ast":null,"code":"\"use strict\";\n\nimport { arrayify, hexZeroPad, isBytes } from \"@ethersproject/bytes\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { BigNumber, isBigNumberish } from \"./bignumber\";\nconst _constructorGuard = {};\nconst Zero = BigNumber.from(0);\nconst NegativeOne = BigNumber.from(-1);\n\nfunction throwFault(message, fault, operation, value) {\n  const params = {\n    fault: fault,\n    operation: operation\n  };\n\n  if (value !== undefined) {\n    params.value = value;\n  }\n\n  return logger.throwError(message, Logger.errors.NUMERIC_FAULT, params);\n} // Constant to pull zeros from for multipliers\n\n\nlet zeros = \"0\";\n\nwhile (zeros.length < 256) {\n  zeros += zeros;\n} // Returns a string \"1\" followed by decimal \"0\"s\n\n\nfunction getMultiplier(decimals) {\n  if (typeof decimals !== \"number\") {\n    try {\n      decimals = BigNumber.from(decimals).toNumber();\n    } catch (e) {}\n  }\n\n  if (typeof decimals === \"number\" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {\n    return \"1\" + zeros.substring(0, decimals);\n  }\n\n  return logger.throwArgumentError(\"invalid decimal size\", \"decimals\", decimals);\n}\n\nexport function formatFixed(value, decimals) {\n  if (decimals == null) {\n    decimals = 0;\n  }\n\n  const multiplier = getMultiplier(decimals); // Make sure wei is a big number (convert as necessary)\n\n  value = BigNumber.from(value);\n  const negative = value.lt(Zero);\n\n  if (negative) {\n    value = value.mul(NegativeOne);\n  }\n\n  let fraction = value.mod(multiplier).toString();\n\n  while (fraction.length < multiplier.length - 1) {\n    fraction = \"0\" + fraction;\n  } // Strip training 0\n\n\n  fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];\n  const whole = value.div(multiplier).toString();\n\n  if (multiplier.length === 1) {\n    value = whole;\n  } else {\n    value = whole + \".\" + fraction;\n  }\n\n  if (negative) {\n    value = \"-\" + value;\n  }\n\n  return value;\n}\nexport function parseFixed(value, decimals) {\n  if (decimals == null) {\n    decimals = 0;\n  }\n\n  const multiplier = getMultiplier(decimals);\n\n  if (typeof value !== \"string\" || !value.match(/^-?[0-9.]+$/)) {\n    logger.throwArgumentError(\"invalid decimal value\", \"value\", value);\n  } // Is it negative?\n\n\n  const negative = value.substring(0, 1) === \"-\";\n\n  if (negative) {\n    value = value.substring(1);\n  }\n\n  if (value === \".\") {\n    logger.throwArgumentError(\"missing value\", \"value\", value);\n  } // Split it into a whole and fractional part\n\n\n  const comps = value.split(\".\");\n\n  if (comps.length > 2) {\n    logger.throwArgumentError(\"too many decimal points\", \"value\", value);\n  }\n\n  let whole = comps[0],\n      fraction = comps[1];\n\n  if (!whole) {\n    whole = \"0\";\n  }\n\n  if (!fraction) {\n    fraction = \"0\";\n  } // Trim trailing zeros\n\n\n  while (fraction[fraction.length - 1] === \"0\") {\n    fraction = fraction.substring(0, fraction.length - 1);\n  } // Check the fraction doesn't exceed our decimals size\n\n\n  if (fraction.length > multiplier.length - 1) {\n    throwFault(\"fractional component exceeds decimals\", \"underflow\", \"parseFixed\");\n  } // If decimals is 0, we have an empty string for fraction\n\n\n  if (fraction === \"\") {\n    fraction = \"0\";\n  } // Fully pad the string with zeros to get to wei\n\n\n  while (fraction.length < multiplier.length - 1) {\n    fraction += \"0\";\n  }\n\n  const wholeValue = BigNumber.from(whole);\n  const fractionValue = BigNumber.from(fraction);\n  let wei = wholeValue.mul(multiplier).add(fractionValue);\n\n  if (negative) {\n    wei = wei.mul(NegativeOne);\n  }\n\n  return wei;\n}\nexport class FixedFormat {\n  constructor(constructorGuard, signed, width, decimals) {\n    if (constructorGuard !== _constructorGuard) {\n      logger.throwError(\"cannot use FixedFormat constructor; use FixedFormat.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"new FixedFormat\"\n      });\n    }\n\n    this.signed = signed;\n    this.width = width;\n    this.decimals = decimals;\n    this.name = (signed ? \"\" : \"u\") + \"fixed\" + String(width) + \"x\" + String(decimals);\n    this._multiplier = getMultiplier(decimals);\n    Object.freeze(this);\n  }\n\n  static from(value) {\n    if (value instanceof FixedFormat) {\n      return value;\n    }\n\n    if (typeof value === \"number\") {\n      value = `fixed128x${value}`;\n    }\n\n    let signed = true;\n    let width = 128;\n    let decimals = 18;\n\n    if (typeof value === \"string\") {\n      if (value === \"fixed\") {// defaults...\n      } else if (value === \"ufixed\") {\n        signed = false;\n      } else {\n        const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);\n\n        if (!match) {\n          logger.throwArgumentError(\"invalid fixed format\", \"format\", value);\n        }\n\n        signed = match[1] !== \"u\";\n        width = parseInt(match[2]);\n        decimals = parseInt(match[3]);\n      }\n    } else if (value) {\n      const check = (key, type, defaultValue) => {\n        if (value[key] == null) {\n          return defaultValue;\n        }\n\n        if (typeof value[key] !== type) {\n          logger.throwArgumentError(\"invalid fixed format (\" + key + \" not \" + type + \")\", \"format.\" + key, value[key]);\n        }\n\n        return value[key];\n      };\n\n      signed = check(\"signed\", \"boolean\", signed);\n      width = check(\"width\", \"number\", width);\n      decimals = check(\"decimals\", \"number\", decimals);\n    }\n\n    if (width % 8) {\n      logger.throwArgumentError(\"invalid fixed format width (not byte aligned)\", \"format.width\", width);\n    }\n\n    if (decimals > 80) {\n      logger.throwArgumentError(\"invalid fixed format (decimals too large)\", \"format.decimals\", decimals);\n    }\n\n    return new FixedFormat(_constructorGuard, signed, width, decimals);\n  }\n\n}\nexport class FixedNumber {\n  constructor(constructorGuard, hex, value, format) {\n    logger.checkNew(new.target, FixedNumber);\n\n    if (constructorGuard !== _constructorGuard) {\n      logger.throwError(\"cannot use FixedNumber constructor; use FixedNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"new FixedFormat\"\n      });\n    }\n\n    this.format = format;\n    this._hex = hex;\n    this._value = value;\n    this._isFixedNumber = true;\n    Object.freeze(this);\n  }\n\n  _checkFormat(other) {\n    if (this.format.name !== other.format.name) {\n      logger.throwArgumentError(\"incompatible format; use fixedNumber.toFormat\", \"other\", other);\n    }\n  }\n\n  addUnsafe(other) {\n    this._checkFormat(other);\n\n    const a = parseFixed(this._value, this.format.decimals);\n    const b = parseFixed(other._value, other.format.decimals);\n    return FixedNumber.fromValue(a.add(b), this.format.decimals, this.format);\n  }\n\n  subUnsafe(other) {\n    this._checkFormat(other);\n\n    const a = parseFixed(this._value, this.format.decimals);\n    const b = parseFixed(other._value, other.format.decimals);\n    return FixedNumber.fromValue(a.sub(b), this.format.decimals, this.format);\n  }\n\n  mulUnsafe(other) {\n    this._checkFormat(other);\n\n    const a = parseFixed(this._value, this.format.decimals);\n    const b = parseFixed(other._value, other.format.decimals);\n    return FixedNumber.fromValue(a.mul(b).div(this.format._multiplier), this.format.decimals, this.format);\n  }\n\n  divUnsafe(other) {\n    this._checkFormat(other);\n\n    const a = parseFixed(this._value, this.format.decimals);\n    const b = parseFixed(other._value, other.format.decimals);\n    return FixedNumber.fromValue(a.mul(this.format._multiplier).div(b), this.format.decimals, this.format);\n  }\n\n  floor() {\n    const comps = this.toString().split(\".\");\n\n    if (comps.length === 1) {\n      comps.push(\"0\");\n    }\n\n    let result = FixedNumber.from(comps[0], this.format);\n    const hasFraction = !comps[1].match(/^(0*)$/);\n\n    if (this.isNegative() && hasFraction) {\n      result = result.subUnsafe(ONE.toFormat(result.format));\n    }\n\n    return result;\n  }\n\n  ceiling() {\n    const comps = this.toString().split(\".\");\n\n    if (comps.length === 1) {\n      comps.push(\"0\");\n    }\n\n    let result = FixedNumber.from(comps[0], this.format);\n    const hasFraction = !comps[1].match(/^(0*)$/);\n\n    if (!this.isNegative() && hasFraction) {\n      result = result.addUnsafe(ONE.toFormat(result.format));\n    }\n\n    return result;\n  } // @TODO: Support other rounding algorithms\n\n\n  round(decimals) {\n    if (decimals == null) {\n      decimals = 0;\n    } // If we are already in range, we're done\n\n\n    const comps = this.toString().split(\".\");\n\n    if (comps.length === 1) {\n      comps.push(\"0\");\n    }\n\n    if (decimals < 0 || decimals > 80 || decimals % 1) {\n      logger.throwArgumentError(\"invalid decimal count\", \"decimals\", decimals);\n    }\n\n    if (comps[1].length <= decimals) {\n      return this;\n    }\n\n    const factor = FixedNumber.from(\"1\" + zeros.substring(0, decimals), this.format);\n    const bump = BUMP.toFormat(this.format);\n    return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);\n  }\n\n  isZero() {\n    return this._value === \"0.0\" || this._value === \"0\";\n  }\n\n  isNegative() {\n    return this._value[0] === \"-\";\n  }\n\n  toString() {\n    return this._value;\n  }\n\n  toHexString(width) {\n    if (width == null) {\n      return this._hex;\n    }\n\n    if (width % 8) {\n      logger.throwArgumentError(\"invalid byte width\", \"width\", width);\n    }\n\n    const hex = BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();\n    return hexZeroPad(hex, width / 8);\n  }\n\n  toUnsafeFloat() {\n    return parseFloat(this.toString());\n  }\n\n  toFormat(format) {\n    return FixedNumber.fromString(this._value, format);\n  }\n\n  static fromValue(value, decimals, format) {\n    // If decimals looks more like a format, and there is no format, shift the parameters\n    if (format == null && decimals != null && !isBigNumberish(decimals)) {\n      format = decimals;\n      decimals = null;\n    }\n\n    if (decimals == null) {\n      decimals = 0;\n    }\n\n    if (format == null) {\n      format = \"fixed\";\n    }\n\n    return FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format));\n  }\n\n  static fromString(value, format) {\n    if (format == null) {\n      format = \"fixed\";\n    }\n\n    const fixedFormat = FixedFormat.from(format);\n    const numeric = parseFixed(value, fixedFormat.decimals);\n\n    if (!fixedFormat.signed && numeric.lt(Zero)) {\n      throwFault(\"unsigned value cannot be negative\", \"overflow\", \"value\", value);\n    }\n\n    let hex = null;\n\n    if (fixedFormat.signed) {\n      hex = numeric.toTwos(fixedFormat.width).toHexString();\n    } else {\n      hex = numeric.toHexString();\n      hex = hexZeroPad(hex, fixedFormat.width / 8);\n    }\n\n    const decimal = formatFixed(numeric, fixedFormat.decimals);\n    return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);\n  }\n\n  static fromBytes(value, format) {\n    if (format == null) {\n      format = \"fixed\";\n    }\n\n    const fixedFormat = FixedFormat.from(format);\n\n    if (arrayify(value).length > fixedFormat.width / 8) {\n      throw new Error(\"overflow\");\n    }\n\n    let numeric = BigNumber.from(value);\n\n    if (fixedFormat.signed) {\n      numeric = numeric.fromTwos(fixedFormat.width);\n    }\n\n    const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();\n    const decimal = formatFixed(numeric, fixedFormat.decimals);\n    return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);\n  }\n\n  static from(value, format) {\n    if (typeof value === \"string\") {\n      return FixedNumber.fromString(value, format);\n    }\n\n    if (isBytes(value)) {\n      return FixedNumber.fromBytes(value, format);\n    }\n\n    try {\n      return FixedNumber.fromValue(value, 0, format);\n    } catch (error) {\n      // Allow NUMERIC_FAULT to bubble up\n      if (error.code !== Logger.errors.INVALID_ARGUMENT) {\n        throw error;\n      }\n    }\n\n    return logger.throwArgumentError(\"invalid FixedNumber value\", \"value\", value);\n  }\n\n  static isFixedNumber(value) {\n    return !!(value && value._isFixedNumber);\n  }\n\n}\nconst ONE = FixedNumber.from(1);\nconst BUMP = FixedNumber.from(\"0.5\");","map":{"version":3,"mappings":"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","names":["arrayify","hexZeroPad","isBytes","Logger","version","logger","BigNumber","isBigNumberish","_constructorGuard","Zero","from","NegativeOne","throwFault","message","fault","operation","value","params","undefined","throwError","errors","NUMERIC_FAULT","zeros","length","getMultiplier","decimals","toNumber","e","substring","throwArgumentError","formatFixed","multiplier","negative","lt","mul","fraction","mod","toString","match","whole","div","parseFixed","comps","split","wholeValue","fractionValue","wei","add","FixedFormat","constructor","constructorGuard","signed","width","UNSUPPORTED_OPERATION","name","String","_multiplier","Object","freeze","parseInt","check","key","type","defaultValue","FixedNumber","hex","format","checkNew","new","target","_hex","_value","_isFixedNumber","_checkFormat","other","addUnsafe","a","b","fromValue","subUnsafe","sub","mulUnsafe","divUnsafe","floor","push","result","hasFraction","isNegative","ONE","toFormat","ceiling","round","factor","bump","BUMP","isZero","toHexString","fromTwos","toTwos","toUnsafeFloat","parseFloat","fromString","fixedFormat","numeric","decimal","fromBytes","Error","error","code","INVALID_ARGUMENT","isFixedNumber"],"sources":["/Users/ianbrighton/Documents/Mach 34/BattleZipsV2/BattleZipsV2-Frontend/node_modules/@ethersproject/bignumber/src.ts/fixednumber.ts"],"sourcesContent":["\"use strict\";\n\nimport { arrayify, BytesLike, hexZeroPad, isBytes } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { BigNumber, BigNumberish, isBigNumberish } from \"./bignumber\";\n\nconst _constructorGuard = { };\n\nconst Zero = BigNumber.from(0);\nconst NegativeOne = BigNumber.from(-1);\n\nfunction throwFault(message: string, fault: string, operation: string, value?: any): never {\n    const params: any = { fault: fault, operation: operation };\n    if (value !== undefined) { params.value = value; }\n    return logger.throwError(message, Logger.errors.NUMERIC_FAULT, params);\n}\n\n// Constant to pull zeros from for multipliers\nlet zeros = \"0\";\nwhile (zeros.length < 256) { zeros += zeros; }\n\n// Returns a string \"1\" followed by decimal \"0\"s\nfunction getMultiplier(decimals: BigNumberish): string {\n\n    if (typeof(decimals) !== \"number\") {\n        try {\n            decimals = BigNumber.from(decimals).toNumber();\n        } catch (e) { }\n    }\n\n    if (typeof(decimals) === \"number\" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {\n        return (\"1\" + zeros.substring(0, decimals));\n    }\n\n    return logger.throwArgumentError(\"invalid decimal size\", \"decimals\", decimals);\n}\n\nexport function formatFixed(value: BigNumberish, decimals?: string | BigNumberish): string {\n    if (decimals == null) { decimals = 0; }\n    const multiplier = getMultiplier(decimals);\n\n    // Make sure wei is a big number (convert as necessary)\n    value = BigNumber.from(value);\n\n    const negative = value.lt(Zero);\n    if (negative) { value = value.mul(NegativeOne); }\n\n    let fraction = value.mod(multiplier).toString();\n    while (fraction.length < multiplier.length - 1) { fraction = \"0\" + fraction; }\n\n    // Strip training 0\n    fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];\n\n    const whole = value.div(multiplier).toString();\n    if (multiplier.length === 1) {\n        value = whole;\n    } else {\n        value = whole + \".\" + fraction;\n    }\n\n    if (negative) { value = \"-\" + value; }\n\n    return value;\n}\n\nexport function parseFixed(value: string, decimals?: BigNumberish): BigNumber {\n\n    if (decimals == null) { decimals = 0; }\n    const multiplier = getMultiplier(decimals);\n\n    if (typeof(value) !== \"string\" || !value.match(/^-?[0-9.]+$/)) {\n        logger.throwArgumentError(\"invalid decimal value\", \"value\", value);\n    }\n\n    // Is it negative?\n    const negative = (value.substring(0, 1) === \"-\");\n    if (negative) { value = value.substring(1); }\n\n    if (value === \".\") {\n        logger.throwArgumentError(\"missing value\", \"value\", value);\n    }\n\n    // Split it into a whole and fractional part\n    const comps = value.split(\".\");\n    if (comps.length > 2) {\n        logger.throwArgumentError(\"too many decimal points\", \"value\", value);\n    }\n\n    let whole = comps[0], fraction = comps[1];\n    if (!whole) { whole = \"0\"; }\n    if (!fraction) { fraction = \"0\"; }\n\n    // Trim trailing zeros\n    while (fraction[fraction.length - 1] === \"0\") {\n        fraction = fraction.substring(0, fraction.length - 1);\n    }\n\n    // Check the fraction doesn't exceed our decimals size\n    if (fraction.length > multiplier.length - 1) {\n        throwFault(\"fractional component exceeds decimals\", \"underflow\", \"parseFixed\");\n    }\n\n    // If decimals is 0, we have an empty string for fraction\n    if (fraction === \"\") { fraction = \"0\"; }\n\n    // Fully pad the string with zeros to get to wei\n    while (fraction.length < multiplier.length - 1) { fraction += \"0\"; }\n\n    const wholeValue = BigNumber.from(whole);\n    const fractionValue = BigNumber.from(fraction);\n\n    let wei = (wholeValue.mul(multiplier)).add(fractionValue);\n\n    if (negative) { wei = wei.mul(NegativeOne); }\n\n    return wei;\n}\n\n\nexport class FixedFormat {\n    readonly signed: boolean;\n    readonly width: number;\n    readonly decimals: number;\n    readonly name: string;\n    readonly _multiplier: string;\n\n    constructor(constructorGuard: any, signed: boolean, width: number, decimals: number) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot use FixedFormat constructor; use FixedFormat.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new FixedFormat\"\n            });\n        }\n\n        this.signed = signed;\n        this.width = width;\n        this.decimals = decimals;\n\n        this.name = (signed ? \"\": \"u\") + \"fixed\" + String(width) + \"x\" + String(decimals);\n\n        this._multiplier = getMultiplier(decimals);\n\n        Object.freeze(this);\n    }\n\n    static from(value: any): FixedFormat {\n        if (value instanceof FixedFormat) { return value; }\n\n        if (typeof(value) === \"number\") {\n            value = `fixed128x${value}`\n        }\n\n        let signed = true;\n        let width = 128;\n        let decimals = 18;\n\n        if (typeof(value) === \"string\") {\n            if (value === \"fixed\") {\n                // defaults...\n            } else if (value === \"ufixed\") {\n                signed = false;\n            } else {\n                const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);\n                if (!match) { logger.throwArgumentError(\"invalid fixed format\", \"format\", value); }\n                signed = (match[1] !== \"u\");\n                width = parseInt(match[2]);\n                decimals = parseInt(match[3]);\n            }\n        } else if (value) {\n            const check = (key: string, type: string, defaultValue: any): any => {\n                if (value[key] == null) { return defaultValue; }\n                if (typeof(value[key]) !== type) {\n                    logger.throwArgumentError(\"invalid fixed format (\" + key + \" not \" + type +\")\", \"format.\" + key, value[key]);\n                }\n                return value[key];\n            }\n            signed = check(\"signed\", \"boolean\", signed);\n            width = check(\"width\", \"number\", width);\n            decimals = check(\"decimals\", \"number\", decimals);\n        }\n\n        if (width % 8) {\n            logger.throwArgumentError(\"invalid fixed format width (not byte aligned)\", \"format.width\", width);\n        }\n\n        if (decimals > 80) {\n            logger.throwArgumentError(\"invalid fixed format (decimals too large)\", \"format.decimals\", decimals);\n        }\n\n        return new FixedFormat(_constructorGuard, signed, width, decimals);\n    }\n}\n\nexport class FixedNumber {\n    readonly format: FixedFormat;\n    readonly _hex: string;\n    readonly _value: string;\n\n    readonly _isFixedNumber: boolean;\n\n    constructor(constructorGuard: any, hex: string, value: string, format?: FixedFormat) {\n        logger.checkNew(new.target, FixedNumber);\n\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot use FixedNumber constructor; use FixedNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new FixedFormat\"\n            });\n        }\n\n        this.format = format;\n        this._hex = hex;\n        this._value = value;\n\n        this._isFixedNumber = true;\n\n        Object.freeze(this);\n    }\n\n    _checkFormat(other: FixedNumber): void {\n        if (this.format.name !== other.format.name) {\n            logger.throwArgumentError(\"incompatible format; use fixedNumber.toFormat\", \"other\", other);\n        }\n    }\n\n    addUnsafe(other: FixedNumber): FixedNumber {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.add(b), this.format.decimals, this.format);\n    }\n\n    subUnsafe(other: FixedNumber): FixedNumber {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.sub(b), this.format.decimals, this.format);\n    }\n\n    mulUnsafe(other: FixedNumber): FixedNumber {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.mul(b).div(this.format._multiplier), this.format.decimals, this.format);\n    }\n\n    divUnsafe(other: FixedNumber): FixedNumber {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.mul(this.format._multiplier).div(b), this.format.decimals, this.format);\n    }\n\n    floor(): FixedNumber {\n        const comps = this.toString().split(\".\");\n        if (comps.length === 1) { comps.push(\"0\"); }\n\n        let result = FixedNumber.from(comps[0], this.format);\n\n        const hasFraction = !comps[1].match(/^(0*)$/);\n        if (this.isNegative() && hasFraction) {\n            result = result.subUnsafe(ONE.toFormat(result.format));\n        }\n\n        return result;\n    }\n\n    ceiling(): FixedNumber {\n        const comps = this.toString().split(\".\");\n        if (comps.length === 1) { comps.push(\"0\"); }\n\n        let result = FixedNumber.from(comps[0], this.format);\n\n        const hasFraction = !comps[1].match(/^(0*)$/);\n        if (!this.isNegative() && hasFraction) {\n            result = result.addUnsafe(ONE.toFormat(result.format));\n        }\n\n        return result;\n    }\n\n    // @TODO: Support other rounding algorithms\n    round(decimals?: number): FixedNumber {\n        if (decimals == null) { decimals = 0; }\n\n        // If we are already in range, we're done\n        const comps = this.toString().split(\".\");\n        if (comps.length === 1) { comps.push(\"0\"); }\n\n        if (decimals < 0 || decimals > 80 || (decimals % 1)) {\n            logger.throwArgumentError(\"invalid decimal count\", \"decimals\", decimals);\n        }\n\n        if (comps[1].length <= decimals) { return this; }\n\n        const factor = FixedNumber.from(\"1\" + zeros.substring(0, decimals), this.format);\n        const bump = BUMP.toFormat(this.format);\n\n        return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);\n    }\n\n    isZero(): boolean {\n        return (this._value === \"0.0\" || this._value === \"0\");\n    }\n\n    isNegative(): boolean {\n        return (this._value[0] === \"-\");\n    }\n\n    toString(): string { return this._value; }\n\n    toHexString(width?: number): string {\n        if (width == null) { return this._hex; }\n        if (width % 8) { logger.throwArgumentError(\"invalid byte width\", \"width\", width); }\n        const hex = BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();\n        return hexZeroPad(hex, width / 8);\n    }\n\n    toUnsafeFloat(): number { return parseFloat(this.toString()); }\n\n    toFormat(format: FixedFormat | string): FixedNumber {\n        return FixedNumber.fromString(this._value, format);\n    }\n\n\n    static fromValue(value: BigNumber, decimals?: BigNumberish, format?: FixedFormat | string | number): FixedNumber {\n        // If decimals looks more like a format, and there is no format, shift the parameters\n        if (format == null && decimals != null && !isBigNumberish(decimals)) {\n            format = decimals;\n            decimals = null;\n        }\n\n        if (decimals == null) { decimals = 0; }\n        if (format == null) { format = \"fixed\"; }\n\n        return FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format));\n    }\n\n\n    static fromString(value: string, format?: FixedFormat | string | number): FixedNumber {\n        if (format == null) { format = \"fixed\"; }\n\n        const fixedFormat = FixedFormat.from(format);\n\n        const numeric = parseFixed(value, fixedFormat.decimals);\n\n        if (!fixedFormat.signed && numeric.lt(Zero)) {\n            throwFault(\"unsigned value cannot be negative\", \"overflow\", \"value\", value);\n        }\n\n        let hex: string = null;\n        if (fixedFormat.signed) {\n            hex = numeric.toTwos(fixedFormat.width).toHexString();\n        } else {\n            hex = numeric.toHexString();\n            hex = hexZeroPad(hex, fixedFormat.width / 8);\n        }\n\n        const decimal = formatFixed(numeric, fixedFormat.decimals);\n\n        return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);\n    }\n\n    static fromBytes(value: BytesLike, format?: FixedFormat | string | number): FixedNumber {\n        if (format == null) { format = \"fixed\"; }\n\n        const fixedFormat = FixedFormat.from(format);\n\n        if (arrayify(value).length > fixedFormat.width / 8) {\n            throw new Error(\"overflow\");\n        }\n\n        let numeric = BigNumber.from(value);\n        if (fixedFormat.signed) { numeric = numeric.fromTwos(fixedFormat.width); }\n\n        const hex = numeric.toTwos((fixedFormat.signed ? 0: 1) + fixedFormat.width).toHexString();\n        const decimal = formatFixed(numeric, fixedFormat.decimals);\n\n        return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);\n    }\n\n    static from(value: any, format?: FixedFormat | string | number) {\n        if (typeof(value) === \"string\") {\n            return FixedNumber.fromString(value, format);\n        }\n\n        if (isBytes(value)) {\n            return FixedNumber.fromBytes(value, format);\n        }\n\n        try {\n            return FixedNumber.fromValue(value, 0, format);\n        } catch (error) {\n            // Allow NUMERIC_FAULT to bubble up\n            if (error.code !== Logger.errors.INVALID_ARGUMENT) {\n                throw error;\n            }\n        }\n\n        return logger.throwArgumentError(\"invalid FixedNumber value\", \"value\", value);\n    }\n\n    static isFixedNumber(value: any): value is FixedNumber {\n        return !!(value && value._isFixedNumber);\n    }\n}\n\nconst ONE = FixedNumber.from(1);\nconst BUMP = FixedNumber.from(\"0.5\");\n"]},"metadata":{},"sourceType":"module"}