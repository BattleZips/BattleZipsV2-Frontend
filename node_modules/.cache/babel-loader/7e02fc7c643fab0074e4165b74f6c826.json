{"ast":null,"code":"\"use strict\";\n\nimport { Coder } from \"./abstract-coder\";\nimport { pack, unpack } from \"./array\";\nexport class TupleCoder extends Coder {\n  constructor(coders, localName) {\n    let dynamic = false;\n    const types = [];\n    coders.forEach(coder => {\n      if (coder.dynamic) {\n        dynamic = true;\n      }\n\n      types.push(coder.type);\n    });\n    const type = \"tuple(\" + types.join(\",\") + \")\";\n    super(\"tuple\", type, localName, dynamic);\n    this.coders = coders;\n  }\n\n  defaultValue() {\n    const values = [];\n    this.coders.forEach(coder => {\n      values.push(coder.defaultValue());\n    }); // We only output named properties for uniquely named coders\n\n    const uniqueNames = this.coders.reduce((accum, coder) => {\n      const name = coder.localName;\n\n      if (name) {\n        if (!accum[name]) {\n          accum[name] = 0;\n        }\n\n        accum[name]++;\n      }\n\n      return accum;\n    }, {}); // Add named values\n\n    this.coders.forEach((coder, index) => {\n      let name = coder.localName;\n\n      if (!name || uniqueNames[name] !== 1) {\n        return;\n      }\n\n      if (name === \"length\") {\n        name = \"_length\";\n      }\n\n      if (values[name] != null) {\n        return;\n      }\n\n      values[name] = values[index];\n    });\n    return Object.freeze(values);\n  }\n\n  encode(writer, value) {\n    return pack(writer, this.coders, value);\n  }\n\n  decode(reader) {\n    return reader.coerce(this.name, unpack(reader, this.coders));\n  }\n\n}","map":{"version":3,"mappings":"AAAA;;AAEA,SAASA,KAAT,QAAsC,kBAAtC;AACA,SAASC,IAAT,EAAeC,MAAf,QAA6B,SAA7B;AAEA,OAAM,MAAOC,UAAP,SAA0BH,KAA1B,CAA+B;AAGjCI,cAAYC,MAAZ,EAAkCC,SAAlC,EAAmD;AAC/C,QAAIC,OAAO,GAAG,KAAd;AACA,UAAMC,KAAK,GAAkB,EAA7B;AACAH,UAAM,CAACI,OAAP,CAAgBC,KAAD,IAAU;AACrB,UAAIA,KAAK,CAACH,OAAV,EAAmB;AAAEA,eAAO,GAAG,IAAV;AAAiB;;AACtCC,WAAK,CAACG,IAAN,CAAWD,KAAK,CAACE,IAAjB;AACH,KAHD;AAIA,UAAMA,IAAI,GAAI,WAAWJ,KAAK,CAACK,IAAN,CAAW,GAAX,CAAX,GAA6B,GAA3C;AAEA,UAAM,OAAN,EAAeD,IAAf,EAAqBN,SAArB,EAAgCC,OAAhC;AACA,SAAKF,MAAL,GAAcA,MAAd;AACH;;AAEDS,cAAY;AACR,UAAMC,MAAM,GAAQ,EAApB;AACA,SAAKV,MAAL,CAAYI,OAAZ,CAAqBC,KAAD,IAAU;AAC1BK,YAAM,CAACJ,IAAP,CAAYD,KAAK,CAACI,YAAN,EAAZ;AACH,KAFD,EAFQ,CAMR;;AACA,UAAME,WAAW,GAAG,KAAKX,MAAL,CAAYY,MAAZ,CAAmB,CAACC,KAAD,EAAQR,KAAR,KAAiB;AACpD,YAAMS,IAAI,GAAGT,KAAK,CAACJ,SAAnB;;AACA,UAAIa,IAAJ,EAAU;AACN,YAAI,CAACD,KAAK,CAACC,IAAD,CAAV,EAAkB;AAAED,eAAK,CAACC,IAAD,CAAL,GAAc,CAAd;AAAkB;;AACtCD,aAAK,CAACC,IAAD,CAAL;AACH;;AACD,aAAOD,KAAP;AACH,KAPmB,EAOa,EAPb,CAApB,CAPQ,CAgBR;;AACA,SAAKb,MAAL,CAAYI,OAAZ,CAAoB,CAACC,KAAD,EAAeU,KAAf,KAAgC;AAChD,UAAID,IAAI,GAAGT,KAAK,CAACJ,SAAjB;;AACA,UAAI,CAACa,IAAD,IAASH,WAAW,CAACG,IAAD,CAAX,KAAsB,CAAnC,EAAsC;AAAE;AAAS;;AAEjD,UAAIA,IAAI,KAAK,QAAb,EAAuB;AAAEA,YAAI,GAAG,SAAP;AAAmB;;AAE5C,UAAIJ,MAAM,CAACI,IAAD,CAAN,IAAgB,IAApB,EAA0B;AAAE;AAAS;;AAErCJ,YAAM,CAACI,IAAD,CAAN,GAAeJ,MAAM,CAACK,KAAD,CAArB;AACH,KATD;AAWA,WAAOC,MAAM,CAACC,MAAP,CAAcP,MAAd,CAAP;AACH;;AAEDQ,QAAM,CAACC,MAAD,EAAiBC,KAAjB,EAA8D;AAChE,WAAOxB,IAAI,CAACuB,MAAD,EAAS,KAAKnB,MAAd,EAAsBoB,KAAtB,CAAX;AACH;;AAEDC,QAAM,CAACC,MAAD,EAAe;AACjB,WAAOA,MAAM,CAACC,MAAP,CAAc,KAAKT,IAAnB,EAAyBjB,MAAM,CAACyB,MAAD,EAAS,KAAKtB,MAAd,CAA/B,CAAP;AACH;;AArDgC","names":["Coder","pack","unpack","TupleCoder","constructor","coders","localName","dynamic","types","forEach","coder","push","type","join","defaultValue","values","uniqueNames","reduce","accum","name","index","Object","freeze","encode","writer","value","decode","reader","coerce"],"sources":["/Users/ianbrighton/Documents/Mach 34/BattleZipsV2/BattleZipsV2-Frontend/node_modules/@ethersproject/abi/src.ts/coders/tuple.ts"],"sourcesContent":["\"use strict\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\nimport { pack, unpack } from \"./array\";\n\nexport class TupleCoder extends Coder {\n    readonly coders: Array<Coder>;\n\n    constructor(coders: Array<Coder>, localName: string) {\n        let dynamic = false;\n        const types: Array<string> = [];\n        coders.forEach((coder) => {\n            if (coder.dynamic) { dynamic = true; }\n            types.push(coder.type);\n        });\n        const type = (\"tuple(\" + types.join(\",\") + \")\");\n\n        super(\"tuple\", type, localName, dynamic);\n        this.coders = coders;\n    }\n\n    defaultValue(): any {\n        const values: any = [ ];\n        this.coders.forEach((coder) => {\n            values.push(coder.defaultValue());\n        });\n\n        // We only output named properties for uniquely named coders\n        const uniqueNames = this.coders.reduce((accum, coder) => {\n            const name = coder.localName;\n            if (name) {\n                if (!accum[name]) { accum[name] = 0; }\n                accum[name]++;\n            }\n            return accum;\n        }, <{ [ name: string ]: number }>{ });\n\n        // Add named values\n        this.coders.forEach((coder: Coder, index: number) => {\n            let name = coder.localName;\n            if (!name || uniqueNames[name] !== 1) { return; }\n\n            if (name === \"length\") { name = \"_length\"; }\n\n            if (values[name] != null) { return; }\n\n            values[name] = values[index];\n        });\n\n        return Object.freeze(values);\n    }\n\n    encode(writer: Writer, value: Array<any> | { [ name: string ]: any }): number {\n        return pack(writer, this.coders, value);\n    }\n\n    decode(reader: Reader): any {\n        return reader.coerce(this.name, unpack(reader, this.coders));\n    }\n}\n\n"]},"metadata":{},"sourceType":"module"}