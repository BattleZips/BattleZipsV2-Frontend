{"ast":null,"code":"\"use strict\";\n\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { arrayify, concat, hexlify, zeroPad } from \"@ethersproject/bytes\";\nimport { keccak256 as hashKeccak256 } from \"@ethersproject/keccak256\";\nimport { sha256 as hashSha256 } from \"@ethersproject/sha2\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\nconst regexBytes = new RegExp(\"^bytes([0-9]+)$\");\nconst regexNumber = new RegExp(\"^(u?int)([0-9]*)$\");\nconst regexArray = new RegExp(\"^(.*)\\\\[([0-9]*)\\\\]$\");\nconst Zeros = \"0000000000000000000000000000000000000000000000000000000000000000\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction _pack(type, value, isArray) {\n  switch (type) {\n    case \"address\":\n      if (isArray) {\n        return zeroPad(value, 32);\n      }\n\n      return arrayify(value);\n\n    case \"string\":\n      return toUtf8Bytes(value);\n\n    case \"bytes\":\n      return arrayify(value);\n\n    case \"bool\":\n      value = value ? \"0x01\" : \"0x00\";\n\n      if (isArray) {\n        return zeroPad(value, 32);\n      }\n\n      return arrayify(value);\n  }\n\n  let match = type.match(regexNumber);\n\n  if (match) {\n    //let signed = (match[1] === \"int\")\n    let size = parseInt(match[2] || \"256\");\n\n    if (match[2] && String(size) !== match[2] || size % 8 !== 0 || size === 0 || size > 256) {\n      logger.throwArgumentError(\"invalid number type\", \"type\", type);\n    }\n\n    if (isArray) {\n      size = 256;\n    }\n\n    value = BigNumber.from(value).toTwos(size);\n    return zeroPad(value, size / 8);\n  }\n\n  match = type.match(regexBytes);\n\n  if (match) {\n    const size = parseInt(match[1]);\n\n    if (String(size) !== match[1] || size === 0 || size > 32) {\n      logger.throwArgumentError(\"invalid bytes type\", \"type\", type);\n    }\n\n    if (arrayify(value).byteLength !== size) {\n      logger.throwArgumentError(`invalid value for ${type}`, \"value\", value);\n    }\n\n    if (isArray) {\n      return arrayify((value + Zeros).substring(0, 66));\n    }\n\n    return value;\n  }\n\n  match = type.match(regexArray);\n\n  if (match && Array.isArray(value)) {\n    const baseType = match[1];\n    const count = parseInt(match[2] || String(value.length));\n\n    if (count != value.length) {\n      logger.throwArgumentError(`invalid array length for ${type}`, \"value\", value);\n    }\n\n    const result = [];\n    value.forEach(function (value) {\n      result.push(_pack(baseType, value, true));\n    });\n    return concat(result);\n  }\n\n  return logger.throwArgumentError(\"invalid type\", \"type\", type);\n} // @TODO: Array Enum\n\n\nexport function pack(types, values) {\n  if (types.length != values.length) {\n    logger.throwArgumentError(\"wrong number of values; expected ${ types.length }\", \"values\", values);\n  }\n\n  const tight = [];\n  types.forEach(function (type, index) {\n    tight.push(_pack(type, values[index]));\n  });\n  return hexlify(concat(tight));\n}\nexport function keccak256(types, values) {\n  return hashKeccak256(pack(types, values));\n}\nexport function sha256(types, values) {\n  return hashSha256(pack(types, values));\n}","map":{"version":3,"mappings":"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","names":["BigNumber","arrayify","concat","hexlify","zeroPad","keccak256","hashKeccak256","sha256","hashSha256","toUtf8Bytes","regexBytes","RegExp","regexNumber","regexArray","Zeros","Logger","version","logger","_pack","type","value","isArray","match","size","parseInt","String","throwArgumentError","from","toTwos","byteLength","substring","Array","baseType","count","length","result","forEach","push","pack","types","values","tight","index"],"sources":["/Users/ianbrighton/Documents/Mach 34/BattleZipsV2/BattleZipsV2-Frontend/node_modules/@ethersproject/solidity/src.ts/index.ts"],"sourcesContent":["\"use strict\";\n\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { arrayify, concat, hexlify, zeroPad } from \"@ethersproject/bytes\";\nimport { keccak256 as hashKeccak256 } from \"@ethersproject/keccak256\";\nimport { sha256 as hashSha256 } from \"@ethersproject/sha2\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\n\nconst regexBytes = new RegExp(\"^bytes([0-9]+)$\");\nconst regexNumber = new RegExp(\"^(u?int)([0-9]*)$\");\nconst regexArray = new RegExp(\"^(.*)\\\\[([0-9]*)\\\\]$\");\n\nconst Zeros = \"0000000000000000000000000000000000000000000000000000000000000000\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n\nfunction _pack(type: string, value: any, isArray?: boolean): Uint8Array {\n    switch(type) {\n        case \"address\":\n            if (isArray) { return zeroPad(value, 32); }\n            return arrayify(value);\n        case \"string\":\n            return toUtf8Bytes(value);\n        case \"bytes\":\n            return arrayify(value);\n        case \"bool\":\n            value = (value ? \"0x01\": \"0x00\");\n            if (isArray) { return zeroPad(value, 32); }\n            return arrayify(value);\n    }\n\n    let match =  type.match(regexNumber);\n    if (match) {\n        //let signed = (match[1] === \"int\")\n        let size = parseInt(match[2] || \"256\")\n\n        if ((match[2] && String(size) !== match[2]) || (size % 8 !== 0) || size === 0 || size > 256) {\n            logger.throwArgumentError(\"invalid number type\", \"type\", type)\n        }\n\n        if (isArray) { size = 256; }\n\n        value = BigNumber.from(value).toTwos(size);\n\n        return zeroPad(value, size / 8);\n    }\n\n    match = type.match(regexBytes);\n    if (match) {\n        const size = parseInt(match[1]);\n\n        if (String(size) !== match[1] || size === 0 || size > 32) {\n            logger.throwArgumentError(\"invalid bytes type\", \"type\", type)\n        }\n        if (arrayify(value).byteLength !== size) {\n            logger.throwArgumentError(`invalid value for ${ type }`, \"value\", value)\n        }\n        if (isArray) { return arrayify((value + Zeros).substring(0, 66)); }\n        return value;\n    }\n\n    match = type.match(regexArray);\n    if (match && Array.isArray(value)) {\n        const baseType = match[1];\n        const count = parseInt(match[2] || String(value.length));\n        if (count != value.length) {\n            logger.throwArgumentError(`invalid array length for ${ type }`, \"value\", value)\n        }\n        const result: Array<Uint8Array> = [];\n        value.forEach(function(value) {\n            result.push(_pack(baseType, value, true));\n        });\n        return concat(result);\n    }\n\n    return logger.throwArgumentError(\"invalid type\", \"type\", type)\n}\n\n// @TODO: Array Enum\n\nexport function pack(types: ReadonlyArray<string>, values: ReadonlyArray<any>) {\n    if (types.length != values.length) {\n        logger.throwArgumentError(\"wrong number of values; expected ${ types.length }\", \"values\", values)\n    }\n    const tight: Array<Uint8Array> = [];\n    types.forEach(function(type, index) {\n        tight.push(_pack(type, values[index]));\n    });\n    return hexlify(concat(tight));\n}\n\nexport function keccak256(types: ReadonlyArray<string>, values: ReadonlyArray<any>) {\n    return hashKeccak256(pack(types, values));\n}\n\nexport function sha256(types: ReadonlyArray<string>, values: ReadonlyArray<any>) {\n    return hashSha256(pack(types, values));\n}\n"]},"metadata":{},"sourceType":"module"}