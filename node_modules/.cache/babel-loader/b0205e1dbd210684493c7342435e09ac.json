{"ast":null,"code":"import { Connector, __privateAdd, __privateGet, __privateSet, __publicField } from \"./chunk-5NCTPR6C.js\"; // src/injected.ts\n\nimport { AddChainError, ChainNotConfiguredError, ConnectorNotFoundError, ResourceUnavailableError, SwitchChainError, UserRejectedRequestError, getClient, normalizeChainId } from \"@wagmi/core\";\nimport { providers } from \"ethers\";\nimport { getAddress, hexValue } from \"ethers/lib/utils.js\"; // src/utils/getInjectedName.ts\n\nfunction getInjectedName(ethereum) {\n  if (!ethereum) return \"Injected\";\n\n  const getName = provider => {\n    if (provider.isAvalanche) return \"Core Wallet\";\n    if (provider.isBitKeep) return \"BitKeep\";\n    if (provider.isBraveWallet) return \"Brave Wallet\";\n    if (provider.isCoinbaseWallet) return \"Coinbase Wallet\";\n    if (provider.isExodus) return \"Exodus\";\n    if (provider.isFrame) return \"Frame\";\n    if (provider.isKuCoinWallet) return \"KuCoin Wallet\";\n    if (provider.isMathWallet) return \"MathWallet\";\n    if (provider.isOneInchIOSWallet || provider.isOneInchAndroidWallet) return \"1inch Wallet\";\n    if (provider.isOpera) return \"Opera\";\n    if (provider.isPortal) return \"Ripio Portal\";\n    if (provider.isRainbow) return \"Rainbow\";\n    if (provider.isTally) return \"Tally\";\n    if (provider.isTokenPocket) return \"TokenPocket\";\n    if (provider.isTokenary) return \"Tokenary\";\n    if (provider.isTrust || provider.isTrustWallet) return \"Trust Wallet\";\n    if (provider.isMetaMask) return \"MetaMask\";\n  };\n\n  if (ethereum.providers?.length) {\n    const nameSet = /* @__PURE__ */new Set();\n    let unknownCount = 1;\n\n    for (const provider of ethereum.providers) {\n      let name = getName(provider);\n\n      if (!name) {\n        name = `Unknown Wallet #${unknownCount}`;\n        unknownCount += 1;\n      }\n\n      nameSet.add(name);\n    }\n\n    const names = [...nameSet];\n    if (names.length) return names;\n    return names[0] ?? \"Injected\";\n  }\n\n  return getName(ethereum) ?? \"Injected\";\n} // src/injected.ts\n\n\nvar _provider, _switchingChains;\n\nvar InjectedConnector = class extends Connector {\n  constructor() {\n    let {\n      chains,\n      options: options_\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const options = {\n      shimDisconnect: true,\n      shimChainChangedDisconnect: true,\n      getProvider: () => typeof window !== \"undefined\" ? window.ethereum : void 0,\n      ...options_\n    };\n    super({\n      chains,\n      options\n    });\n\n    __publicField(this, \"id\");\n\n    __publicField(this, \"name\");\n\n    __publicField(this, \"ready\");\n\n    __privateAdd(this, _provider, void 0);\n\n    __privateAdd(this, _switchingChains, void 0);\n\n    __publicField(this, \"shimDisconnectKey\", `${this.id}.shimDisconnect`);\n\n    __publicField(this, \"onAccountsChanged\", accounts => {\n      if (accounts.length === 0) this.emit(\"disconnect\");else this.emit(\"change\", {\n        account: getAddress(accounts[0])\n      });\n    });\n\n    __publicField(this, \"onChainChanged\", chainId => {\n      const id = normalizeChainId(chainId);\n      const unsupported = this.isChainUnsupported(id);\n      this.emit(\"change\", {\n        chain: {\n          id,\n          unsupported\n        }\n      });\n    });\n\n    __publicField(this, \"onDisconnect\", () => {\n      if (this.options.shimChainChangedDisconnect && __privateGet(this, _switchingChains)) {\n        __privateSet(this, _switchingChains, false);\n\n        return;\n      }\n\n      this.emit(\"disconnect\");\n      if (this.options.shimDisconnect) getClient().storage?.removeItem(this.shimDisconnectKey);\n    });\n\n    const provider = options.getProvider();\n    if (typeof options.name === \"string\") this.name = options.name;else if (provider) {\n      const detectedName = getInjectedName(provider);\n      if (options.name) this.name = options.name(detectedName);else {\n        if (typeof detectedName === \"string\") this.name = detectedName;else this.name = detectedName[0];\n      }\n    } else this.name = \"Injected\";\n    this.id = \"injected\";\n    this.ready = !!provider;\n  }\n\n  async connect() {\n    let {\n      chainId\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    try {\n      const provider = await this.getProvider();\n      if (!provider) throw new ConnectorNotFoundError();\n\n      if (provider.on) {\n        provider.on(\"accountsChanged\", this.onAccountsChanged);\n        provider.on(\"chainChanged\", this.onChainChanged);\n        provider.on(\"disconnect\", this.onDisconnect);\n      }\n\n      this.emit(\"message\", {\n        type: \"connecting\"\n      });\n      const accounts = await provider.request({\n        method: \"eth_requestAccounts\"\n      });\n      const account = getAddress(accounts[0]);\n      let id = await this.getChainId();\n      let unsupported = this.isChainUnsupported(id);\n\n      if (chainId && id !== chainId) {\n        const chain = await this.switchChain(chainId);\n        id = chain.id;\n        unsupported = this.isChainUnsupported(id);\n      }\n\n      if (this.options.shimDisconnect) getClient().storage?.setItem(this.shimDisconnectKey, true);\n      return {\n        account,\n        chain: {\n          id,\n          unsupported\n        },\n        provider\n      };\n    } catch (error) {\n      if (this.isUserRejectedRequestError(error)) throw new UserRejectedRequestError(error);\n      if (error.code === -32002) throw new ResourceUnavailableError(error);\n      throw error;\n    }\n  }\n\n  async disconnect() {\n    const provider = await this.getProvider();\n    if (!provider?.removeListener) return;\n    provider.removeListener(\"accountsChanged\", this.onAccountsChanged);\n    provider.removeListener(\"chainChanged\", this.onChainChanged);\n    provider.removeListener(\"disconnect\", this.onDisconnect);\n    if (this.options.shimDisconnect) getClient().storage?.removeItem(this.shimDisconnectKey);\n  }\n\n  async getAccount() {\n    const provider = await this.getProvider();\n    if (!provider) throw new ConnectorNotFoundError();\n    const accounts = await provider.request({\n      method: \"eth_accounts\"\n    });\n    return getAddress(accounts[0]);\n  }\n\n  async getChainId() {\n    const provider = await this.getProvider();\n    if (!provider) throw new ConnectorNotFoundError();\n    return provider.request({\n      method: \"eth_chainId\"\n    }).then(normalizeChainId);\n  }\n\n  async getProvider() {\n    const provider = this.options.getProvider();\n    if (provider) __privateSet(this, _provider, provider);\n    return __privateGet(this, _provider);\n  }\n\n  async getSigner() {\n    let {\n      chainId\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const [provider, account] = await Promise.all([this.getProvider(), this.getAccount()]);\n    return new providers.Web3Provider(provider, chainId).getSigner(account);\n  }\n\n  async isAuthorized() {\n    try {\n      if (this.options.shimDisconnect && !getClient().storage?.getItem(this.shimDisconnectKey)) return false;\n      const provider = await this.getProvider();\n      if (!provider) throw new ConnectorNotFoundError();\n      const account = await this.getAccount();\n      return !!account;\n    } catch {\n      return false;\n    }\n  }\n\n  async switchChain(chainId) {\n    if (this.options.shimChainChangedDisconnect) __privateSet(this, _switchingChains, true);\n    const provider = await this.getProvider();\n    if (!provider) throw new ConnectorNotFoundError();\n    const id = hexValue(chainId);\n\n    try {\n      await Promise.all([provider.request({\n        method: \"wallet_switchEthereumChain\",\n        params: [{\n          chainId: id\n        }]\n      }), new Promise(res => this.on(\"change\", _ref => {\n        let {\n          chain\n        } = _ref;\n        if (chain?.id === chainId) res();\n      }))]);\n      return this.chains.find(x => x.id === chainId) ?? {\n        id: chainId,\n        name: `Chain ${id}`,\n        network: `${id}`,\n        nativeCurrency: {\n          name: \"Ether\",\n          decimals: 18,\n          symbol: \"ETH\"\n        },\n        rpcUrls: {\n          default: {\n            http: [\"\"]\n          },\n          public: {\n            http: [\"\"]\n          }\n        }\n      };\n    } catch (error) {\n      const chain = this.chains.find(x => x.id === chainId);\n      if (!chain) throw new ChainNotConfiguredError({\n        chainId,\n        connectorId: this.id\n      });\n\n      if (error.code === 4902 || error?.data?.originalError?.code === 4902) {\n        try {\n          await provider.request({\n            method: \"wallet_addEthereumChain\",\n            params: [{\n              chainId: id,\n              chainName: chain.name,\n              nativeCurrency: chain.nativeCurrency,\n              rpcUrls: [chain.rpcUrls.public?.http[0] ?? \"\"],\n              blockExplorerUrls: this.getBlockExplorerUrls(chain)\n            }]\n          });\n          return chain;\n        } catch (addError) {\n          if (this.isUserRejectedRequestError(addError)) throw new UserRejectedRequestError(error);\n          throw new AddChainError();\n        }\n      }\n\n      if (this.isUserRejectedRequestError(error)) throw new UserRejectedRequestError(error);\n      throw new SwitchChainError(error);\n    }\n  }\n\n  async watchAsset(_ref2) {\n    let {\n      address,\n      decimals = 18,\n      image,\n      symbol\n    } = _ref2;\n    const provider = await this.getProvider();\n    if (!provider) throw new ConnectorNotFoundError();\n    return provider.request({\n      method: \"wallet_watchAsset\",\n      params: {\n        type: \"ERC20\",\n        options: {\n          address,\n          decimals,\n          image,\n          symbol\n        }\n      }\n    });\n  }\n\n  isUserRejectedRequestError(error) {\n    return error.code === 4001;\n  }\n\n};\n_provider = new WeakMap();\n_switchingChains = new WeakMap();\nexport { InjectedConnector };","map":{"version":3,"sources":["/Users/ianbrighton/Documents/Mach 34/BattleZipsV2/BattleZipsV2-Frontend/node_modules/@wagmi/connectors/dist/chunk-6IU3YKWQ.js"],"names":["Connector","__privateAdd","__privateGet","__privateSet","__publicField","AddChainError","ChainNotConfiguredError","ConnectorNotFoundError","ResourceUnavailableError","SwitchChainError","UserRejectedRequestError","getClient","normalizeChainId","providers","getAddress","hexValue","getInjectedName","ethereum","getName","provider","isAvalanche","isBitKeep","isBraveWallet","isCoinbaseWallet","isExodus","isFrame","isKuCoinWallet","isMathWallet","isOneInchIOSWallet","isOneInchAndroidWallet","isOpera","isPortal","isRainbow","isTally","isTokenPocket","isTokenary","isTrust","isTrustWallet","isMetaMask","length","nameSet","Set","unknownCount","name","add","names","_provider","_switchingChains","InjectedConnector","constructor","chains","options","options_","shimDisconnect","shimChainChangedDisconnect","getProvider","window","id","accounts","emit","account","chainId","unsupported","isChainUnsupported","chain","storage","removeItem","shimDisconnectKey","detectedName","ready","connect","on","onAccountsChanged","onChainChanged","onDisconnect","type","request","method","getChainId","switchChain","setItem","error","isUserRejectedRequestError","code","disconnect","removeListener","getAccount","then","getSigner","Promise","all","Web3Provider","isAuthorized","getItem","params","res","find","x","network","nativeCurrency","decimals","symbol","rpcUrls","default","http","public","connectorId","data","originalError","chainName","blockExplorerUrls","getBlockExplorerUrls","addError","watchAsset","address","image","WeakMap"],"mappings":"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","sourcesContent":["import {\n  Connector,\n  __privateAdd,\n  __privateGet,\n  __privateSet,\n  __publicField\n} from \"./chunk-5NCTPR6C.js\";\n\n// src/injected.ts\nimport {\n  AddChainError,\n  ChainNotConfiguredError,\n  ConnectorNotFoundError,\n  ResourceUnavailableError,\n  SwitchChainError,\n  UserRejectedRequestError,\n  getClient,\n  normalizeChainId\n} from \"@wagmi/core\";\nimport { providers } from \"ethers\";\nimport { getAddress, hexValue } from \"ethers/lib/utils.js\";\n\n// src/utils/getInjectedName.ts\nfunction getInjectedName(ethereum) {\n  if (!ethereum)\n    return \"Injected\";\n  const getName = (provider) => {\n    if (provider.isAvalanche)\n      return \"Core Wallet\";\n    if (provider.isBitKeep)\n      return \"BitKeep\";\n    if (provider.isBraveWallet)\n      return \"Brave Wallet\";\n    if (provider.isCoinbaseWallet)\n      return \"Coinbase Wallet\";\n    if (provider.isExodus)\n      return \"Exodus\";\n    if (provider.isFrame)\n      return \"Frame\";\n    if (provider.isKuCoinWallet)\n      return \"KuCoin Wallet\";\n    if (provider.isMathWallet)\n      return \"MathWallet\";\n    if (provider.isOneInchIOSWallet || provider.isOneInchAndroidWallet)\n      return \"1inch Wallet\";\n    if (provider.isOpera)\n      return \"Opera\";\n    if (provider.isPortal)\n      return \"Ripio Portal\";\n    if (provider.isRainbow)\n      return \"Rainbow\";\n    if (provider.isTally)\n      return \"Tally\";\n    if (provider.isTokenPocket)\n      return \"TokenPocket\";\n    if (provider.isTokenary)\n      return \"Tokenary\";\n    if (provider.isTrust || provider.isTrustWallet)\n      return \"Trust Wallet\";\n    if (provider.isMetaMask)\n      return \"MetaMask\";\n  };\n  if (ethereum.providers?.length) {\n    const nameSet = /* @__PURE__ */ new Set();\n    let unknownCount = 1;\n    for (const provider of ethereum.providers) {\n      let name = getName(provider);\n      if (!name) {\n        name = `Unknown Wallet #${unknownCount}`;\n        unknownCount += 1;\n      }\n      nameSet.add(name);\n    }\n    const names = [...nameSet];\n    if (names.length)\n      return names;\n    return names[0] ?? \"Injected\";\n  }\n  return getName(ethereum) ?? \"Injected\";\n}\n\n// src/injected.ts\nvar _provider, _switchingChains;\nvar InjectedConnector = class extends Connector {\n  constructor({\n    chains,\n    options: options_\n  } = {}) {\n    const options = {\n      shimDisconnect: true,\n      shimChainChangedDisconnect: true,\n      getProvider: () => typeof window !== \"undefined\" ? window.ethereum : void 0,\n      ...options_\n    };\n    super({ chains, options });\n    __publicField(this, \"id\");\n    __publicField(this, \"name\");\n    __publicField(this, \"ready\");\n    __privateAdd(this, _provider, void 0);\n    __privateAdd(this, _switchingChains, void 0);\n    __publicField(this, \"shimDisconnectKey\", `${this.id}.shimDisconnect`);\n    __publicField(this, \"onAccountsChanged\", (accounts) => {\n      if (accounts.length === 0)\n        this.emit(\"disconnect\");\n      else\n        this.emit(\"change\", {\n          account: getAddress(accounts[0])\n        });\n    });\n    __publicField(this, \"onChainChanged\", (chainId) => {\n      const id = normalizeChainId(chainId);\n      const unsupported = this.isChainUnsupported(id);\n      this.emit(\"change\", { chain: { id, unsupported } });\n    });\n    __publicField(this, \"onDisconnect\", () => {\n      if (this.options.shimChainChangedDisconnect && __privateGet(this, _switchingChains)) {\n        __privateSet(this, _switchingChains, false);\n        return;\n      }\n      this.emit(\"disconnect\");\n      if (this.options.shimDisconnect)\n        getClient().storage?.removeItem(this.shimDisconnectKey);\n    });\n    const provider = options.getProvider();\n    if (typeof options.name === \"string\")\n      this.name = options.name;\n    else if (provider) {\n      const detectedName = getInjectedName(provider);\n      if (options.name)\n        this.name = options.name(detectedName);\n      else {\n        if (typeof detectedName === \"string\")\n          this.name = detectedName;\n        else\n          this.name = detectedName[0];\n      }\n    } else\n      this.name = \"Injected\";\n    this.id = \"injected\";\n    this.ready = !!provider;\n  }\n  async connect({ chainId } = {}) {\n    try {\n      const provider = await this.getProvider();\n      if (!provider)\n        throw new ConnectorNotFoundError();\n      if (provider.on) {\n        provider.on(\"accountsChanged\", this.onAccountsChanged);\n        provider.on(\"chainChanged\", this.onChainChanged);\n        provider.on(\"disconnect\", this.onDisconnect);\n      }\n      this.emit(\"message\", { type: \"connecting\" });\n      const accounts = await provider.request({\n        method: \"eth_requestAccounts\"\n      });\n      const account = getAddress(accounts[0]);\n      let id = await this.getChainId();\n      let unsupported = this.isChainUnsupported(id);\n      if (chainId && id !== chainId) {\n        const chain = await this.switchChain(chainId);\n        id = chain.id;\n        unsupported = this.isChainUnsupported(id);\n      }\n      if (this.options.shimDisconnect)\n        getClient().storage?.setItem(this.shimDisconnectKey, true);\n      return { account, chain: { id, unsupported }, provider };\n    } catch (error) {\n      if (this.isUserRejectedRequestError(error))\n        throw new UserRejectedRequestError(error);\n      if (error.code === -32002)\n        throw new ResourceUnavailableError(error);\n      throw error;\n    }\n  }\n  async disconnect() {\n    const provider = await this.getProvider();\n    if (!provider?.removeListener)\n      return;\n    provider.removeListener(\"accountsChanged\", this.onAccountsChanged);\n    provider.removeListener(\"chainChanged\", this.onChainChanged);\n    provider.removeListener(\"disconnect\", this.onDisconnect);\n    if (this.options.shimDisconnect)\n      getClient().storage?.removeItem(this.shimDisconnectKey);\n  }\n  async getAccount() {\n    const provider = await this.getProvider();\n    if (!provider)\n      throw new ConnectorNotFoundError();\n    const accounts = await provider.request({\n      method: \"eth_accounts\"\n    });\n    return getAddress(accounts[0]);\n  }\n  async getChainId() {\n    const provider = await this.getProvider();\n    if (!provider)\n      throw new ConnectorNotFoundError();\n    return provider.request({ method: \"eth_chainId\" }).then(normalizeChainId);\n  }\n  async getProvider() {\n    const provider = this.options.getProvider();\n    if (provider)\n      __privateSet(this, _provider, provider);\n    return __privateGet(this, _provider);\n  }\n  async getSigner({ chainId } = {}) {\n    const [provider, account] = await Promise.all([\n      this.getProvider(),\n      this.getAccount()\n    ]);\n    return new providers.Web3Provider(\n      provider,\n      chainId\n    ).getSigner(account);\n  }\n  async isAuthorized() {\n    try {\n      if (this.options.shimDisconnect && !getClient().storage?.getItem(this.shimDisconnectKey))\n        return false;\n      const provider = await this.getProvider();\n      if (!provider)\n        throw new ConnectorNotFoundError();\n      const account = await this.getAccount();\n      return !!account;\n    } catch {\n      return false;\n    }\n  }\n  async switchChain(chainId) {\n    if (this.options.shimChainChangedDisconnect)\n      __privateSet(this, _switchingChains, true);\n    const provider = await this.getProvider();\n    if (!provider)\n      throw new ConnectorNotFoundError();\n    const id = hexValue(chainId);\n    try {\n      await Promise.all([\n        provider.request({\n          method: \"wallet_switchEthereumChain\",\n          params: [{ chainId: id }]\n        }),\n        new Promise(\n          (res) => this.on(\"change\", ({ chain }) => {\n            if (chain?.id === chainId)\n              res();\n          })\n        )\n      ]);\n      return this.chains.find((x) => x.id === chainId) ?? {\n        id: chainId,\n        name: `Chain ${id}`,\n        network: `${id}`,\n        nativeCurrency: { name: \"Ether\", decimals: 18, symbol: \"ETH\" },\n        rpcUrls: { default: { http: [\"\"] }, public: { http: [\"\"] } }\n      };\n    } catch (error) {\n      const chain = this.chains.find((x) => x.id === chainId);\n      if (!chain)\n        throw new ChainNotConfiguredError({ chainId, connectorId: this.id });\n      if (error.code === 4902 || error?.data?.originalError?.code === 4902) {\n        try {\n          await provider.request({\n            method: \"wallet_addEthereumChain\",\n            params: [\n              {\n                chainId: id,\n                chainName: chain.name,\n                nativeCurrency: chain.nativeCurrency,\n                rpcUrls: [chain.rpcUrls.public?.http[0] ?? \"\"],\n                blockExplorerUrls: this.getBlockExplorerUrls(chain)\n              }\n            ]\n          });\n          return chain;\n        } catch (addError) {\n          if (this.isUserRejectedRequestError(addError))\n            throw new UserRejectedRequestError(error);\n          throw new AddChainError();\n        }\n      }\n      if (this.isUserRejectedRequestError(error))\n        throw new UserRejectedRequestError(error);\n      throw new SwitchChainError(error);\n    }\n  }\n  async watchAsset({\n    address,\n    decimals = 18,\n    image,\n    symbol\n  }) {\n    const provider = await this.getProvider();\n    if (!provider)\n      throw new ConnectorNotFoundError();\n    return provider.request({\n      method: \"wallet_watchAsset\",\n      params: {\n        type: \"ERC20\",\n        options: {\n          address,\n          decimals,\n          image,\n          symbol\n        }\n      }\n    });\n  }\n  isUserRejectedRequestError(error) {\n    return error.code === 4001;\n  }\n};\n_provider = new WeakMap();\n_switchingChains = new WeakMap();\n\nexport {\n  InjectedConnector\n};\n"]},"metadata":{},"sourceType":"module"}