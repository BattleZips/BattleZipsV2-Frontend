{"ast":null,"code":"import { deepCopy } from \"@ethersproject/properties\";\nimport { fetchJson } from \"@ethersproject/web\";\nimport { JsonRpcProvider } from \"./json-rpc-provider\"; // Experimental\n\nexport class JsonRpcBatchProvider extends JsonRpcProvider {\n  send(method, params) {\n    const request = {\n      method: method,\n      params: params,\n      id: this._nextId++,\n      jsonrpc: \"2.0\"\n    };\n\n    if (this._pendingBatch == null) {\n      this._pendingBatch = [];\n    }\n\n    const inflightRequest = {\n      request,\n      resolve: null,\n      reject: null\n    };\n    const promise = new Promise((resolve, reject) => {\n      inflightRequest.resolve = resolve;\n      inflightRequest.reject = reject;\n    });\n\n    this._pendingBatch.push(inflightRequest);\n\n    if (!this._pendingBatchAggregator) {\n      // Schedule batch for next event loop + short duration\n      this._pendingBatchAggregator = setTimeout(() => {\n        // Get teh current batch and clear it, so new requests\n        // go into the next batch\n        const batch = this._pendingBatch;\n        this._pendingBatch = null;\n        this._pendingBatchAggregator = null; // Get the request as an array of requests\n\n        const request = batch.map(inflight => inflight.request);\n        this.emit(\"debug\", {\n          action: \"requestBatch\",\n          request: deepCopy(request),\n          provider: this\n        });\n        return fetchJson(this.connection, JSON.stringify(request)).then(result => {\n          this.emit(\"debug\", {\n            action: \"response\",\n            request: request,\n            response: result,\n            provider: this\n          }); // For each result, feed it to the correct Promise, depending\n          // on whether it was a success or error\n\n          batch.forEach((inflightRequest, index) => {\n            const payload = result[index];\n\n            if (payload.error) {\n              const error = new Error(payload.error.message);\n              error.code = payload.error.code;\n              error.data = payload.error.data;\n              inflightRequest.reject(error);\n            } else {\n              inflightRequest.resolve(payload.result);\n            }\n          });\n        }, error => {\n          this.emit(\"debug\", {\n            action: \"response\",\n            error: error,\n            request: request,\n            provider: this\n          });\n          batch.forEach(inflightRequest => {\n            inflightRequest.reject(error);\n          });\n        });\n      }, 10);\n    }\n\n    return promise;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["deepCopy","fetchJson","JsonRpcProvider","JsonRpcBatchProvider","send","method","params","request","id","_nextId","jsonrpc","_pendingBatch","inflightRequest","resolve","reject","promise","Promise","push","_pendingBatchAggregator","setTimeout","batch","map","inflight","emit","action","provider","connection","JSON","stringify","then","result","response","forEach","index","payload","error","Error","message","code","data"],"sources":["/Users/ianbrighton/Documents/Mach 34/BattleZipsV2/BattleZipsV2-Frontend/node_modules/@ethersproject/providers/src.ts/json-rpc-batch-provider.ts"],"sourcesContent":["\nimport { deepCopy } from \"@ethersproject/properties\";\nimport { fetchJson } from \"@ethersproject/web\";\n\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\n\n// Experimental\n\nexport class JsonRpcBatchProvider extends JsonRpcProvider {\n    _pendingBatchAggregator: NodeJS.Timer;\n    _pendingBatch: Array<{\n        request: { method: string, params: Array<any>, id: number, jsonrpc: \"2.0\" },\n        resolve: (result: any) => void,\n        reject: (error: Error) => void\n    }>;\n\n    send(method: string, params: Array<any>): Promise<any> {\n        const request = {\n            method: method,\n            params: params,\n            id: (this._nextId++),\n            jsonrpc: \"2.0\"\n        };\n\n        if (this._pendingBatch == null) {\n            this._pendingBatch = [ ];\n        }\n\n        const inflightRequest: any = { request, resolve: null, reject: null };\n\n        const promise = new Promise((resolve, reject) => {\n            inflightRequest.resolve = resolve;\n            inflightRequest.reject = reject;\n        });\n\n        this._pendingBatch.push(inflightRequest);\n\n        if (!this._pendingBatchAggregator) {\n            // Schedule batch for next event loop + short duration\n            this._pendingBatchAggregator = setTimeout(() => {\n\n                // Get teh current batch and clear it, so new requests\n                // go into the next batch\n                const batch = this._pendingBatch;\n                this._pendingBatch = null;\n                this._pendingBatchAggregator = null;\n\n                // Get the request as an array of requests\n                const request = batch.map((inflight) => inflight.request);\n\n                this.emit(\"debug\", {\n                    action: \"requestBatch\",\n                    request: deepCopy(request),\n                    provider: this\n                });\n\n                return fetchJson(this.connection, JSON.stringify(request)).then((result) => {\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        request: request,\n                        response: result,\n                        provider: this\n                    });\n\n                    // For each result, feed it to the correct Promise, depending\n                    // on whether it was a success or error\n                    batch.forEach((inflightRequest, index) => {\n                        const payload = result[index];\n                        if (payload.error) {\n                            const error = new Error(payload.error.message);\n                            (<any>error).code = payload.error.code;\n                            (<any>error).data = payload.error.data;\n                            inflightRequest.reject(error);\n                        } else {\n                            inflightRequest.resolve(payload.result);\n                        }\n                    });\n\n                }, (error) => {\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        error: error,\n                        request: request,\n                        provider: this\n                    });\n\n                    batch.forEach((inflightRequest) => {\n                        inflightRequest.reject(error);\n                    });\n                });\n\n            }, 10);\n        }\n\n        return promise;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}