import m from"pino";import f from"@walletconnect/sign-client";import{getSdkError as g,isValidArray as P}from"@walletconnect/utils";import{getDefaultLoggerOptions as w}from"@walletconnect/logger";import{JsonRpcProvider as a}from"@walletconnect/jsonrpc-provider";import c,{HttpConnection as C}from"@walletconnect/jsonrpc-http-connection";import I from"events";function y(i){var t;const e=(t=i[Object.keys(i)[0]])==null?void 0:t.chains[0];return[e.split(":")[0],e.split(":")[1]]}function r(i,t){let e;return t.rpcMap&&(e=t.rpcMap[O([i])]),e}function O(i){return Number(i[0].split(":")[1])}class E{constructor(t){this.name="eip155",this.namespace=t.namespace,this.client=t.client,this.events=t.events,this.httpProviders=this.createHttpProviders(),this.chainId=this.getDefaultChainId()}async request(t){var e;switch(t.request.method){case"eth_requestAccounts":return this.getAccounts();case"eth_accounts":return this.getAccounts();case"wallet_switchEthereumChain":{const s=t.request.params?(e=t.request.params[0])==null?void 0:e.chainId:"0x0";return this.setDefaultChain(parseInt(s,16).toString()),null}case"eth_chainId":return this.getDefaultChainId()}return this.namespace.methods.includes(t.request.method)?await this.client.request(t):this.getHttpProvider().request(t.request)}updateNamespace(t){this.namespace=Object.assign(this.namespace,t)}setDefaultChain(t,e){if(this.chainId=parseInt(t),!this.httpProviders[t]){const s=e||r(`${this.name}:${t}`,this.namespace);if(!s)throw new Error(`No RPC url provided for chainId: ${t}`);this.setHttpProvider(t,s)}this.events.emit("chainChanged",this.chainId)}requestAccounts(){return this.getAccounts()}createHttpProvider(t,e){const s=e||r(t,this.namespace);return typeof s>"u"?void 0:new a(new C(s))}setHttpProvider(t,e){const s=this.createHttpProvider(t,e);s&&(this.httpProviders[t]=s)}createHttpProviders(){const t={};return this.namespace.chains.forEach(e=>{t[e]=this.createHttpProvider(e)}),t}getAccounts(){const t=this.namespace.accounts;return t?t.filter(e=>e.split(":")[1]===this.chainId.toString()).map(e=>e.split(":")[2])||[]:[]}getDefaultChainId(){if(this.chainId)return this.chainId;const t=this.namespace.chains[0];if(!t)throw new Error("ChainId not found");return parseInt(t.split(":")[1])}getHttpProvider(){const t=`${this.name}:${this.chainId}`,e=this.httpProviders[t];if(typeof e>"u")throw new Error(`JSON-RPC provider for ${t} not found`);return e}}class q{constructor(t){this.name="solana",this.namespace=t.namespace,this.events=t.events,this.client=t.client,this.chainId=this.getDefaultChainId(),this.httpProviders=this.createHttpProviders()}updateNamespace(t){this.namespace=Object.assign(this.namespace,t)}requestAccounts(){return this.getAccounts()}getAccounts(){const t=this.namespace.accounts;return t?t.filter(e=>e.split(":")[1]===this.chainId.toString()).map(e=>e.split(":")[2])||[]:[]}createHttpProviders(){const t={};return this.namespace.chains.forEach(e=>{t[e]=this.createHttpProvider(e)}),t}getDefaultChainId(){if(this.chainId)return this.chainId;const t=this.namespace.chains[0];if(!t)throw new Error("ChainId not found");return t.split(":")[1]}request(t){return this.namespace.methods.includes(t.request.method)?this.client.request(t):this.getHttpProvider().request(t.request)}getHttpProvider(){const t=`${this.name}:${this.chainId}`,e=this.httpProviders[t];if(typeof e>"u")throw new Error(`JSON-RPC provider for ${t} not found`);return e}setDefaultChain(t,e){if(this.chainId=t,!this.httpProviders[t]){const s=e||r(`${this.name}:${t}`,this.namespace);if(!s)throw new Error(`No RPC url provided for chainId: ${t}`);this.setHttpProvider(t,s)}this.events.emit("chainChanged",this.chainId)}setHttpProvider(t,e){const s=this.createHttpProvider(t,e);s&&(this.httpProviders[t]=s)}createHttpProvider(t,e){const s=e||r(t,this.namespace);return typeof s>"u"?void 0:new a(new c(s))}}class H{constructor(t){this.name="cosmos",this.namespace=t.namespace,this.events=t.events,this.client=t.client,this.chainId=this.getDefaultChainId(),this.httpProviders=this.createHttpProviders()}updateNamespace(t){this.namespace=Object.assign(this.namespace,t)}requestAccounts(){return this.getAccounts()}getAccounts(){const t=this.namespace.accounts;return t?t.filter(e=>e.split(":")[1]===this.chainId.toString()).map(e=>e.split(":")[2])||[]:[]}createHttpProviders(){const t={};return this.namespace.chains.forEach(e=>{t[e]=this.createHttpProvider(e)}),t}getDefaultChainId(){if(this.chainId)return this.chainId;const t=this.namespace.chains[0];if(!t)throw new Error("ChainId not found");return t.split(":")[1]}request(t){return this.namespace.methods.includes(t.request.method)?this.client.request(t):this.getHttpProvider().request(t.request)}getHttpProvider(){const t=`${this.name}:${this.chainId}`,e=this.httpProviders[t];if(typeof e>"u")throw new Error(`JSON-RPC provider for ${t} not found`);return e}setDefaultChain(t,e){if(this.chainId=t,!this.httpProviders[t]){const s=e||r(`${this.name}:${t}`,this.namespace);if(!s)throw new Error(`No RPC url provided for chainId: ${t}`);this.setHttpProvider(t,s)}this.events.emit("chainChanged",this.chainId)}setHttpProvider(t,e){const s=this.createHttpProvider(t,e);s&&(this.httpProviders[t]=s)}createHttpProvider(t,e){const s=e||r(t,this.namespace);return typeof s>"u"?void 0:new a(new c(s))}}class ${constructor(t){this.name="cip34",this.namespace=t.namespace,this.events=t.events,this.client=t.client,this.chainId=this.getDefaultChainId(),this.httpProviders=this.createHttpProviders()}updateNamespace(t){this.namespace=Object.assign(this.namespace,t)}requestAccounts(){return this.getAccounts()}getAccounts(){const t=this.namespace.accounts;return t?t.filter(e=>e.split(":")[1]===this.chainId.toString()).map(e=>e.split(":")[2])||[]:[]}createHttpProviders(){const t={};return this.namespace.chains.forEach(e=>{t[e]=this.createHttpProvider(e)}),t}getDefaultChainId(){if(this.chainId)return this.chainId;const t=this.namespace.chains[0];if(!t)throw new Error("ChainId not found");return t.split(":")[1]}request(t){return this.namespace.methods.includes(t.request.method)?this.client.request(t):this.getHttpProvider().request(t.request)}getHttpProvider(){const t=`${this.name}:${this.chainId}`,e=this.httpProviders[t];if(typeof e>"u")throw new Error(`JSON-RPC provider for ${t} not found`);return e}setDefaultChain(t,e){if(this.chainId=t,!this.httpProviders[t]){const s=e||r(`${this.name}:${t}`,this.namespace);if(!s)throw new Error(`No RPC url provided for chainId: ${t}`);this.setHttpProvider(t,s)}this.events.emit("chainChanged",this.chainId)}setHttpProvider(t,e){const s=this.createHttpProvider(t,e);s&&(this.httpProviders[t]=s)}createHttpProvider(t,e){const s=e||r(t,this.namespace);return typeof s>"u"?void 0:new a(new c(s))}}const h="error",b="wss://relay.walletconnect.com",S="wc",A="universal_provider",p=`${S}@${2}:${A}:`;var N=Object.defineProperty,D=Object.defineProperties,j=Object.getOwnPropertyDescriptors,d=Object.getOwnPropertySymbols,k=Object.prototype.hasOwnProperty,R=Object.prototype.propertyIsEnumerable,l=(i,t,e)=>t in i?N(i,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):i[t]=e,u=(i,t)=>{for(var e in t||(t={}))k.call(t,e)&&l(i,e,t[e]);if(d)for(var e of d(t))R.call(t,e)&&l(i,e,t[e]);return i},_=(i,t)=>D(i,j(t));class o{constructor(t){this.events=new I,this.rpcProviders={},this.providerOpts=t,this.logger=typeof t?.logger<"u"&&typeof t?.logger!="string"?t.logger:m(w({level:t?.logger||h}))}static async init(t){const e=new o(t);return await e.initialize(),e}async request(t,e){const[s,n]=this.validateChain(e);if(!this.session)throw new Error("Please call connect() before request()");return await this.getProvider(s).request({request:u({},t),chainId:`${s}:${n}`,topic:this.session.topic})}sendAsync(t,e,s){this.request(t,s).then(n=>e(null,n)).catch(n=>e(n,void 0))}async enable(){if(!this.client)throw new Error("Sign Client not initialized");return this.session||await this.connect({namespaces:this.namespaces}),await this.requestAccounts()}async disconnect(){var t;if(!this.session)throw new Error("Please call connect() before enable()");await this.client.disconnect({topic:(t=this.session)==null?void 0:t.topic,reason:g("USER_DISCONNECTED")}),await this.cleanup()}async connect(t){if(!this.client)throw new Error("Sign Client not initialized");const{namespaces:e}=t;return this.setNamespaces(e),this.createProviders(),await this.cleanupPendingPairings(),t.skipPairing===!0?void 0:await this.pair(t.pairingTopic)}on(t,e){this.events.on(t,e)}once(t,e){this.events.once(t,e)}removeListener(t,e){this.events.removeListener(t,e)}off(t,e){this.events.off(t,e)}get isWalletConnect(){return!0}async pair(t){const{uri:e,approval:s}=await this.client.connect({pairingTopic:t,requiredNamespaces:this.namespaces});return e&&(this.uri=e,this.events.emit("display_uri",e)),this.session=await s(),this.onSessionUpdate(),this.onConnect(),this.session}setDefaultChain(t,e){try{const[s,n]=this.validateChain(t);this.getProvider(s).setDefaultChain(n,e)}catch(s){if(!/Please call connect/.test(s.message))throw s}}async cleanupPendingPairings(t={}){this.logger.info("Cleaning up inactive pairings...");const e=this.client.pairing.getAll();if(P(e)){for(const s of e)t.deletePairings?this.client.core.expirer.set(s.topic,0):await this.client.core.relayer.subscriber.unsubscribe(s.topic);this.logger.info(`Inactive pairings cleared: ${e.length}`)}}async checkStorage(){if(this.namespaces=await this.client.core.storage.getItem(`${p}/namespaces`)||{},this.namespaces&&this.createProviders(),this.client.session.length){const t=this.client.session.keys.length-1;this.session=this.client.session.get(this.client.session.keys[t]),this.onSessionUpdate()}}async initialize(){this.logger.trace("Initialized"),await this.createClient(),this.checkStorage(),this.registerEventListeners()}async createClient(){this.client=this.providerOpts.client||await f.init({logger:this.providerOpts.logger||h,relayUrl:this.providerOpts.relayUrl||b,projectId:this.providerOpts.projectId,metadata:this.providerOpts.metadata,storageOptions:this.providerOpts.storageOptions,name:this.providerOpts.name}),this.logger.trace("SignClient Initialized")}createProviders(){if(!this.client)throw new Error("Sign Client not initialized");Object.keys(this.namespaces).forEach(t=>{switch(t){case"eip155":this.rpcProviders[t]=new E({client:this.client,namespace:this.namespaces[t],events:this.events});break;case"solana":this.rpcProviders[t]=new q({client:this.client,namespace:this.namespaces[t],events:this.events});break;case"cosmos":this.rpcProviders[t]=new H({client:this.client,namespace:this.namespaces[t],events:this.events});break;case"polkadot":break;case"cip34":this.rpcProviders[t]=new $({client:this.client,namespace:this.namespaces[t],events:this.events});break}})}registerEventListeners(){if(typeof this.client>"u")throw new Error("Sign Client is not initialized");this.client.on("session_ping",t=>{this.events.emit("session_ping",t)}),this.client.on("session_event",t=>{const{params:e}=t,{event:s}=e;s.name==="accountsChanged"?this.events.emit("accountsChanged",s.data):s.name==="chainChanged"?this.onChainChanged(s.data,e.chainId):this.events.emit(s.name,s.data),this.events.emit("session_event",t)}),this.client.on("session_update",({topic:t,params:e})=>{var s;const{namespaces:n}=e,v=(s=this.client)==null?void 0:s.session.get(t);this.session=_(u({},v),{namespaces:n}),this.onSessionUpdate(),this.events.emit("session_update",{topic:t,params:e})}),this.client.on("session_delete",async t=>{await this.cleanup(),this.events.emit("session_delete",t)})}getProvider(t){if(!this.rpcProviders[t])throw new Error(`Provider not found: ${t}`);return this.rpcProviders[t]}onSessionUpdate(){Object.keys(this.rpcProviders).forEach(t=>{var e;this.getProvider(t).updateNamespace((e=this.session)==null?void 0:e.namespaces[t])})}setNamespaces(t){if(!t||!Object.keys(t).length)throw new Error("Namespaces must be not empty");this.client.core.storage.setItem(`${p}/namespaces`,t),this.namespaces=t}validateChain(t){const[e,s]=t?.split(":")||["",""];if(e&&!Object.keys(this.namespaces).includes(e))throw new Error(`Namespace '${e}' is not configured. Please call connect() first with namespace config.`);return!e||!s?y(this.namespaces):[e,s]}async requestAccounts(){const[t]=this.validateChain();return await this.getProvider(t).requestAccounts()}onChainChanged(t,e){const[s,n]=this.validateChain(e);this.getProvider(s).setDefaultChain(n),this.events.emit("chainChanged",t)}onConnect(){this.events.emit("connect",{session:this.session})}async cleanup(){this.session=void 0,await this.cleanupPendingPairings({deletePairings:!0})}}const U=o;export{U as UniversalProvider,o as default};
//# sourceMappingURL=index.es.js.map
