#!/usr/bin/env node
function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }

function _sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _slicedToArray(arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return _sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }

var readline = require("readline");

var _require = require("fs"),
    createReadStream = _require.createReadStream;

var _require2 = require("../tools"),
    parsers = _require2.parsers;

var _require3 = require("../compiler/compile/module"),
    createCompiledModule = _require3.createCompiledModule;

var t = require("../compiler/AST");

var _require4 = require("../interpreter"),
    Instance = _require4.Instance;

var partialEvaluation = require("../interpreter/partial-evaluation");

var _require5 = require("../interpreter/runtime/values/memory"),
    Memory = _require5.Memory;

var _require6 = require("../interpreter/kernel/memory"),
    createAllocator = _require6.createAllocator;

var _require7 = require("../compiler/parsing/wasm/decoder"),
    decode = _require7.decode;

var isVerbose = process.argv.find(function (x) {
  return x === "--debug";
}) !== undefined;

function decodeBinaryModule(node
/*: BinaryModule */
) {
  var raw = node.blob.join("");
  var chars = raw.split("");
  var out = [];

  for (var i = 0; i < chars.length; i++) {
    var e = chars[i];

    if (e === "\\") {
      // Start espace sequence
      var byte = chars[i + 1] + chars[i + 2];
      var hexInNumber = parseInt(byte, 16);
      out.push(hexInNumber);
      i = i + 2;
    } else {
      // ASCII
      var _hexInNumber = Number(chars[i].charCodeAt(0));

      out.push(_hexInNumber);
    }
  }

  decode(out);
}
/**
 * Assert helpers
 */
// ;; assert module cannot be decoded with given failure string
// ( assert_malformed <module> <failure> )


function assert_malformed(node) {
  var _node$args = _slicedToArray(node.args, 2),
      module = _node$args[0],
      expected = _node$args[1];

  if (module.type === "BinaryModule") {
    try {
      decodeBinaryModule(module);
      assert(false, "module is valid, expected malformed (".concat(expected.value, ")"));
    } catch (err) {
      assert(new RegExp(expected.value, "ig").test(err.message), "Expected failure of \"".concat(expected.value, "\", \"").concat(err.message, "\" given"));
    }
  } else {
    throw new Error("Unsupported module type: " + module.type);
  }
} // assert module traps on instantiation
// ( assert_trap <module> <failure> )


function assert_trap(node) {
  var _node$args2 = _slicedToArray(node.args, 2),
      action = _node$args2[0],
      expected = _node$args2[1];

  if (action.type === "Instr" && action.id === "invoke") {
    try {
      invoke(action);
      assert(false, "invoke is valid, expected trapped (".concat(expected.value, ")"));
    } catch (err) {
      assert(err.message.toLowerCase() === expected.value.toLowerCase(), "Expected failure of ".concat(expected.value, ", ").concat(err.message, " given"));
    }
  } else {
    throw new Error("Unsupported action: " + action.id);
  }
} // assert module is invalid with given failure string
// ( assert_invalid <module> <failure> )


function assert_invalid(node) {
  var _node$args3 = _slicedToArray(node.args, 2),
      module = _node$args3[0],
      expected = _node$args3[1];

  try {
    createModuleInstanceFromAst(module);
    assert(false, "module is valid, expected invalid (".concat(expected.value, ")"));
  } catch (err) {
    assert(new RegExp(expected.value, "ig").test(err.message), "Expected failure of \"".concat(expected.value, "\", \"").concat(err.message, "\" given"));
  }
} // assert action has expected results
// ( assert_return <action> <expr>* )
// action:
//   ( invoke <name>? <string> <expr>* )        ;; invoke function export
//   ( get <name>? <string> )                   ;; get global export


function assert_return(node) {
  var _node$args4 = _toArray(node.args),
      action = _node$args4[0],
      args = _node$args4.slice(1);

  var expectedRes;
  var expectedEvaluation = partialEvaluation.evaluate(allocator, args);

  if (expectedEvaluation !== undefined) {
    expectedRes = expectedEvaluation.value.toString();
  }

  if (action.type === "Instr" && action.id === "invoke") {
    var actualRes = invoke(action);
    assert(actualRes == expectedRes, "expected \"".concat(expectedRes, "\", \"").concat(actualRes, "\" given"));
  } else if (action.type === "Instr" && action.id === "get") {
    var id;

    if (action.args.length === 2) {
      id = action.args[1];
    } else {
      id = action.args[0];
    } // find export in instantiated module


    var module = instantiatedModules.find(function (_ref) {
      var exports = _ref.exports;
      return exports[id.value] !== undefined;
    });
    var _actualRes = module.exports[id.value];
    assert(_actualRes == expectedRes, "expected \"".concat(expectedRes, "\", \"").concat(_actualRes, "\" given"));
  } else {
    throw new Error("Unsupported action in assert_return: " + action.id);
  }
} // invoke function export
// ( invoke <name>? <string> <expr>* )


function invoke(node) {
  var _module$exports;

  var _node$args5 = _toArray(node.args),
      first = _node$args5[0],
      args = _node$args5.slice(1);

  var name = first;

  if (first.type === "Identifier") {
    // Module name
    // TODO(sven):: ignore for now since we need to add an Identifier on the
    // module
    name = args.shift();
  } // find export in instantiated module


  var module = instantiatedModules.find(function (_ref2) {
    var exports = _ref2.exports;
    return exports[name.value] !== undefined;
  });
  assert(module !== undefined, "Module with export \"".concat(name.value, "\" not found"));
  var argValues = args.map(function (expr) {
    var evaluation = partialEvaluation.evaluate(allocator, [expr]);

    if (evaluation !== undefined) {
      // Pass the raw value here since we need the LongNumber representation
      // It's only meant for testing
      if (expr.object === "i64") {
        return evaluation.value._value;
      }

      return evaluation.value.toString();
    }
  });

  var res = (_module$exports = module.exports)[name.value].apply(_module$exports, _toConsumableArray(argValues));

  return res;
}
/**
 * REPL
 */


var memory = new Memory({
  initial: 100
});
var allocator = createAllocator(memory); // Cache instanced modules

var instantiatedModules = [];
var filename = process.argv[2];

function wrapInModule(node) {
  var name = "autogenerated";
  return t.module(name, [node]);
}

function assert(cond) {
  var msg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "unknown";

  if (cond === false) {
    error(new Error("assertion failure: " + msg));

    if (filename !== undefined) {
      process.exit(1);
    }
  }

  if (isVerbose === true) {
    console.log("Assertion OK");
  }
}

function countChar(char) {
  return function (str) {
    return str.split("").reduce(function (acc, e) {
      if (e === char) {
        acc++;
      }

      return acc;
    }, 0);
  };
}

var countOpeningParens = countChar("(");
var countClosingParens = countChar(")"); // Buffer used to store incomplet user input

var buffer = "";
var openParens = 0;

function error(_ref3) {
  var message = _ref3.message;
  console.log("Error: " + message);
}

function createModuleInstanceFromAst(moduleNode) {
  var internalInstanceOptions = {
    checkForI64InSignature: false
  };
  var importObject = {
    _internalInstanceOptions: internalInstanceOptions
  };
  var module = createCompiledModule(moduleNode);
  return new Instance(module, importObject);
}

function replEval(input) {
  if (isVerbose === true) {
    console.log(input);
  }

  var ast = parsers.parseWATFSpecTest(input);

  var _ast$body = _slicedToArray(ast.body, 1),
      node = _ast$body[0]; // Empty input, skip this iteration


  if (node === undefined) {
    return;
  }

  if (node.type === "Instr") {
    if (node.id === "assert_invalid") {
      return assert_invalid(node);
    }

    if (node.id === "assert_return") {
      return assert_return(node);
    }

    if (node.id === "invoke") {
      return invoke(node);
    }

    if (node.id === "assert_return_canonical_nan") {
      throw new Error("assert_return_canonical_nan: not implemented yet");
    }

    if (node.id === "assert_return_arithmetic_nan") {
      throw new Error("assert_return_arithmetic_nan: not implemented yet");
    }

    if (node.id === "assert_trap") {
      return assert_trap(node);
    }

    if (node.id === "assert_malformed") {
      return assert_malformed(node);
    }

    if (node.id === "assert_malformed") {
      throw new Error("assert_unlinkable: not implemented yet");
    }
  } else if (node.type === "Module") {
    var instance = createModuleInstanceFromAst(node);
    prettyPrintInstance(instance);
    instantiatedModules.unshift(instance);
  } else {
    // else wrap the instruction it into a module and interpret it
    var _instance = createModuleInstanceFromAst(wrapInModule(node));

    prettyPrintInstance(_instance);
  }
}

function read(input) {
  openParens += countOpeningParens(input);
  openParens -= countClosingParens(input);
  buffer += input + "\n";

  if (openParens === 0) {
    try {
      replEval(buffer);
    } catch (err) {
      error(err);
    }

    buffer = "";
  }

  if (filename === undefined) {
    process.stdout.write(" > ");
  }
}

function prettyPrintInstance(instance) {
  if (filename !== undefined) {
    return;
  }

  var exports = Object.keys(instance.exports).map(function (name) {
    return "  export func \"".concat(name, "\"");
  });
  console.log("module:");

  if (exports.length > 0) {
    console.log(exports.join("\n"));
  } else {
    console.log("empty");
  }
}

if (filename === undefined) {
  var rl = readline.createInterface({
    input: process.stdin
  });
  process.stdout.write("wasm 1.0 JavaScript interpreter\n");
  process.stdout.write("> ");
  rl.on("line", read);
} else {
  var _rl = readline.createInterface({
    input: createReadStream(filename)
  });

  _rl.on("line", read);
}