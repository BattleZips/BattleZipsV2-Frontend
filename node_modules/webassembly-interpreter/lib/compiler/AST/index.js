"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.signature = signature;
exports.identifier = identifier;
exports.valtype = valtype;
exports.stringLiteral = stringLiteral;
exports.program = program;
exports.module = _module;
exports.binaryModule = binaryModule;
exports.quoteModule = quoteModule;
exports.moduleExport = moduleExport;
exports.func = func;
exports.objectInstruction = objectInstruction;
exports.instruction = instruction;
exports.loopInstruction = loopInstruction;
exports.blockInstruction = blockInstruction;
exports.numberLiteral = numberLiteral;
exports.callInstruction = callInstruction;
exports.ifInstruction = ifInstruction;
exports.withLoc = withLoc;
exports.moduleImport = moduleImport;
exports.globalImportDescr = globalImportDescr;
exports.funcParam = funcParam;
exports.funcImportDescr = funcImportDescr;
exports.table = table;
exports.limits = limits;
exports.memory = memory;
exports.data = data;
exports.global = global;
exports.globalType = globalType;
exports.byteArray = byteArray;
exports.leadingComment = leadingComment;
exports.blockComment = blockComment;
exports.indexLiteral = indexLiteral;
exports.memIndexLiteral = memIndexLiteral;

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var _require = require("../parsing/watf/number-literals"),
    parse32F = _require.parse32F,
    parse64F = _require.parse64F,
    parse32I = _require.parse32I,
    parse64I = _require.parse64I,
    parseU32 = _require.parseU32,
    isNanLiteral = _require.isNanLiteral,
    isInfLiteral = _require.isInfLiteral;

var _require2 = require("./signatures"),
    signatures = _require2.signatures;

function assert(cond) {
  if (!cond) {
    throw new Error("assertion error");
  }
}

function signature(object, name) {
  var opcodeName = name;

  if (object !== undefined && object !== "") {
    opcodeName = object + "." + name;
  }

  var sign = signatures[opcodeName];

  if (sign == undefined) {
    // TODO: Uncomment this when br_table and others has been done
    //throw new Error("Invalid opcode: "+opcodeName);
    return [object, object];
  }

  return sign[0];
}

function identifier(value) {
  return {
    type: "Identifier",
    value: value
  };
}

function valtype(name) {
  return {
    type: "ValtypeLiteral",
    name: name
  };
}

function stringLiteral(value) {
  return {
    type: "StringLiteral",
    value: value
  };
}

function program(body) {
  return {
    type: "Program",
    body: body
  };
}

function _module(id, fields) {
  if (id != null) {
    assert(typeof id === "string");
  }

  assert(_typeof(fields) === "object" && typeof fields.length !== "undefined");
  return {
    type: "Module",
    id: id,
    fields: fields
  };
}

function binaryModule(id, blob) {
  return {
    type: "BinaryModule",
    blob: blob,
    id: id,
    fields: []
  };
}

function quoteModule(id, string) {
  return {
    type: "QuoteModule",
    string: string,
    id: id,
    fields: []
  };
}

function moduleExport(name, type, id) {
  return {
    type: "ModuleExport",
    name: name,
    descr: {
      type: type,
      id: id
    }
  };
}

function func(name, params, result, body) {
  assert(_typeof(params) === "object" && typeof params.length !== "undefined");
  assert(_typeof(result) === "object" && typeof result.length !== "undefined");
  assert(_typeof(body) === "object" && typeof body.length !== "undefined");
  assert(typeof name !== "string");
  return {
    type: "Func",
    name: name,
    params: params,
    result: result,
    body: body
  };
}

function objectInstruction(id, object) {
  var args = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  var namedArgs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  assert(_typeof(args) === "object" && typeof args.length !== "undefined");
  assert(typeof object === "string");
  var n = {
    type: "Instr",
    id: id,
    object: object,
    args: args
  };

  if (Object.keys(namedArgs).length !== 0) {
    n.namedArgs = namedArgs;
  }

  return n;
}

function instruction(id) {
  var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var namedArgs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  assert(_typeof(args) === "object" && typeof args.length !== "undefined");
  assert(id !== "block");
  assert(id !== "if");
  assert(id !== "loop");
  var n = {
    type: "Instr",
    id: id,
    args: args
  };

  if (Object.keys(namedArgs).length !== 0) {
    n.namedArgs = namedArgs;
  }

  return n;
}

function loopInstruction(label, resulttype, instr) {
  assert(_typeof(instr) === "object" && typeof instr.length !== "undefined");
  return {
    type: "LoopInstruction",
    id: "loop",
    label: label,
    resulttype: resulttype,
    instr: instr
  };
}

function blockInstruction(label, instr, result) {
  assert(typeof label !== "undefined");
  assert(typeof label.type === "string");
  assert(_typeof(instr) === "object" && typeof instr.length !== "undefined");
  return {
    type: "BlockInstruction",
    id: "block",
    label: label,
    instr: instr,
    result: result
  };
}

function numberLiteral(rawValue) {
  var instructionType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "i32";
  var value;
  var nan = false;
  var inf = false;
  var type = "NumberLiteral";

  if (typeof rawValue === "number") {
    value = rawValue;
  } else {
    switch (instructionType) {
      case "i32":
        {
          value = parse32I(rawValue);
          break;
        }

      case "u32":
        {
          value = parseU32(rawValue);
          break;
        }

      case "i64":
        {
          type = "LongNumberLiteral";
          value = parse64I(rawValue);
          break;
        }

      case "f32":
        {
          type = "FloatLiteral";
          value = parse32F(rawValue);
          nan = isNanLiteral(rawValue);
          inf = isInfLiteral(rawValue);
          break;
        }
      // f64

      default:
        {
          type = "FloatLiteral";
          value = parse64F(rawValue);
          nan = isNanLiteral(rawValue);
          inf = isInfLiteral(rawValue);
          break;
        }
    }
  } // This is a hack to avoid rewriting all tests to have a "isnan: false" field
  // $FlowIgnore: this is correct, but flow doesn't like mutations like this


  var x = {
    type: type,
    value: value
  };

  if (nan === true) {
    // $FlowIgnore
    x.nan = true;
  }

  if (inf === true) {
    // $FlowIgnore
    x.inf = true;
  }

  return x;
}

function callInstruction(index) {
  assert(typeof index.type === "string");
  return {
    type: "CallInstruction",
    id: "call",
    index: index
  };
}

function ifInstruction(testLabel, result, test, consequent, alternate) {
  assert(typeof testLabel.type === "string");
  return {
    type: "IfInstruction",
    id: "if",
    testLabel: testLabel,
    test: test,
    result: result,
    consequent: consequent,
    alternate: alternate
  };
}

function withLoc(n, end, start) {
  var loc = {
    start: start,
    end: end
  };
  n.loc = loc;
  return n;
}
/**
 * Import
 */


function moduleImport(module, name, descr) {
  return {
    type: "ModuleImport",
    module: module,
    name: name,
    descr: descr
  };
}

function globalImportDescr(valtype, mutability) {
  return {
    type: "GlobalType",
    valtype: valtype,
    mutability: mutability
  };
}

function funcParam(valtype, id) {
  return {
    valtype: valtype,
    id: id
  };
}

function funcImportDescr(id) {
  var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var results = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  assert(_typeof(params) === "object" && typeof params.length !== "undefined");
  assert(_typeof(results) === "object" && typeof results.length !== "undefined");
  return {
    type: "FuncImportDescr",
    id: id,
    params: params,
    results: results
  };
}

function table(elementType, limits, name) {
  return {
    type: "Table",
    elementType: elementType,
    limits: limits,
    name: name
  };
}

function limits(min, max) {
  return {
    type: "Limit",
    min: min,
    max: max
  };
}

function memory(limits, id) {
  return {
    type: "Memory",
    limits: limits,
    id: id
  };
}

function data(memoryIndex, offset, init) {
  return {
    type: "Data",
    memoryIndex: memoryIndex,
    offset: offset,
    init: init
  };
}

function global(globalType, init, name) {
  return {
    type: "Global",
    globalType: globalType,
    init: init,
    name: name
  };
}

function globalType(valtype, mutability) {
  return {
    type: "GlobalType",
    valtype: valtype,
    mutability: mutability
  };
}

function byteArray(values) {
  return {
    type: "Bytes",
    values: values
  };
}

function leadingComment(value) {
  return {
    type: "LeadingComment",
    value: value
  };
}

function blockComment(value) {
  return {
    type: "BlockComment",
    value: value
  };
}

function indexLiteral(value) {
  // $FlowIgnore
  var x = numberLiteral(value, "u32");
  return x;
}

function memIndexLiteral(value) {
  // $FlowIgnore
  var x = numberLiteral(value, "u32");
  return x;
}