"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.decode = decode;

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var t = require("../../AST");

var _require = require("../../../errors"),
    CompileError = _require.CompileError;

var _require2 = require("./constants"),
    importTypes = _require2.importTypes,
    symbolsByByte = _require2.symbolsByByte,
    blockTypes = _require2.blockTypes,
    tableTypes = _require2.tableTypes,
    globalTypes = _require2.globalTypes,
    limitHasMaximum = _require2.limitHasMaximum,
    exportTypes = _require2.exportTypes,
    types = _require2.types,
    magicModuleHeader = _require2.magicModuleHeader,
    valtypes = _require2.valtypes,
    moduleVersion = _require2.moduleVersion,
    sections = _require2.sections;

var _require3 = require("./LEB128"),
    decodeUInt32 = _require3.decodeUInt32,
    MAX_NUMBER_OF_BYTE_U32 = _require3.MAX_NUMBER_OF_BYTE_U32,
    decodeUInt64 = _require3.decodeUInt64,
    MAX_NUMBER_OF_BYTE_U64 = _require3.MAX_NUMBER_OF_BYTE_U64;

var ieee754 = require("./ieee754");

var _require4 = require("./utf8"),
    utf8ArrayToStr = _require4.utf8ArrayToStr;

function toHex(n) {
  return "0x" + Number(n).toString(16);
}

function byteArrayEq(l, r) {
  if (l.length !== r.length) {
    return false;
  }

  for (var i = 0; i < l.length; i++) {
    if (l[i] !== r[i]) {
      return false;
    }
  }

  return true;
}

function decode(ab) {
  var printDump = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var buf = new Uint8Array(ab);
  var inc = 0;

  function getUniqueName() {
    var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "temp";
    inc++;
    return prefix + "_" + inc;
  }

  var offset = 0;

  function dump(b, msg) {
    if (!printDump) return;
    var pad = "\t\t\t\t\t\t\t\t\t\t";
    var str = "";

    if (b.length < 5) {
      str = b.map(toHex).join(" ");
    } else {
      str = "...";
    }

    console.log(toHex(offset) + ":\t", str, pad, ";", msg);
  }

  function dumpSep(msg) {
    if (!printDump) return;
    console.log(";", msg);
  }
  /**
   * TODO(sven): we can atually use a same structure
   * we are adding incrementally new features
   */


  var state = {
    elementsInFuncSection: [],
    elementsInExportSection: [],
    elementsInCodeSection: [],

    /**
     * Decode memory from:
     * - Memory section
     */
    memoriesInModule: [],

    /**
     * Decoded types from:
     * - Type section
     */
    typesInModule: [],

    /**
     * Decoded functions from:
     * - Function section
     * - Import section
     */
    functionsInModule: []
  };

  function eatBytes(n) {
    offset = offset + n;
  }

  function readBytes(numberOfBytes) {
    var arr = [];

    for (var i = 0; i < numberOfBytes; i++) {
      arr.push(buf[offset + i]);
    }

    return arr;
  }

  function readF64() {
    var bytes = readBytes(ieee754.NUMBER_OF_BYTE_F64);
    var buffer = Buffer.from(bytes);
    var value = ieee754.decode(buffer, 0, true, ieee754.SINGLE_PRECISION_MANTISSA, ieee754.NUMBER_OF_BYTE_F64);
    return {
      value: value,
      nextIndex: ieee754.NUMBER_OF_BYTE_F64
    };
  }

  function readF32() {
    var bytes = readBytes(ieee754.NUMBER_OF_BYTE_F32);
    var buffer = Buffer.from(bytes);
    var value = ieee754.decode(buffer, 0, true, ieee754.SINGLE_PRECISION_MANTISSA, ieee754.NUMBER_OF_BYTE_F32);
    return {
      value: value,
      nextIndex: ieee754.NUMBER_OF_BYTE_F32
    };
  }

  function readUTF8String() {
    var lenu32 = readU32();
    var len = lenu32.value;
    eatBytes(lenu32.nextIndex);
    var bytes = readBytes(len);
    var value = utf8ArrayToStr(bytes);
    return {
      value: value,
      nextIndex: len
    };
  }
  /**
   * Decode an unsigned 32bits integer
   *
   * The length will be handled by the leb librairy, we pass the max number of
   * byte.
   */


  function readU32() {
    var bytes = readBytes(MAX_NUMBER_OF_BYTE_U32);
    var buffer = Buffer.from(bytes);
    return decodeUInt32(buffer);
  }

  function readU64() {
    var bytes = readBytes(MAX_NUMBER_OF_BYTE_U64);
    var buffer = Buffer.from(bytes);
    return decodeUInt64(buffer);
  }

  function readByte() {
    return readBytes(1)[0];
  }

  function parseModuleHeader() {
    var header = readBytes(4);

    if (byteArrayEq(magicModuleHeader, header) === false) {
      throw new CompileError("magic header not detected");
    }

    dump(header, "wasm magic header");
    eatBytes(4);
  }

  function parseVersion() {
    var version = readBytes(4);

    if (byteArrayEq(moduleVersion, version) === false) {
      throw new CompileError("unknown wasm version: " + version.join(" "));
    }

    dump(version, "wasm version");
    eatBytes(4);
  }

  function parseVec(cast) {
    // Int on 1byte
    var u32 = readU32();
    var length = u32.value;
    eatBytes(u32.nextIndex);
    dump([length], "number");

    if (length === 0) {
      return [];
    }

    var elements = [];

    for (var i = 0; i < length; i++) {
      var byte = readByte();
      eatBytes(1);
      var value = cast(byte);
      dump([byte], value);

      if (typeof value === "undefined") {
        throw new CompileError("Internal failure: parseVec could not cast the value");
      }

      elements.push(value);
    }

    return elements;
  } // Type section
  // https://webassembly.github.io/spec/binary/modules.html#binary-typesec


  function parseTypeSection(numberOfTypes) {
    dump([numberOfTypes], "num types");

    for (var i = 0; i < numberOfTypes; i++) {
      dumpSep("type " + i);
      var type = readByte();
      eatBytes(1);

      if (type == types.func) {
        dump([type], "func");
        var paramValtypes = parseVec(function (b) {
          return valtypes[b];
        });
        var params = paramValtypes.map(function (v) {
          return t.funcParam(v);
        });
        var result = parseVec(function (b) {
          return valtypes[b];
        });
        state.typesInModule.push({
          params: params,
          result: result
        });
      } else {
        throw new Error("Unsupported type: " + toHex(type));
      }
    }
  } // Import section
  // https://webassembly.github.io/spec/binary/modules.html#binary-importsec


  function parseImportSection() {
    var imports = [];
    var numberOfImportsu32 = readU32();
    var numberOfImports = numberOfImportsu32.value;
    eatBytes(numberOfImportsu32.nextIndex);

    for (var i = 0; i < numberOfImports; i++) {
      /**
       * Module name
       */
      var moduleName = readUTF8String();
      eatBytes(moduleName.nextIndex);
      dump([], "module name (".concat(moduleName.value, ")"));
      /**
       * Name
       */

      var name = readUTF8String();
      eatBytes(name.nextIndex);
      dump([], "name (".concat(name.value, ")"));
      /**
       * Import descr
       */

      var descrTypeByte = readByte();
      eatBytes(1);
      var descrType = importTypes[descrTypeByte];
      dump([descrTypeByte], "import type");

      if (typeof descrType === "undefined") {
        throw new CompileError("Unknown import description type: " + toHex(descrTypeByte));
      }

      var importDescr = void 0;

      if (descrType === "func") {
        var indexU32 = readU32();
        var typeindex = indexU32.value;
        eatBytes(indexU32.nextIndex);
        dump([typeindex], "type index");
        var signature = state.typesInModule[typeindex];

        if (typeof signature === "undefined") {
          throw new CompileError("function signature not found in type section");
        }

        var id = t.identifier("".concat(moduleName.value, ".").concat(name.value));
        importDescr = t.funcImportDescr(id, signature.params, signature.result);
        state.functionsInModule.push({
          id: t.identifier(name.value),
          signature: signature,
          isExternal: true
        });
      } else if (descrType === "global") {
        importDescr = parseGlobalType();
      } else {
        throw new CompileError("Unsupported import of type: " + descrType);
      }

      imports.push(t.moduleImport(moduleName.value, name.value, importDescr));
    }

    return imports;
  } // Function section
  // https://webassembly.github.io/spec/binary/modules.html#function-section


  function parseFuncSection() {
    var numberOfFunctionsu32 = readU32();
    var numberOfFunctions = numberOfFunctionsu32.value;
    eatBytes(numberOfFunctionsu32.nextIndex);

    for (var i = 0; i < numberOfFunctions; i++) {
      var indexU32 = readU32();
      var typeindex = indexU32.value;
      eatBytes(indexU32.nextIndex);
      dump([typeindex], "type index");
      var signature = state.typesInModule[typeindex];

      if (typeof signature === "undefined") {
        throw new CompileError("function signature not found");
      }

      var id = t.identifier(getUniqueName("func"));
      state.functionsInModule.push({
        id: id,
        signature: signature,
        isExternal: false
      });
    }
  } // Export section
  // https://webassembly.github.io/spec/binary/modules.html#export-section


  function parseExportSection() {
    var u32 = readU32();
    var numberOfExport = u32.value;
    eatBytes(u32.nextIndex);
    dump([numberOfExport], "num exports"); // Parse vector of exports

    for (var i = 0; i < numberOfExport; i++) {
      /**
       * Name
       */
      var name = readUTF8String();
      eatBytes(name.nextIndex);
      dump([], "export name (".concat(name.value, ")"));
      /**
       * exportdescr
       */

      var typeIndex = readByte();
      eatBytes(1);
      dump([typeIndex], "export kind");
      var indexu32 = readU32();
      var index = indexu32.value;
      eatBytes(indexu32.nextIndex);
      dump([index], "export index");
      var id = void 0,
          signature = void 0;

      if (exportTypes[typeIndex] === "Func") {
        var func = state.functionsInModule[index];

        if (typeof func === "undefined") {
          throw new CompileError("entry not found at index ".concat(index, " in function section"));
        }

        id = func.id;
        signature = func.signature;
      } else if (exportTypes[typeIndex] === "Mem") {
        var memNode = state.memoriesInModule[index];

        if (typeof memNode === "undefined") {
          throw new CompileError("entry not found at index ".concat(index, " in memory section"));
        }

        if (memNode.id != null) {
          id = t.identifier(memNode.id.value + "");
        } else {
          id = t.identifier(getUniqueName("memory"));
        }

        signature = null;
      } else {
        throw new CompileError("Unsupported export type: " + toHex(typeIndex));
      }

      state.elementsInExportSection.push({
        name: name.value,
        type: exportTypes[typeIndex],
        signature: signature,
        id: id,
        index: index
      });
    }
  } // Code section
  // https://webassembly.github.io/spec/binary/modules.html#code-section


  function parseCodeSection() {
    var u32 = readU32();
    var numberOfFuncs = u32.value;
    eatBytes(u32.nextIndex);
    dump([numberOfFuncs], "number functions"); // Parse vector of function

    for (var i = 0; i < numberOfFuncs; i++) {
      dumpSep("function body " + i); // the u32 size of the function code in bytes
      // Ignore it for now

      var bodySizeU32 = readU32();
      eatBytes(bodySizeU32.nextIndex);
      dump([0x0], "function body size (guess)");
      var code = [];
      /**
       * Parse locals
       */

      var funcLocalNumU32 = readU32();
      var funcLocalNum = funcLocalNumU32.value;
      eatBytes(funcLocalNumU32.nextIndex);
      dump([funcLocalNum], "num locals");
      var locals = [];

      for (var _i = 0; _i < funcLocalNum; _i++) {
        var localCountU32 = readU32();
        var localCount = localCountU32.value;
        eatBytes(localCountU32.nextIndex);
        dump([localCount], "num local");
        var valtypeByte = readByte();
        eatBytes(1);
        var type = valtypes[valtypeByte];
        dump([valtypeByte], type);

        if (typeof type === "undefined") {
          throw new CompileError("Unexpected valtype: " + toHex(valtypeByte));
        }
      } // Decode instructions until the end


      parseInstructionBlock(code);
      state.elementsInCodeSection.push({
        code: code,
        locals: locals
      });
    }
  }

  function parseInstructionBlock(code) {
    while (true) {
      var instructionAlreadyCreated = false;
      var instructionByte = readByte();
      eatBytes(1);
      var instruction = symbolsByByte[instructionByte];
      dump([instructionByte], instruction.name);

      if (typeof instruction === "undefined") {
        throw new CompileError("Unexpected instruction: " + toHex(instructionByte));
      }
      /**
       * End of the function
       */


      if (instruction.name === "end") {
        break;
      }

      var args = [];

      if (instruction.name === "loop") {
        var blocktypeByte = readByte();
        eatBytes(1);
        var blocktype = blockTypes[blocktypeByte];
        dump([blocktypeByte], "blocktype");

        if (typeof blocktype === "undefined") {
          throw new CompileError("Unexpected blocktype: " + toHex(blocktypeByte));
        }

        var instr = [];
        parseInstructionBlock(instr);
        var loopNode = t.loopInstruction(null, blocktype, instr);
        code.push(loopNode);
        instructionAlreadyCreated = true;
      } else if (instruction.name === "if") {
        var _blocktypeByte = readByte();

        eatBytes(1);
        var _blocktype = blockTypes[_blocktypeByte];
        dump([_blocktypeByte], "blocktype");

        if (typeof _blocktype === "undefined") {
          throw new CompileError("Unexpected blocktype: " + toHex(_blocktypeByte));
        }

        var consequentInstr = [];
        parseInstructionBlock(consequentInstr); // FIXME(sven): handle the second block via the byte in between

        var alternate = []; // FIXME(sven): where is that stored?

        var testIndex = t.identifier(getUniqueName("ifindex"));
        var testInstrs = [];
        var ifNode = t.ifInstruction(testIndex, _blocktype, testInstrs, consequentInstr, alternate);
        code.push(ifNode);
        instructionAlreadyCreated = true;
      } else if (instruction.name === "block") {
        var _blocktypeByte2 = readByte();

        eatBytes(1);
        var _blocktype2 = blockTypes[_blocktypeByte2];
        dump([_blocktypeByte2], "blocktype");

        if (typeof _blocktype2 === "undefined") {
          throw new CompileError("Unexpected blocktype: " + toHex(_blocktypeByte2));
        }

        var _instr = [];
        parseInstructionBlock(_instr);
        var label = t.identifier(getUniqueName()); // FIXME(sven): result type is ignored?

        var blockNode = t.blockInstruction(label, _instr);
        code.push(blockNode);
        instructionAlreadyCreated = true;
      } else if (instruction.name === "call") {
        var indexu32 = readU32();
        var index = indexu32.value;
        eatBytes(indexu32.nextIndex);
        dump([index], "index");
        var callNode = t.callInstruction(t.indexLiteral(index));
        code.push(callNode);
        instructionAlreadyCreated = true;
      } else if (instruction.name === "br_table") {
        var indicesu32 = readU32();
        var indices = indicesu32.value;
        eatBytes(indicesu32.nextIndex);
        dump([indices], "num indices");

        for (var i = 0; i < indices; i++) {
          var _indexu = readU32();

          var _index = _indexu.value;
          eatBytes(_indexu.nextIndex);
          dump([_index], "index");
        }

        var labelIndexu32 = readU32();
        var labelIndex = labelIndexu32.value;
        eatBytes(labelIndexu32.nextIndex);
        dump([labelIndex], "label index");
      } else if (instructionByte >= 0x28 && instructionByte <= 0x40) {
        /**
         * Memory instructions
         */
        var aligun32 = readU32();
        var align = aligun32.value;
        eatBytes(aligun32.nextIndex);
        dump([align], "align");
        var offsetu32 = readU32();
        var _offset = offsetu32.value;
        eatBytes(offsetu32.nextIndex);
        dump([_offset], "offset");
      } else if (instructionByte >= 0x41 && instructionByte <= 0x44) {
        /**
         * Numeric instructions
         */
        if (instruction.object === "i32") {
          var valueu32 = readU32();
          var value = valueu32.value;
          eatBytes(valueu32.nextIndex);
          dump([value], "value");
          args.push(t.numberLiteral(value));
        }

        if (instruction.object === "i64") {
          var valueu64 = readU64();
          var _value = valueu64.value;
          eatBytes(valueu64.nextIndex);
          dump([_value], "value");
          args.push(t.numberLiteral(_value));
        }

        if (instruction.object === "f32") {
          var valuef32 = readF32();
          var _value2 = valuef32.value;
          eatBytes(valuef32.nextIndex);
          dump([_value2], "value");
          args.push(t.numberLiteral(_value2));
        }

        if (instruction.object === "f64") {
          var valuef64 = readF64();
          var _value3 = valuef64.value;
          eatBytes(valuef64.nextIndex);
          dump([_value3], "value");
          args.push(t.numberLiteral(_value3));
        }
      } else {
        for (var _i2 = 0; _i2 < instruction.numberOfArgs; _i2++) {
          var u32 = readU32();
          eatBytes(u32.nextIndex);
          dump([u32.value], "argument " + _i2);
          args.push(t.numberLiteral(u32.value));
        }
      }

      if (instructionAlreadyCreated === false) {
        if (typeof instruction.object === "string") {
          code.push( // $FlowIgnore
          t.objectInstruction(instruction.name, instruction.object, args));
        } else {
          code.push(t.instruction(instruction.name, args));
        }
      }
    }
  } // https://webassembly.github.io/spec/binary/modules.html#binary-tablesec


  function parseTableSection() {
    var tables = [];
    var u32 = readU32();
    var numberOfTable = u32.value;
    eatBytes(u32.nextIndex);
    dump([numberOfTable], "num tables");

    for (var i = 0; i < numberOfTable; i++) {
      var elementTypeByte = readByte();
      eatBytes(1);
      dump([elementTypeByte], "element type");
      var elementType = tableTypes[elementTypeByte];

      if (typeof elementType === "undefined") {
        throw new CompileError("Unknown element type in table: " + toHex(elementType));
      }

      var limitType = readByte();
      eatBytes(1);
      var min = void 0,
          max = void 0;

      if (limitHasMaximum[limitType] === true) {
        var u32min = readU32();
        min = u32min.value;
        eatBytes(u32min.nextIndex);
        dump([min], "min");
        var u32max = readU32();
        max = u32max.value;
        eatBytes(u32max.nextIndex);
        dump([max], "max");
      } else {
        var _u32min = readU32();

        min = _u32min.value;
        eatBytes(_u32min.nextIndex);
        dump([min], "min");
      }

      tables.push(t.table(elementType, t.limits(min, max)));
    }

    return tables;
  } // https://webassembly.github.io/spec/binary/types.html#global-types


  function parseGlobalType() {
    var valtypeByte = readByte();
    eatBytes(1);
    var type = valtypes[valtypeByte];
    dump([valtypeByte], "valtype type");

    if (typeof type === "undefined") {
      throw new CompileError("Unknown valtype: " + toHex(valtypeByte));
    }

    var globalTypeByte = readByte();
    var globalType = globalTypes[globalTypeByte];
    dump([globalTypeByte], "global type");

    if (typeof globalType === "undefined") {
      throw new CompileError("Invalid mutability: " + toHex(globalTypeByte));
    }

    return t.globalType(type, globalType);
  }

  function parseGlobalSection() {
    var globals = [];
    var numberOfGlobalsu32 = readU32();
    var numberOfGlobals = numberOfGlobalsu32.value;
    eatBytes(numberOfGlobalsu32.nextIndex);
    dump([numberOfGlobals], "num globals");

    for (var i = 0; i < numberOfGlobals; i++) {
      var globalType = parseGlobalType();
      /**
       * Global expressions
       */

      var init = [];
      parseInstructionBlock(init);
      globals.push(t.global(globalType, init));
    }

    return globals;
  }

  function parseElemSection() {
    var numberOfElementsu32 = readU32();
    var numberOfElements = numberOfElementsu32.value;
    eatBytes(numberOfElementsu32.nextIndex);
    dump([numberOfElements], "num elements");

    for (var i = 0; i < numberOfElements; i++) {
      var tableindexu32 = readU32();
      var tableindex = tableindexu32.value;
      eatBytes(tableindexu32.nextIndex);
      dump([tableindex], "table index");
      /**
       * Parse instructions
       */

      var instr = [];
      parseInstructionBlock(instr);
      /**
       * Parse ( vector function index ) *
       */

      var indicesu32 = readU32();
      var indices = indicesu32.value;
      eatBytes(indicesu32.nextIndex);
      dump([indices], "num indices");

      for (var _i3 = 0; _i3 < indices; _i3++) {
        var indexu32 = readU32();
        var index = indexu32.value;
        eatBytes(indexu32.nextIndex);
        dump([index], "index");
      }
    }
  } // https://webassembly.github.io/spec/binary/modules.html#memory-section


  function parseMemorySection() {
    var memories = [];
    var numberOfElementsu32 = readU32();
    var numberOfElements = numberOfElementsu32.value;
    eatBytes(numberOfElementsu32.nextIndex);
    dump([numberOfElements], "num elements");

    for (var i = 0; i < numberOfElements; i++) {
      var limitType = readByte();
      eatBytes(1);
      var min = void 0,
          max = void 0;

      if (limitHasMaximum[limitType] === true) {
        var u32min = readU32();
        min = u32min.value;
        eatBytes(u32min.nextIndex);
        dump([min], "min");
        var u32max = readU32();
        max = u32max.value;
        eatBytes(u32max.nextIndex);
        dump([max], "max");
      } else {
        var _u32min2 = readU32();

        min = _u32min2.value;
        eatBytes(_u32min2.nextIndex);
        dump([min], "min");
      }

      var memoryNode = t.memory(t.limits(min, max), t.indexLiteral(i));
      state.memoriesInModule.push(memoryNode);
      memories.push(memoryNode);
    }

    return memories;
  } // https://webassembly.github.io/spec/binary/modules.html#binary-startsec


  function parseStartSection() {
    var u32 = readU32();
    var startFuncIndex = u32.value;
    eatBytes(u32.nextIndex);
    dump([startFuncIndex], "index");
    var func = state.functionsInModule[startFuncIndex];

    if (typeof func === "undefined") {
      throw new CompileError("Unknown start function");
    }
  } // https://webassembly.github.io/spec/binary/modules.html#data-section


  function parseDataSection() {
    var dataEntries = [];
    var numberOfElementsu32 = readU32();
    var numberOfElements = numberOfElementsu32.value;
    eatBytes(numberOfElementsu32.nextIndex);
    dump([numberOfElements], "num elements");

    for (var i = 0; i < numberOfElements; i++) {
      var memoryIndexu32 = readU32();
      var memoryIndex = memoryIndexu32.value;
      eatBytes(memoryIndexu32.nextIndex);
      dump([memoryIndex], "memory index");
      var instrs = [];
      parseInstructionBlock(instrs);

      if (instrs.length !== 1) {
        throw new CompileError("data section offset must be a single instruction");
      }

      var bytes = parseVec(function (b) {
        return b;
      }); // FIXME(sven): the Go binary can store > 100kb of data here
      // my testing suite doesn't handle that.
      // Disabling for now.

      bytes = [];
      dump([], "init");
      dataEntries.push(t.data(t.memIndexLiteral(memoryIndex), instrs[0], t.byteArray(bytes)));
    }

    return dataEntries;
  } // https://webassembly.github.io/spec/binary/modules.html#binary-section


  function parseSection() {
    var sectionId = readByte();
    eatBytes(1);
    var u32 = readU32();
    var sectionSizeInBytes = u32.value;
    eatBytes(u32.nextIndex);

    switch (sectionId) {
      case sections.typeSection:
        {
          dumpSep("section Type");
          dump([sectionId], "section code");
          dump([0x0], "section size (ignore)");

          var _u = readU32();

          var numberOfTypes = _u.value;
          eatBytes(_u.nextIndex);
          parseTypeSection(numberOfTypes);
          break;
        }

      case sections.tableSection:
        {
          dumpSep("section Table");
          dump([sectionId], "section code");
          dump([0x0], "section size (ignore)");
          return parseTableSection();
        }

      case sections.importSection:
        {
          dumpSep("section Import");
          dump([sectionId], "section code");
          dump([0x0], "section size (ignore)");
          return parseImportSection();
        }

      case sections.funcSection:
        {
          dumpSep("section Function");
          dump([sectionId], "section code");
          dump([0x0], "section size (ignore)");
          parseFuncSection();
          break;
        }

      case sections.exportSection:
        {
          dumpSep("section Export");
          dump([sectionId], "section code");
          dump([0x0], "section size (ignore)");
          parseExportSection();
          break;
        }

      case sections.codeSection:
        {
          dumpSep("section Code");
          dump([sectionId], "section code");
          dump([0x0], "section size (ignore)");
          parseCodeSection();
          break;
        }

      case sections.startSection:
        {
          dumpSep("section Start");
          dump([sectionId], "section code");
          dump([0x0], "section size (ignore)");
          parseStartSection();
          break;
        }

      case sections.elemSection:
        {
          dumpSep("section Element");
          dump([sectionId], "section code");
          dump([0x0], "section size (ignore)");
          parseElemSection();
          break;
        }

      case sections.globalSection:
        {
          dumpSep("section Global");
          dump([sectionId], "section code");
          dump([0x0], "section size (ignore)");
          return parseGlobalSection();
        }

      case sections.memorySection:
        {
          dumpSep("section Memory");
          dump([sectionId], "section code");
          dump([0x0], "section size (ignore)");
          return parseMemorySection();
        }

      case sections.dataSection:
        {
          dumpSep("section Data");
          dump([sectionId], "section code");
          dump([0x0], "section size (ignore)");
          return parseDataSection();
        }

      case sections.customSection:
        {
          dumpSep("section Custom");
          dump([sectionId], "section code");
          dump([sectionSizeInBytes], "section size"); // We don't need to parse it, just eat all the bytes

          eatBytes(sectionSizeInBytes);
          break;
        }

      default:
        {
          throw new CompileError("Unexpected section: " + JSON.stringify(sectionId));
        }
    }

    return [];
  }

  parseModuleHeader();
  parseVersion();
  var moduleFields = [];
  /**
   * All the generate declaration are going to be stored in our state
   */

  while (offset < buf.length) {
    var nodes = parseSection();
    moduleFields.push.apply(moduleFields, _toConsumableArray(nodes));
  }
  /**
   * Transform the state into AST nodes
   */


  var funcIndex = 0;
  state.functionsInModule.forEach(function (func) {
    var params = func.signature.params;
    var result = func.signature.result;
    var body = []; // External functions doesn't provide any code, can skip it here

    if (func.isExternal === true) {
      return;
    }

    var decodedElementInCodeSection = state.elementsInCodeSection[funcIndex];
    body = decodedElementInCodeSection.code;
    funcIndex++;
    var funcNode = t.func(func.id, params, result, body);

    if (func.isExternal === true) {
      funcNode.isExternal = func.isExternal;
    }

    moduleFields.push(funcNode);
  });
  state.elementsInExportSection.forEach(function (moduleExport) {
    /**
     * If the export has no id, we won't be able to call it from the outside
     * so we can omit it
     */
    if (moduleExport.id != null) {
      moduleFields.push(t.moduleExport(moduleExport.name, moduleExport.type, moduleExport.id));
    }
  });
  dumpSep("end of program");
  var module = t.module(null, moduleFields);
  return t.program([module]);
}