var _require = require("@babel/code-frame"),
    codeFrameColumns = _require.codeFrameColumns;

function showCodeFrame(source, line, column) {
  var loc = {
    start: {
      line: line,
      column: column
    }
  };
  var out = codeFrameColumns(source, loc);
  process.stdout.write(out + "\n");
}

var WHITESPACE = /\s/;
var LETTERS = /[a-z0-9_/]/i;
var idchar = /[a-z0-9!#$%&*+./:<=>?@\\[\]^_`|~-]/i;
var valtypes = ["i32", "i64", "f32", "f64"];
var NUMBERS = /[0-9|.|_]/;
var NUMBER_KEYWORDS = /nan|inf/;
var HEX_NUMBERS = /[0-9|A-F|a-f|_|.|p|P|-]/;

function isNewLine(char) {
  return char.charCodeAt(0) === 10 || char.charCodeAt(0) === 13;
}

function Token(type, value, line, column) {
  var opts = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
  var token = {
    type: type,
    value: value,
    loc: {
      start: {
        line: line,
        column: column
      }
    }
  };

  if (Object.keys(opts).length > 0) {
    // $FlowIgnore
    token["opts"] = opts;
  }

  return token;
}

function createToken(type) {
  return function (v, line, col) {
    var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    return Token(type, v, line, col, opts);
  };
}

var tokens = {
  openParen: "openParen",
  closeParen: "closeParen",
  number: "number",
  string: "string",
  name: "name",
  identifier: "identifier",
  valtype: "valtype",
  dot: "dot",
  comment: "comment",
  equal: "equal",
  keyword: "keyword"
};
var keywords = {
  module: "module",
  func: "func",
  param: "param",
  result: "result",
  export: "export",
  loop: "loop",
  block: "block",
  if: "if",
  then: "then",
  else: "else",
  call: "call",
  import: "import",
  memory: "memory",
  table: "table",
  global: "global",
  anyfunc: "anyfunc",
  mut: "mut",
  data: "data"
};
var CloseParenToken = createToken(tokens.closeParen);
var OpenParenToken = createToken(tokens.openParen);
var NumberToken = createToken(tokens.number);
var ValtypeToken = createToken(tokens.valtype);
var NameToken = createToken(tokens.name);
var IdentifierToken = createToken(tokens.identifier);
var KeywordToken = createToken(tokens.keyword);
var DotToken = createToken(tokens.dot);
var StringToken = createToken(tokens.string);
var CommentToken = createToken(tokens.comment);
var EqualToken = createToken(tokens.equal);

function tokenize(input) {
  var current = 0; // Used by SourceLocation

  var column = 1;
  var line = 1;
  var tokens = [];

  function eatToken() {
    column++;
    current++;
  }

  while (current < input.length) {
    var char = input[current]; // ;;

    if (char === ";" && input[current + 1] === ";") {
      eatToken();
      eatToken();
      char = input[current];
      var text = "";

      while (!isNewLine(char)) {
        text += char;
        char = input[++current];

        if (char === undefined) {
          break;
        }
      } // Shift by the length of the string


      column += text.length;
      tokens.push(CommentToken(text, line, column, {
        type: "leading"
      }));
      continue;
    } // (;


    if (char === "(" && input[current + 1] === ";") {
      eatToken(); // (

      eatToken(); // ;

      char = input[current];
      var _text = ""; // ;)

      while (true) {
        char = input[current];

        if (char === ";" && input[current + 1] === ")") {
          eatToken(); // ;

          eatToken(); // )

          break;
        }

        _text += char;

        if (isNewLine(char)) {
          line++;
          column = 0;
        } else {
          column++;
        }

        eatToken();
      }

      tokens.push(CommentToken(_text, line, column, {
        type: "block"
      }));
      continue;
    }

    if (char === "(") {
      tokens.push(OpenParenToken(char, line, column));
      eatToken();
      continue;
    }

    if (char === "=") {
      tokens.push(EqualToken(char, line, column));
      eatToken();
      continue;
    }

    if (char === ")") {
      tokens.push(CloseParenToken(char, line, column));
      eatToken();
      continue;
    }

    if (isNewLine(char)) {
      line++;
      eatToken();
      column = 0;
      continue;
    }

    if (WHITESPACE.test(char)) {
      eatToken();
      continue;
    }

    if (char === "$") {
      char = input[++current];
      var value = "";

      while (idchar.test(char)) {
        value += char;
        char = input[++current];
      } // Shift by the length of the string


      column += value.length;
      tokens.push(IdentifierToken(value, line, column));
      continue;
    }

    if (NUMBERS.test(char) || NUMBER_KEYWORDS.test(input.substring(current, current + 3)) || char === "-") {
      var _value = "";

      if (char === "-") {
        _value += char;
        char = input[++current];
      }

      if (NUMBER_KEYWORDS.test(input.substring(current, current + 3))) {
        var tokenLength = 3;

        if (input.substring(current, current + 4) === "nan:") {
          tokenLength = 4;
        } else if (input.substring(current, current + 3) === "nan") {
          tokenLength = 3;
        }

        _value += input.substring(current, current + tokenLength);
        char = input[current += tokenLength];
      }

      var numberLiterals = NUMBERS;

      if (char === "0" && input[current + 1].toUpperCase() === "X") {
        _value += "0x";
        numberLiterals = HEX_NUMBERS;
        char = input[current += 2];
      }

      while (numberLiterals.test(char) || input[current - 1] === "p" && char === "+") {
        if (char !== "_") {
          _value += char;
        }

        char = input[++current];
      } // Shift by the length of the string


      column += _value.length;
      tokens.push(NumberToken(_value, line, column));
      continue;
    }

    if (char === '"') {
      var _value2 = "";
      char = input[++current];

      while (char !== '"') {
        if (isNewLine(char)) {
          throw new Error("Unterminated string constant");
        }

        _value2 += char;
        char = input[++current];
      } // Shift by the length of the string


      column += _value2.length;
      eatToken();
      tokens.push(StringToken(_value2, line, column));
      continue;
    }

    if (LETTERS.test(char)) {
      var _value3 = "";

      while (LETTERS.test(char)) {
        _value3 += char;
        char = input[++current];
      } // Shift by the length of the string


      column += _value3.length;
      /*
       * Handle MemberAccess
       */

      if (char === ".") {
        if (valtypes.indexOf(_value3) !== -1) {
          tokens.push(ValtypeToken(_value3, line, column));
        } else {
          tokens.push(NameToken(_value3, line, column));
        }

        _value3 = "";
        char = input[++current];

        while (LETTERS.test(char)) {
          _value3 += char;
          char = input[++current];
        } // Shift by the length of the string


        column += _value3.length;
        tokens.push(DotToken(".", line, column));
        tokens.push(NameToken(_value3, line, column));
        continue;
      }
      /*
       * Handle keywords
       */
      // $FlowIgnore


      if (typeof keywords[_value3] === "string") {
        tokens.push(KeywordToken(_value3, line, column)); // Shift by the length of the string

        column += _value3.length;
        continue;
      }
      /*
       * Handle types
       */


      if (valtypes.indexOf(_value3) !== -1) {
        tokens.push(ValtypeToken(_value3, line, column)); // Shift by the length of the string

        column += _value3.length;
        continue;
      }
      /*
       * Handle literals
       */


      tokens.push(NameToken(_value3, line, column)); // Shift by the length of the string

      column += _value3.length;
      continue;
    }

    showCodeFrame(input, line, column);
    throw new TypeError("Unknown char: " + char);
  }

  return tokens;
}

module.exports = {
  tokenize: tokenize,
  tokens: tokens,
  keywords: keywords
};