"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Instance = void 0;

var _hostFunc = require("./host-func");

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _require = require("../compiler/AST/traverse"),
    traverse = _require.traverse;

var modulevalue = require("./runtime/values/module");

var _require2 = require("../errors"),
    RuntimeError = _require2.RuntimeError;

var _require3 = require("../compiler/compile/module"),
    _Module = _require3.Module;

var _require4 = require("./runtime/values/table"),
    Table = _require4.Table;

var _require5 = require("./kernel/memory"),
    createAllocator = _require5.createAllocator;

var importObjectUtils = require("./import-object");

var Instance =
/**
 * Map id to external elements or callable functions
 */
function Instance(module, importObject) {
  var _this = this;

  _classCallCheck(this, Instance);

  if (module instanceof _Module === false) {
    throw new TypeError("module must be of type WebAssembly.Module, " + _typeof(module) + " given.");
  }

  this._externalElements = {};
  this.exports = {};
  /**
   * Create Module's default memory allocator
   */

  this._allocator = createAllocator();
  /**
   * Pass internal options
   */

  var internalInstanceOptions = {
    checkForI64InSignature: true
  };

  if (_typeof(importObject._internalInstanceOptions) === "object") {
    internalInstanceOptions = importObject._internalInstanceOptions;
  }
  /**
   * importObject.
   */


  if (_typeof(importObject) === "object") {
    importObjectUtils.walk(importObject, function (key, key2, value) {
      if (_typeof(_this._externalElements[key]) !== "object") {
        _this._externalElements[key] = {};
      }

      if (value instanceof Table) {
        _this._table = value;
      } else {
        _this._externalElements[key][key2] = value;
      }
    });
  }

  var moduleNode = getModuleFromProgram(module._ast);

  if (moduleNode === null) {
    throw new RuntimeError("Module not found");
  }

  var moduleInstance = modulevalue.createInstance(this._allocator, // $FlowIgnore: that's the correct type but Flow fails to get it
  moduleNode, this._externalElements);
  moduleInstance.exports.forEach(function (exportinst) {
    if (exportinst.value.type === "Func") {
      _this.exports[exportinst.name] = (0, _hostFunc.createHostfunc)(moduleInstance, exportinst, _this._allocator, internalInstanceOptions);
    }

    if (exportinst.value.type === "Global") {
      var globalinst = _this._allocator.get(exportinst.value.addr);

      if (globalinst == null) {
        throw new RuntimeError("Global instance has not been instantiated");
      }

      _this.exports[exportinst.name] = globalinst.value.toNumber();
    }

    if (exportinst.value.type === "Memory") {
      var memoryinst = _this._allocator.get(exportinst.value.addr);

      if (memoryinst == null) {
        throw new RuntimeError("Memory instance has not been instantiated");
      }

      _this.exports[exportinst.name] = memoryinst;
    }

    if (_this._table != undefined) {
      _this._table.push(_this.exports[exportinst.name]);
    }
  });
  this._moduleInstance = moduleInstance;
};

exports.Instance = Instance;

function getModuleFromProgram(ast) {
  var module = null;
  traverse(ast, {
    Module: function Module(_ref) {
      var node = _ref.node;
      module = node;
    }
  });
  return module;
}