"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.executeStackFrame = executeStackFrame;

var _memory2 = require("../runtime/values/memory");

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _slicedToArray(arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return _sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var _require = require("./instruction/binop"),
    binopi32 = _require.binopi32,
    binopi64 = _require.binopi64,
    binopf32 = _require.binopf32,
    binopf64 = _require.binopf64;

var _require2 = require("./instruction/unop"),
    unopi32 = _require2.unopi32,
    unopi64 = _require2.unopi64,
    unopf32 = _require2.unopf32,
    unopf64 = _require2.unopf64;

var _require3 = require("../runtime/castIntoStackLocalOfType"),
    castIntoStackLocalOfType = _require3.castIntoStackLocalOfType;

var i32 = require("../runtime/values/i32");

var i64 = require("../runtime/values/i64");

var f32 = require("../runtime/values/f32");

var f64 = require("../runtime/values/f64");

var label = require("../runtime/values/label");

var _require4 = require("./stackframe"),
    createChildStackFrame = _require4.createChildStackFrame;

var _require5 = require("./signals"),
    createTrap = _require5.createTrap;

var _require6 = require("../../errors"),
    RuntimeError = _require6.RuntimeError;

var t = require("../../compiler/AST"); // TODO(sven): can remove asserts call at compile to gain perf in prod


function assert(cond) {
  if (!cond) {
    throw new RuntimeError("Assertion error");
  }
}

function assertStackDepth(depth) {
  if (depth >= 300) {
    throw new RuntimeError("Maximum call stack depth reached");
  }
}

function executeStackFrame(frame) {
  var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var pc = 0;

  function createAndExecuteChildStackFrame(instrs) {
    var childStackFrame = createChildStackFrame(frame, instrs);
    childStackFrame.trace = frame.trace;
    var res = executeStackFrame(childStackFrame, depth + 1);
    pushResult(res);
  }

  function getLocalByIndex(index) {
    var local = frame.locals[index];

    if (typeof local === "undefined") {
      throw new RuntimeError("Assertion error: no local value at index " + index);
    }

    frame.values.push(local);
  }

  function setLocalByIndex(index, value) {
    assert(typeof index === "number");
    frame.locals[index] = value;
  }

  function pushResult(res) {
    if (typeof res === "undefined") {
      return;
    }

    frame.values.push(res);
  }

  function popArrayOfValTypes(types) {
    assertNItemsOnStack(frame.values, types.length);
    return types.map(function (type) {
      return pop1OfType(type);
    });
  }

  function pop1OfType(type) {
    assertNItemsOnStack(frame.values, 1);
    var v = frame.values.pop();

    if (typeof type === "string" && v.type !== type) {
      throw new RuntimeError("Internal failure: expected value of type " + type + " on top of the stack, give type: " + v.type);
    }

    return v;
  }

  function pop1() {
    assertNItemsOnStack(frame.values, 1);
    return frame.values.pop();
  }

  function pop2(type1, type2) {
    assertNItemsOnStack(frame.values, 2);
    var c2 = frame.values.pop();
    var c1 = frame.values.pop();

    if (c2.type !== type2) {
      throw new RuntimeError("Internal failure: expected c2 value of type " + type2 + " on top of the stack, give type: " + c2.type);
    }

    if (c1.type !== type1) {
      throw new RuntimeError("Internal failure: expected c1 value of type " + type1 + " on top of the stack, give type: " + c1.type);
    }

    return [c1, c2];
  }

  function getLabel(index) {
    var code;

    if (index.type === "NumberLiteral") {
      var _label = index; // WASM

      code = frame.labels.find(function (l) {
        return l.value.value === _label.value;
      });
    } else if (index.type === "Identifier") {
      var _label2 = index; // WATF

      code = frame.labels.find(function (l) {
        if (l.id == null) {
          return false;
        }

        return l.id.value === _label2.value;
      });
    }

    if (typeof code !== "undefined") {
      return code.value;
    }
  }

  function br(label) {
    var code = getLabel(label);

    if (typeof code === "undefined") {
      throw new RuntimeError("Label ".concat(label.value, " doesn't exist"));
    } // FIXME(sven): find a more generic way to handle label and its code
    // Currently func body and block instr*.


    var childStackFrame = createChildStackFrame(frame, code.body || code.instr);
    childStackFrame.trace = frame.trace;
    var res = executeStackFrame(childStackFrame, depth + 1);
    return res;
  }

  function getMemoryOffset(instruction) {
    if (instruction.namedArgs && instruction.namedArgs.offset) {
      var offset = instruction.namedArgs.offset.value;

      if (offset < 0) {
        throw new RuntimeError("offset must be positive");
      }

      if (offset > 0xffffffff) {
        throw new RuntimeError("offset must be less than or equal to 0xffffffff");
      }

      return offset;
    } else {
      return 0;
    }
  }

  function getMemory() {
    if (frame.originatingModule.memaddrs.length != 1) {
      throw new RuntimeError("unknown memory");
    }

    var memAddr = frame.originatingModule.memaddrs[0];
    return frame.allocator.get(memAddr);
  }

  assertStackDepth(depth);

  while (pc < frame.code.length) {
    var instruction = frame.code[pc];

    switch (instruction.type) {
      /**
       * Function declaration
       *
       * FIXME(sven): seems unspecified in the spec but it's required for the `call`
       * instruction.
       */
      case "Func":
        {
          var func = instruction;
          /**
           * Register the function into the stack frame labels
           */

          if (_typeof(func.name) === "object") {
            if (func.name.type === "Identifier") {
              frame.labels.push({
                value: func,
                arity: func.params.length,
                id: func.name
              });
            }
          }

          break;
        }
    }

    switch (instruction.id) {
      case "const":
        {
          // https://webassembly.github.io/spec/core/exec/instructions.html#exec-const
          var n = instruction.args[0];

          if (typeof n === "undefined") {
            throw new RuntimeError("const requires one argument, none given.");
          }

          if (n.type !== "NumberLiteral" && n.type !== "LongNumberLiteral" && n.type !== "FloatLiteral") {
            throw new RuntimeError("const: unsupported value of type: " + n.type);
          }

          pushResult(castIntoStackLocalOfType(instruction.object, n.value));
          break;
        }

      /**
       * Control Instructions
       *
       * https://webassembly.github.io/spec/core/exec/instructions.html#control-instructions
       */

      case "nop":
        {
          // Do nothing
          // https://webassembly.github.io/spec/core/exec/instructions.html#exec-nop
          break;
        }

      case "loop":
        {
          // https://webassembly.github.io/spec/core/exec/instructions.html#exec-loop
          var loop = instruction;
          assert(_typeof(loop.instr) === "object" && typeof loop.instr.length !== "undefined"); // 2. Enter the block instrâˆ— with label

          frame.labels.push({
            value: loop,
            arity: 0,
            id: t.identifier("loop" + pc) // random

          });

          if (loop.instr.length > 0) {
            createAndExecuteChildStackFrame(loop.instr);
          }

          break;
        }

      case "drop":
        {
          // https://webassembly.github.io/spec/core/exec/instructions.html#exec-drop
          // 1. Assert: due to validation, a value is on the top of the stack.
          assertNItemsOnStack(frame.values, 1); // 2. Pop the value valval from the stack.

          pop1();
          break;
        }

      case "call":
        {
          // According to the spec call doesn't support an Identifier as argument
          // but the Script syntax supports it.
          // https://webassembly.github.io/spec/core/exec/instructions.html#exec-call
          var call = instruction;

          if (call.index.type === "Identifier") {
            throw new RuntimeError("Internal compiler error: Identifier argument in call must be " + "transformed to a NumberLiteral node");
          } // WASM


          if (call.index.type === "NumberLiteral") {
            var index = call.index.value;
            assert(typeof frame.originatingModule !== "undefined"); // 2. Assert: due to validation, F.module.funcaddrs[x] exists.

            var funcaddr = frame.originatingModule.funcaddrs[index];

            if (typeof funcaddr === "undefined") {
              throw new RuntimeError("No function were found in module at address ".concat(index));
            } // 3. Let a be the function address F.module.funcaddrs[x]


            var subroutine = frame.allocator.get(funcaddr);

            if (_typeof(subroutine) !== "object") {
              throw new RuntimeError("Cannot call function at address ".concat(funcaddr, ": not a function"));
            } // 4. Invoke the function instance at address a
            // FIXME(sven): assert that res has type of resultType


            var _subroutine$type = _slicedToArray(subroutine.type, 2),
                argTypes = _subroutine$type[0],
                resultType = _subroutine$type[1];

            var args = popArrayOfValTypes(argTypes);

            if (subroutine.isExternal === false) {
              createAndExecuteChildStackFrame(subroutine.code);
            } else {
              var res = subroutine.code(args.map(function (arg) {
                return arg.value;
              }));
              pushResult(castIntoStackLocalOfType(resultType, res));
            }
          }

          break;
        }

      case "block":
        {
          var block = instruction;
          /**
           * Used to keep track of the number of values added on top of the stack
           * because we need to remove the label after the execution of this block.
           */

          var numberOfValuesAddedOnTopOfTheStack = 0;
          /**
           * When entering block push the label onto the stack
           */

          if (block.label.type === "Identifier") {
            pushResult(label.createValue(block.label.value));
          }

          assert(_typeof(block.instr) === "object" && typeof block.instr.length !== "undefined");

          if (block.instr.length > 0) {
            var oldStackSize = frame.values.length;
            createAndExecuteChildStackFrame(block.instr);
            numberOfValuesAddedOnTopOfTheStack = frame.values.length - oldStackSize;
          }
          /**
           * Wen exiting the block
           *
           * > Let m be the number of values on the top of the stack
           *
           * The Stack (values) are seperated by StackFrames and we are running on
           * one single thread, there's no need to check if values were added.
           *
           * We tracked it in numberOfValuesAddedOnTopOfTheStack anyway.
           */


          var topOfTheStack = frame.values.slice(frame.values.length - numberOfValuesAddedOnTopOfTheStack);
          frame.values.splice(frame.values.length - numberOfValuesAddedOnTopOfTheStack);
          pop1OfType("label");
          frame.values = _toConsumableArray(frame.values).concat(_toConsumableArray(topOfTheStack));
          break;
        }

      case "br_if":
        {
          var _instruction$args = _slicedToArray(instruction.args, 1),
              _label3 = _instruction$args[0]; // 1. Assert: due to validation, a value of type i32 is on the top of the stack.
          // 2. Pop the value ci32.const c from the stack.


          var c = pop1OfType("i32");

          if (!c.value.eqz().isTrue()) {
            // 3. If c is non-zero, then
            // 3. a. Execute the instruction (br l).
            var _res = br(_label3);

            pushResult(_res);
          } else {// 4. Else:
            // 4. a. Do nothing.
          }

          break;
        }

      case "if":
        {
          if (instruction.test.length > 0) {
            createAndExecuteChildStackFrame(instruction.test);
          } // 1. Assert: due to validation, a value of value type i32 is on the top of the stack.
          // 2. Pop the value i32.const from the stack.


          var _c = pop1OfType("i32");

          if (_c.value.eqz().isTrue() === false) {
            /**
             * Execute consequent
             */
            createAndExecuteChildStackFrame(instruction.consequent);
          } else if (typeof instruction.alternate !== "undefined" && instruction.alternate.length > 0) {
            /**
             * Execute alternate
             */
            createAndExecuteChildStackFrame(instruction.alternate);
          }

          break;
        }

      /**
       * Administrative Instructions
       *
       * https://webassembly.github.io/spec/core/exec/runtime.html#administrative-instructions
       */

      case "unreachable": // https://webassembly.github.io/spec/core/exec/instructions.html#exec-unreachable

      case "trap":
        {
          // signalling abrupt termination
          // https://webassembly.github.io/spec/core/exec/runtime.html#syntax-trap
          return createTrap();
        }

      /**
       * Memory Instructions
       *
       * https://webassembly.github.io/spec/core/exec/instructions.html#memory-instructions
       */

      case "get_local":
        {
          // https://webassembly.github.io/spec/core/exec/instructions.html#exec-get-local
          var _index = instruction.args[0];

          if (typeof _index === "undefined") {
            throw new RuntimeError("get_local requires one argument, none given.");
          }

          if (_index.type === "NumberLiteral" || _index.type === "FloatLiteral") {
            getLocalByIndex(_index.value);
          } else {
            throw new RuntimeError("get_local: unsupported index of type: " + _index.type);
          }

          break;
        }

      case "set_local":
        {
          // https://webassembly.github.io/spec/core/exec/instructions.html#exec-set-local
          var _index2 = instruction.args[0];
          var init = instruction.args[1];

          if (typeof init !== "undefined" && init.type === "Instr") {
            // WAST
            createAndExecuteChildStackFrame([init]);

            var _res2 = pop1();

            setLocalByIndex(_index2.value, _res2);
          } else if (_index2.type === "NumberLiteral") {
            // WASM
            // 4. Pop the value val from the stack
            var val = pop1(); // 5. Replace F.locals[x] with the value val

            setLocalByIndex(_index2.value, val);
          } else {
            throw new RuntimeError("set_local: unsupported index of type: " + _index2.type);
          }

          break;
        }

      case "tee_local":
        {
          // https://webassembly.github.io/spec/core/exec/instructions.html#exec-tee-local
          var _index3 = instruction.args[0];
          var _init = instruction.args[1];

          if (typeof _init !== "undefined" && _init.type === "Instr") {
            // WAST
            createAndExecuteChildStackFrame([_init]);

            var _res3 = pop1();

            setLocalByIndex(_index3.value, _res3);
            pushResult(_res3);
          } else if (_index3.type === "NumberLiteral") {
            // WASM
            // 1. Assert: due to validation, a value is on the top of the stack.
            // 2. Pop the value val from the stack.
            var _val = pop1(); // 3. Push the value valval to the stack.


            pushResult(_val); // 4. Push the value valval to the stack.

            pushResult(_val); // 5. Execute the instruction (set_local x).
            // 5. 4. Pop the value val from the stack

            var val2 = pop1(); // 5. 5. Replace F.locals[x] with the value val

            setLocalByIndex(_index3.value, val2);
          } else {
            throw new RuntimeError("tee_local: unsupported index of type: " + _index3.type);
          }

          break;
        }

      case "set_global":
        {
          // https://webassembly.github.io/spec/core/exec/instructions.html#exec-set-global
          var _instruction$args2 = _slicedToArray(instruction.args, 2),
              _index4 = _instruction$args2[0],
              right = _instruction$args2[1]; // Interpret right branch first if it's a child instruction


          if (typeof right !== "undefined") {
            createAndExecuteChildStackFrame([right]);
          } // 2. Assert: due to validation, F.module.globaladdrs[x] exists.


          var globaladdr = frame.originatingModule.globaladdrs[_index4.value];

          if (typeof globaladdr === "undefined") {
            throw new RuntimeError("Global address ".concat(_index4.value, " not found"));
          } // 4. Assert: due to validation, S.globals[a] exists.


          var globalinst = frame.allocator.get(globaladdr);

          if (_typeof(globalinst) !== "object") {
            throw new RuntimeError("Unexpected data for global at ".concat(globaladdr));
          } // 7. Pop the value val from the stack.


          var _val2 = pop1(); // 8. Replace glob.value with the value val.


          globalinst.value = _val2.value;
          frame.allocator.set(globaladdr, globalinst);
          break;
        }

      case "get_global":
        {
          // https://webassembly.github.io/spec/core/exec/instructions.html#exec-get-global
          var _index5 = instruction.args[0]; // 2. Assert: due to validation, F.module.globaladdrs[x] exists.

          var _globaladdr = frame.originatingModule.globaladdrs[_index5.value];

          if (typeof _globaladdr === "undefined") {
            throw new RuntimeError("Unknown global at index: ".concat(_index5.value));
          } // 4. Assert: due to validation, S.globals[a] exists.


          var _globalinst = frame.allocator.get(_globaladdr);

          if (_typeof(_globalinst) !== "object") {
            throw new RuntimeError("Unexpected data for global at ".concat(_globaladdr));
          } // 7. Pop the value val from the stack.


          pushResult(_globalinst);
          break;
        }

      case "return":
        {
          var _args = instruction.args;

          if (_args.length > 0) {
            createAndExecuteChildStackFrame(_args);
          } // Abort execution and return the first item on the stack


          return pop1();
        }

      /**
       * Memory operations
       */
      // https://webassembly.github.io/spec/core/exec/instructions.html#exec-storen

      case "store":
      case "store8":
      case "store16":
      case "store32":
        {
          var memory = getMemory();

          var _pop = pop2("i32", instruction.object),
              _pop2 = _slicedToArray(_pop, 2),
              c1 = _pop2[0],
              c2 = _pop2[1];

          var ptr = c1.value.toNumber() + getMemoryOffset(instruction);
          var valueBuffer = c2.value.toByteArray();

          switch (instruction.id) {
            case "store8":
              valueBuffer = valueBuffer.slice(0, 1);
              break;

            case "store16":
              valueBuffer = valueBuffer.slice(0, 2);
              break;

            case "store32":
              valueBuffer = valueBuffer.slice(0, 4);
              break;
          }

          if (ptr + valueBuffer.length > memory.buffer.byteLength) {
            throw new RuntimeError("memory access out of bounds");
          }

          var memoryBuffer = new Uint8Array(memory.buffer); // load / store use little-endian order

          for (var ptrOffset = 0; ptrOffset < valueBuffer.length; ptrOffset++) {
            memoryBuffer[ptr + ptrOffset] = valueBuffer[ptrOffset];
          }

          break;
        }
      // https://webassembly.github.io/spec/core/exec/instructions.html#and

      case "load":
      case "load16_s":
      case "load16_u":
      case "load8_s":
      case "load8_u":
      case "load32_s":
      case "load32_u":
        {
          var _memory = getMemory();

          var _ptr = pop1OfType("i32").value.toNumber() + getMemoryOffset(instruction); // for i32 / i64 ops, handle extended load


          var extend = 0; // for i64 values, increase the bitshift by 4 bytes

          var extendOffset = instruction.object === "i32" ? 0 : 32;
          var signed = false;

          switch (instruction.id) {
            case "load16_s":
              extend = 16 + extendOffset;
              signed = true;
              break;

            case "load16_u":
              extend = 16 + extendOffset;
              signed = false;
              break;

            case "load8_s":
              extend = 24 + extendOffset;
              signed = true;
              break;

            case "load8_u":
              extend = 24 + extendOffset;
              signed = false;
              break;

            case "load32_u":
              extend = 0 + extendOffset;
              signed = false;
              break;

            case "load32_s":
              extend = 0 + extendOffset;
              signed = true;
              break;
          } // check for memory access out of bounds


          switch (instruction.object) {
            case "i32":
            case "f32":
              if (_ptr + 4 > _memory.buffer.byteLength) {
                throw new RuntimeError("memory access out of bounds");
              }

              break;

            case "i64":
            case "f64":
              if (_ptr + 8 > _memory.buffer.byteLength) {
                throw new RuntimeError("memory access out of bounds");
              }

              break;
          }

          switch (instruction.object) {
            case "i32":
              pushResult(i32.createValueFromArrayBuffer(_memory.buffer, _ptr, extend, signed));
              break;

            case "i64":
              pushResult(i64.createValueFromArrayBuffer(_memory.buffer, _ptr, extend, signed));
              break;

            case "f32":
              pushResult(f32.createValueFromArrayBuffer(_memory.buffer, _ptr));
              break;

            case "f64":
              pushResult(f64.createValueFromArrayBuffer(_memory.buffer, _ptr));
              break;
          }

          break;
        }

      /**
       * Binary operations
       */

      case "add":
      case "mul":
      case "sub":
      /**
       * There are two seperated operation for both signed and unsigned integer,
       * but since the host environment will handle that, we don't have too :)
       */

      case "div_s":
      case "div_u":
      case "rem_s":
      case "rem_u":
      case "shl":
      case "shr_s":
      case "shr_u":
      case "rotl":
      case "rotr":
      case "div":
      case "min":
      case "max":
      case "copysign":
      case "or":
      case "xor":
      case "and":
      case "eq":
      case "ne":
      case "lt_s":
      case "lt_u":
      case "le_s":
      case "le_u":
      case "gt":
      case "gt_s":
      case "gt_u":
      case "ge_s":
      case "ge_u":
        {
          var binopFn = void 0;

          switch (instruction.object) {
            case "i32":
              binopFn = binopi32;
              break;

            case "i64":
              binopFn = binopi64;
              break;

            case "f32":
              binopFn = binopf32;
              break;

            case "f64":
              binopFn = binopf64;
              break;

            default:
              throw new RuntimeError("Unsupported operation " + instruction.id + " on " + instruction.object);
          }

          var _instruction$args3 = _slicedToArray(instruction.args, 2),
              left = _instruction$args3[0],
              _right = _instruction$args3[1]; // Interpret left branch first if it's a child instruction


          if (typeof left !== "undefined") {
            createAndExecuteChildStackFrame([left]);
          } // Interpret right branch first if it's a child instruction


          if (typeof _right !== "undefined") {
            createAndExecuteChildStackFrame([_right]);
          }

          var _pop3 = pop2(instruction.object, instruction.object),
              _pop4 = _slicedToArray(_pop3, 2),
              _c2 = _pop4[0],
              _c3 = _pop4[1];

          pushResult(binopFn(_c2, _c3, instruction.id));
          break;
        }

      /**
       * Unary operations
       */

      case "abs":
      case "neg":
      case "clz":
      case "ctz":
      case "popcnt":
      case "eqz":
      case "reinterpret/f32":
      case "reinterpret/f64":
        {
          var unopFn = void 0; // for conversion operations, the operand type appears after the forward-slash
          // e.g. with i32.reinterpret/f32, the oprand is f32, and the resultant is i32

          var opType = instruction.id.indexOf("/") !== -1 ? instruction.id.split("/")[1] : instruction.object;

          switch (opType) {
            case "i32":
              unopFn = unopi32;
              break;

            case "i64":
              unopFn = unopi64;
              break;

            case "f32":
              unopFn = unopf32;
              break;

            case "f64":
              unopFn = unopf64;
              break;

            default:
              throw new RuntimeError("Unsupported operation " + instruction.id + " on " + opType);
          }

          var _instruction$args4 = _slicedToArray(instruction.args, 1),
              operand = _instruction$args4[0]; // Interpret argument first if it's a child instruction


          if (typeof operand !== "undefined") {
            createAndExecuteChildStackFrame([operand]);
          }

          var _c4 = pop1OfType(opType);

          pushResult(unopFn(_c4, instruction.id));
          break;
        }
    }

    if (typeof frame.trace === "function") {
      frame.trace(depth, pc, instruction);
    }

    pc++;
  } // Return the item on top of the values/stack;


  if (frame.values.length > 0) {
    return pop1();
  }
}

function assertNItemsOnStack(stack, numberOfItem) {
  if (stack.length < numberOfItem) {
    throw new RuntimeError("Assertion error: expected " + numberOfItem + " on the stack, found " + stack.length);
  }
}