"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createInstance = createInstance;

var _memory = require("./memory");

var _errors = require("../../../errors");

var _require = require("../../../compiler/AST/traverse"),
    traverse = _require.traverse;

var func = require("./func");

var externvalue = require("./extern");

var global = require("./global");

var _require2 = require("../../../errors"),
    LinkError = _require2.LinkError,
    CompileError = _require2.CompileError;

var _require3 = require("./i32"),
    i32 = _require3.i32;
/**
 * Create Module's import instances
 *
 * > the indices of imports go before the first index of any definition
 * > contained in the module itself.
 * see https://webassembly.github.io/spec/core/syntax/modules.html#imports
 */


function instantiateImports(n, allocator, externalElements, internals, moduleInstance) {
  function getExternalElementOrThrow(key, key2) {
    if (typeof externalElements[key] === "undefined" || typeof externalElements[key][key2] === "undefined") {
      throw new CompileError("Unknown import ".concat(key, ".").concat(key2));
    }

    return externalElements[key][key2];
  }

  function handleFuncImport(node, descr) {
    var element = getExternalElementOrThrow(node.module, node.name);
    var params = descr.params != null ? descr.params : [];
    var results = descr.results != null ? descr.results : [];
    var externFuncinstance = externvalue.createFuncInstance(element, // $FlowIgnore
    params, results);
    var externFuncinstanceAddr = allocator.malloc(1
    /* sizeof externFuncinstance */
    );
    allocator.set(externFuncinstanceAddr, externFuncinstance);
    moduleInstance.funcaddrs.push(externFuncinstanceAddr);
  }

  function handleGlobalImport(node, descr) {
    // Validation: The mutability of globaltype must be const.
    if (descr.mutability === "var") {
      throw new CompileError("Mutable globals cannot be imported");
    }

    var element = getExternalElementOrThrow(node.module, node.name);
    var externglobalinstance = externvalue.createGlobalInstance(new i32(element), descr.valtype, descr.mutability);
    var addr = allocator.malloc(1
    /* size of the globalinstance struct */
    );
    allocator.set(addr, externglobalinstance);
    moduleInstance.globaladdrs.push(addr);
  }

  traverse(n, {
    ModuleImport: function (_ModuleImport) {
      function ModuleImport(_x) {
        return _ModuleImport.apply(this, arguments);
      }

      ModuleImport.toString = function () {
        return _ModuleImport.toString();
      };

      return ModuleImport;
    }(function (_ref) {
      var node = _ref.node;

      switch (node.descr.type) {
        case "FuncImportDescr":
          return handleFuncImport(node, node.descr);

        case "GlobalType":
          return handleGlobalImport(node, node.descr);

        default:
          throw new Error("Unsupported import of type: " + node.descr.type);
      }
    })
  });
}
/**
 * write data segments to linear memory
 */


function instantiateDataSections(n, allocator, moduleInstance) {
  traverse(n, {
    Data: function (_Data) {
      function Data(_x2) {
        return _Data.apply(this, arguments);
      }

      Data.toString = function () {
        return _Data.toString();
      };

      return Data;
    }(function (_ref2) {
      var node = _ref2.node;
      var memIndex = node.memoryIndex.value;
      var memoryAddr = moduleInstance.memaddrs[memIndex];
      var memory = allocator.get(memoryAddr);
      var buffer = new Uint8Array(memory.buffer);
      var offset;

      if (node.offset.id === "const") {
        var offsetInstruction = node.offset;
        var arg = offsetInstruction.args[0];
        offset = arg.value;
      } else if (node.offset.id === "get_global") {
        var _offsetInstruction = node.offset;
        var globalIndex = _offsetInstruction.args[0].value;
        var globalAddr = moduleInstance.globaladdrs[globalIndex];
        var globalInstance = allocator.get(globalAddr);
        offset = globalInstance.value.toNumber();
      } else {
        throw new _errors.RuntimeError("data segment offsets can only be specified as constants or globals");
      }

      for (var i = 0; i < node.init.values.length; i++) {
        buffer[i + offset] = node.init.values[i];
      }
    })
  });
}
/**
 * Create Module's internal elements instances
 */


function instantiateInternals(n, allocator, internals, moduleInstance) {
  traverse(n, {
    Func: function (_Func) {
      function Func(_x3) {
        return _Func.apply(this, arguments);
      }

      Func.toString = function () {
        return _Func.toString();
      };

      return Func;
    }(function (_ref3) {
      var node = _ref3.node;

      // Only instantiate/allocate our own functions
      if (node.isExternal === true) {
        return;
      }

      var funcinstance = func.createInstance(node, moduleInstance);
      var addr = allocator.malloc(1
      /* size of the funcinstance struct */
      );
      allocator.set(addr, funcinstance);
      moduleInstance.funcaddrs.push(addr);

      if (node.name != null) {
        if (node.name.type === "Identifier") {
          internals.instantiatedFuncs[node.name.value] = addr;
        }
      }
    }),
    Table: function (_Table) {
      function Table(_x4) {
        return _Table.apply(this, arguments);
      }

      Table.toString = function () {
        return _Table.toString();
      };

      return Table;
    }(function (_ref4) {
      var node = _ref4.node;
      // TODO(sven): implement exporting a Table instance
      var tableinstance = null;
      var addr = allocator.malloc(1
      /* size of the tableinstance struct */
      );
      allocator.set(addr, tableinstance);
      moduleInstance.tableaddrs.push(addr);

      if (node.name != null) {
        if (node.name.type === "Identifier") {
          internals.instantiatedTables[node.name.value] = addr;
        }
      }
    }),
    Memory: function Memory(_ref5) {
      var node = _ref5.node;
      // $FlowIgnore: see type Memory in src/types/AST.js
      var limits = node.limits;

      if (limits.max && limits.max < limits.min) {
        throw new _errors.RuntimeError("size minimum must not be greater than maximum");
      }

      if (limits.min > 65536) {
        throw new _errors.RuntimeError("memory size must be at most 65536 pages (4GiB)");
      }

      var memoryDescriptor = {
        initial: limits.min,
        maximum: limits.max
      };
      var memoryinstance = new _memory.Memory(memoryDescriptor);
      var addr = allocator.malloc(1
      /* size of the memoryinstance struct */
      );
      allocator.set(addr, memoryinstance);
      moduleInstance.memaddrs.push(addr);

      if (node.id != null) {
        if (node.id.type === "Identifier") {
          // $FlowIgnore
          internals.instantiatedMemories[node.id.value] = addr;
        }
      }
    },
    Global: function (_Global) {
      function Global(_x5) {
        return _Global.apply(this, arguments);
      }

      Global.toString = function () {
        return _Global.toString();
      };

      return Global;
    }(function (_ref6) {
      var node = _ref6.node;
      var globalinstance = global.createInstance(allocator, node);
      var addr = allocator.malloc(1
      /* size of the globalinstance struct */
      );
      allocator.set(addr, globalinstance);
      moduleInstance.globaladdrs.push(addr);

      if (node.name != null) {
        if (node.name.type === "Identifier") {
          internals.instantiatedGlobals[node.name.value] = {
            addr: addr,
            type: node.globalType
          };
        }
      }
    })
  });
}
/**
 * Create Module's exports instances
 *
 * The `internals` argument reference already instantiated elements
 */


function instantiateExports(n, allocator, internals, moduleInstance) {
  function assertNotAlreadyExported(str) {
    var moduleInstanceExport = moduleInstance.exports.find(function (_ref7) {
      var name = _ref7.name;
      return name === str;
    });

    if (moduleInstanceExport !== undefined) {
      throw new CompileError("Duplicate export name");
    }
  }

  traverse(n, {
    ModuleExport: function (_ModuleExport) {
      function ModuleExport(_x6) {
        return _ModuleExport.apply(this, arguments);
      }

      ModuleExport.toString = function () {
        return _ModuleExport.toString();
      };

      return ModuleExport;
    }(function (_ref8) {
      var node = _ref8.node;

      if (node.descr.type === "Func") {
        // Referenced by its index in the module.funcaddrs
        if (node.descr.id.type === "NumberLiteral") {
          var index = node.descr.id.value;
          var funcinstaddr = moduleInstance.funcaddrs[index];

          if (funcinstaddr === undefined) {
            throw new CompileError("Unknown function");
          }

          var externalVal = {
            type: node.descr.type,
            addr: funcinstaddr
          };
          assertNotAlreadyExported(node.name);
          moduleInstance.exports.push(createModuleExportIntance(node.name, externalVal));
        } // Referenced by its identifier


        if (node.descr.id.type === "Identifier") {
          var instantiatedFuncAddr = internals.instantiatedFuncs[node.descr.id.value];

          if (typeof instantiatedFuncAddr === "undefined") {
            throw new Error("Cannot create exportinst: function " + node.descr.id.value + " was not declared or instantiated");
          }

          var _externalVal = {
            type: node.descr.type,
            addr: instantiatedFuncAddr
          };
          assertNotAlreadyExported(node.name);
          moduleInstance.exports.push(createModuleExportIntance(node.name, _externalVal));
        }
      }

      if (node.descr.type === "Global") {
        // Referenced by its index in the module.globaladdrs
        if (node.descr.id.type === "NumberLiteral") {
          var _index = node.descr.id.value;
          var globalinstaddr = moduleInstance.globaladdrs[_index];

          if (globalinstaddr === undefined) {
            throw new CompileError("Unknown global");
          }

          var globalinst = allocator.get(globalinstaddr);

          if (globalinst.mutability === "var") {
            throw new CompileError("Mutable globals cannot be exported");
          }

          var _externalVal2 = {
            type: node.descr.type,
            addr: globalinstaddr
          };
          assertNotAlreadyExported(node.name);
          moduleInstance.exports.push(createModuleExportIntance(node.name, _externalVal2));
        } // Referenced by its identifier


        if (node.descr.id.type === "Identifier") {
          var instantiatedGlobal = internals.instantiatedGlobals[node.descr.id.value];

          if (instantiatedGlobal.type.mutability === "var") {
            throw new CompileError("Mutable globals cannot be exported");
          }

          if (instantiatedGlobal.type.valtype === "i64") {
            throw new LinkError("Export of globals of type i64 is not allowed");
          }

          var _externalVal3 = {
            type: node.descr.type,
            addr: instantiatedGlobal.addr
          };
          assertNotAlreadyExported(node.name);
          moduleInstance.exports.push(createModuleExportIntance(node.name, _externalVal3));
        }
      }

      if (node.descr.type === "Table") {
        // Referenced by its identifier
        if (node.descr.id.type === "Identifier") {
          var instantiatedTable = internals.instantiatedTables[node.descr.id.value];
          var _externalVal4 = {
            type: node.descr.type,
            addr: instantiatedTable
          };
          assertNotAlreadyExported(node.name);
          moduleInstance.exports.push(createModuleExportIntance(node.name, _externalVal4));
        } // Referenced by its index in the module.tableaddrs


        if (node.descr.id.type === "NumberLiteral") {
          var _index2 = node.descr.id.value;
          var tableinstaddr = moduleInstance.tableaddrs[_index2];
          var _externalVal5 = {
            type: node.descr.type,
            addr: tableinstaddr
          };
          assertNotAlreadyExported(node.name);

          if (tableinstaddr === undefined) {
            throw new CompileError("Unknown table");
          }

          moduleInstance.exports.push(createModuleExportIntance(node.name, _externalVal5));
        }
      }

      if (node.descr.type === "Memory") {
        // Referenced by its identifier
        if (node.descr.id.type === "Identifier") {
          var instantiatedMemory = internals.instantiatedMemories[node.descr.id.value];
          var _externalVal6 = {
            type: node.descr.type,
            addr: instantiatedMemory
          };
          assertNotAlreadyExported(node.name);
          moduleInstance.exports.push(createModuleExportIntance(node.name, _externalVal6));
        } // Referenced by its index in the module.memaddrs


        if (node.descr.id.type === "NumberLiteral") {
          var _index3 = node.descr.id.value;
          var meminstaddr = moduleInstance.memaddrs[_index3];
          var _externalVal7 = {
            type: node.descr.type,
            addr: meminstaddr
          };
          assertNotAlreadyExported(node.name);

          if (meminstaddr === undefined) {
            throw new CompileError("Unknown memory");
          }

          moduleInstance.exports.push(createModuleExportIntance(node.name, _externalVal7));
        }
      }
    })
  });
}

function createInstance(allocator, n) {
  var externalElements = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  // Keep a ref to the module instance
  var moduleInstance = {
    types: [],
    funcaddrs: [],
    tableaddrs: [],
    memaddrs: [],
    globaladdrs: [],
    exports: []
  };
  /**
   * Keep the function that were instantiated and re-use their addr in
   * the export wrapper
   */

  var instantiatedInternals = {
    instantiatedFuncs: {},
    instantiatedGlobals: {},
    instantiatedTables: {},
    instantiatedMemories: {}
  };
  instantiateImports(n, allocator, externalElements, instantiatedInternals, moduleInstance);
  instantiateInternals(n, allocator, instantiatedInternals, moduleInstance);
  instantiateDataSections(n, allocator, moduleInstance);
  instantiateExports(n, allocator, instantiatedInternals, moduleInstance);
  return moduleInstance;
}

function createModuleExportIntance(name, value) {
  return {
    name: name,
    value: value
  };
}